// This file is @generated by generator/rust-component.js. Do not edit by hand.

pub mod types {
    use serde::{Deserialize, Serialize};
    pub use serde_json::Value;

    #[derive(Debug, Clone, Serialize, Deserialize)]
    #[serde(untagged)]
    pub enum RangeParam {
        Single(u64),
        Range([u64; 2]),
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AddconnectionResult {
        /// Address of newly added connection.
        pub address: String,
        /// Type of connection opened.
        pub connection_type: String,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AddpeeraddressResult {
        /// whether the peer address was successfully added to the address manager table
        pub success: bool,
        /// error description, if the address could not be added
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub error: Option<String>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AnalyzepsbtResultInputsItemMissing {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pubkeys: Option<Vec<String>>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub signatures: Option<Vec<String>>,
        /// Hash160 of the redeem script that is missing
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub redeemscript: Option<String>,
        /// SHA256 of the witness script that is missing
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub witnessscript: Option<String>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AnalyzepsbtResultInputsItem {
        /// Whether a UTXO is provided
        pub has_utxo: bool,
        /// Whether the input is finalized
        pub is_final: bool,
        /// Things that are missing that are required to complete this input
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub missing: Option<AnalyzepsbtResultInputsItemMissing>,
        /// Role of the next person that this input needs to go to
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next: Option<String>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct AnalyzepsbtResult {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub inputs: Option<Vec<AnalyzepsbtResultInputsItem>>,
        /// Estimated vsize of the final signed transaction
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub estimated_vsize: Option<f64>,
        /// Estimated feerate of the final signed transaction in BTC/kvB. Shown only if all UTXO slots in the PSBT have been filled
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub estimated_feerate: Option<rust_decimal::Decimal>,
        /// The transaction fee paid. Shown only if all UTXO slots in the PSBT have been filled
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fee: Option<rust_decimal::Decimal>,
        /// Role of the next person that this psbt needs to go to
        pub next: String,
        /// Error message (if there is one)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub error: Option<String>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct BumpfeeOptions {
        /// Confirmation target in blocks
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub conf_target: Option<f64>,
        /// Specify a fee rate in sat/vB instead of relying on the built-in fee estimator.
        /// Must be at least 0.100 sat/vB higher than the current transaction fee rate.
        /// WARNING: before version 0.21, fee_rate was in BTC/kvB. As of 0.21, fee_rate is in sat/vB.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fee_rate: Option<rust_decimal::Decimal>,
        /// Whether the new transaction should be
        /// marked bip-125 replaceable. If true, the sequence numbers in the transaction will
        /// be set to 0xfffffffd. If false, any input sequence numbers in the
        /// transaction will be set to 0xfffffffe
        /// so the new transaction will not be explicitly bip-125 replaceable (though it may
        /// still be replaceable in practice, for example if it has unconfirmed ancestors which
        /// are replaceable).
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub replaceable: Option<bool>,
        /// The fee estimate mode, must be one of (case insensitive):
        /// unset, economical, conservative
        /// unset means no mode set (economical mode is used if the transaction is replaceable;
        /// otherwise, conservative mode is used).
        /// economical estimates use a shorter time horizon, making them more
        /// responsive to short-term drops in the prevailing fee market. This mode
        /// potentially returns a lower fee rate estimate.
        /// conservative estimates use a longer time horizon, making them
        /// less responsive to short-term drops in the prevailing fee market. This mode
        /// potentially returns a higher fee rate estimate.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub estimate_mode: Option<String>,
        /// The outputs specified as key-value pairs.
        /// Each key may only appear once, i.e. there can only be one 'data' output, and no address may be duplicated.
        /// At least one output of either type must be specified.
        /// Cannot be provided if 'original_change_index' is specified.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub outputs: Option<Vec<Value>>,
        /// The 0-based index of the change output on the original transaction. The indicated output will be recycled into the new change output on the bumped transaction. The remainder after paying the recipients and fees will be sent to the output script of the original change output. The change outputâ€™s amount can increase if bumping the transaction adds new inputs, otherwise it will decrease. Cannot be used in combination with the 'outputs' option.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub original_change_index: Option<f64>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct BumpfeeResult {
        /// The id of the new transaction.
        pub txid: String,
        /// The fee of the replaced transaction.
        pub origfee: rust_decimal::Decimal,
        /// The fee of the new transaction.
        pub fee: rust_decimal::Decimal,
        /// Errors encountered during processing (may be empty).
        pub errors: Vec<String>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CreatemultisigResult {
        /// The value of the new multisig address.
        pub address: String,
        /// The string value of the hex-encoded redemption script.
        #[serde(rename = "redeemScript")]
        pub redeem_script: String,
        /// The descriptor for this multisig
        pub descriptor: String,
        /// Any warnings resulting from the creation of this multisig
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub warnings: Option<Vec<String>>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CreatepsbtInputsItem {
        /// The transaction id
        pub txid: String,
        /// The output number
        pub vout: f64,
        /// The sequence number
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub sequence: Option<f64>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CreaterawtransactionInputsItem {
        /// The transaction id
        pub txid: String,
        /// The output number
        pub vout: f64,
        /// The sequence number
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub sequence: Option<f64>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CreatewalletResult {
        /// The wallet name if created successfully. If the wallet was created using a full path, the wallet_name will be the full path.
        pub name: String,
        /// Warning messages, if any, related to creating and loading the wallet.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub warnings: Option<Vec<String>>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CreatewalletdescriptorOptions {
        /// Whether to only make one descriptor that is internal (if parameter is true) or external (if parameter is false)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub internal: Option<bool>,
        /// The HD key that the wallet knows the private key of, listed using 'gethdkeys', to use for this descriptor's key
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub hdkey: Option<String>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct CreatewalletdescriptorResult {
        /// The public descriptors that were added to the wallet
        pub descs: Vec<String>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DecodepsbtResultGlobalXpubsItem {
        /// The extended public key this path corresponds to
        pub xpub: String,
        /// The fingerprint of the master key
        pub master_fingerprint: String,
        /// The path
        pub path: String,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DecodepsbtResultProprietaryItem {
        /// The hex string for the proprietary identifier
        pub identifier: String,
        /// The number for the subtype
        pub subtype: f64,
        /// The hex for the key
        pub key: String,
        /// The hex for the value
        pub value: String,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DecodepsbtResultInputsItemWitnessUtxoScriptPubKey {
        /// Disassembly of the output script
        pub asm: String,
        /// Inferred descriptor for the output
        pub desc: String,
        /// The raw output script bytes, hex-encoded
        pub hex: String,
        /// The type, eg 'pubkeyhash'
        #[serde(rename = "type")]
        pub type_: String,
        /// The Bitcoin address (only if a well-defined address exists)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub address: Option<String>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DecodepsbtResultInputsItemWitnessUtxo {
        /// The value in BTC
        pub amount: f64,
        #[serde(rename = "scriptPubKey")]
        pub script_pub_key: DecodepsbtResultInputsItemWitnessUtxoScriptPubKey,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DecodepsbtResultInputsItemRedeemScript {
        /// Disassembly of the redeem script
        pub asm: String,
        /// The raw redeem script bytes, hex-encoded
        pub hex: String,
        /// The type, eg 'pubkeyhash'
        #[serde(rename = "type")]
        pub type_: String,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DecodepsbtResultInputsItemWitnessScript {
        /// Disassembly of the witness script
        pub asm: String,
        /// The raw witness script bytes, hex-encoded
        pub hex: String,
        /// The type, eg 'pubkeyhash'
        #[serde(rename = "type")]
        pub type_: String,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DecodepsbtResultInputsItemBip32DerivsItem {
        /// The public key with the derivation path as the value.
        pub pubkey: String,
        /// The fingerprint of the master key
        pub master_fingerprint: String,
        /// The path
        pub path: String,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DecodepsbtResultInputsItemFinalScriptSig {
        /// Disassembly of the final signature script
        pub asm: String,
        /// The raw final signature script bytes, hex-encoded
        pub hex: String,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DecodepsbtResultInputsItemTaprootScriptPathSigsItem {
        /// The x-only pubkey for this signature
        pub pubkey: String,
        /// The leaf hash for this signature
        pub leaf_hash: String,
        /// The signature itself
        pub sig: String,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DecodepsbtResultInputsItemTaprootScriptsItem {
        /// A leaf script
        pub script: String,
        /// The version number for the leaf script
        pub leaf_ver: f64,
        /// The control blocks for this script
        pub control_blocks: Vec<String>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DecodepsbtResultInputsItemTaprootBip32DerivsItem {
        /// The x-only public key this path corresponds to
        pub pubkey: String,
        /// The fingerprint of the master key
        pub master_fingerprint: String,
        /// The path
        pub path: String,
        /// The hashes of the leaves this pubkey appears in
        pub leaf_hashes: Vec<String>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DecodepsbtResultInputsItemMusig2ParticipantPubkeysItem {
        /// The compressed aggregate public key for which the participants create.
        pub aggregate_pubkey: String,
        pub participant_pubkeys: Vec<String>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DecodepsbtResultInputsItemMusig2PubnoncesItem {
        /// The compressed public key of the participant that created this pubnonce.
        pub participant_pubkey: String,
        /// The compressed aggregate public key for which this pubnonce is for.
        pub aggregate_pubkey: String,
        /// The hash of the leaf script that contains the aggregate pubkey being signed for. Omitted when signing for the internal key.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub leaf_hash: Option<String>,
        /// The public nonce itself.
        pub pubnonce: String,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DecodepsbtResultInputsItemMusig2PartialSigsItem {
        /// The compressed public key of the participant that created this partial signature.
        pub participant_pubkey: String,
        /// The compressed aggregate public key for which this partial signature is for.
        pub aggregate_pubkey: String,
        /// The hash of the leaf script that contains the aggregate pubkey being signed for. Omitted when signing for the internal key.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub leaf_hash: Option<String>,
        /// The partial signature itself.
        pub partial_sig: String,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DecodepsbtResultInputsItemProprietaryItem {
        /// The hex string for the proprietary identifier
        pub identifier: String,
        /// The number for the subtype
        pub subtype: f64,
        /// The hex for the key
        pub key: String,
        /// The hex for the value
        pub value: String,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DecodepsbtResultInputsItem {
        /// Decoded network transaction for non-witness UTXOs
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub non_witness_utxo: Option<std::collections::BTreeMap<String, Value>>,
        /// Transaction output for witness UTXOs
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub witness_utxo: Option<DecodepsbtResultInputsItemWitnessUtxo>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub partial_signatures: Option<std::collections::BTreeMap<String, String>>,
        /// The sighash type to be used
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub sighash: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub redeem_script: Option<DecodepsbtResultInputsItemRedeemScript>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub witness_script: Option<DecodepsbtResultInputsItemWitnessScript>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub bip32_derivs: Option<Vec<DecodepsbtResultInputsItemBip32DerivsItem>>,
        #[serde(rename = "final_scriptSig")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub final_script_sig: Option<DecodepsbtResultInputsItemFinalScriptSig>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub final_scriptwitness: Option<Vec<String>>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ripemd160_preimages: Option<std::collections::BTreeMap<String, String>>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub sha256_preimages: Option<std::collections::BTreeMap<String, String>>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub hash160_preimages: Option<std::collections::BTreeMap<String, String>>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub hash256_preimages: Option<std::collections::BTreeMap<String, String>>,
        /// hex-encoded signature for the Taproot key path spend
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub taproot_key_path_sig: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub taproot_script_path_sigs: Option<Vec<DecodepsbtResultInputsItemTaprootScriptPathSigsItem>>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub taproot_scripts: Option<Vec<DecodepsbtResultInputsItemTaprootScriptsItem>>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub taproot_bip32_derivs: Option<Vec<DecodepsbtResultInputsItemTaprootBip32DerivsItem>>,
        /// The hex-encoded Taproot x-only internal key
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub taproot_internal_key: Option<String>,
        /// The hex-encoded Taproot merkle root
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub taproot_merkle_root: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub musig2_participant_pubkeys: Option<Vec<DecodepsbtResultInputsItemMusig2ParticipantPubkeysItem>>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub musig2_pubnonces: Option<Vec<DecodepsbtResultInputsItemMusig2PubnoncesItem>>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub musig2_partial_sigs: Option<Vec<DecodepsbtResultInputsItemMusig2PartialSigsItem>>,
        /// The unknown input fields
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub unknown: Option<std::collections::BTreeMap<String, String>>,
        /// The input proprietary map
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub proprietary: Option<Vec<DecodepsbtResultInputsItemProprietaryItem>>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DecodepsbtResultOutputsItemRedeemScript {
        /// Disassembly of the redeem script
        pub asm: String,
        /// The raw redeem script bytes, hex-encoded
        pub hex: String,
        /// The type, eg 'pubkeyhash'
        #[serde(rename = "type")]
        pub type_: String,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DecodepsbtResultOutputsItemWitnessScript {
        /// Disassembly of the witness script
        pub asm: String,
        /// The raw witness script bytes, hex-encoded
        pub hex: String,
        /// The type, eg 'pubkeyhash'
        #[serde(rename = "type")]
        pub type_: String,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DecodepsbtResultOutputsItemBip32DerivsItem {
        /// The public key this path corresponds to
        pub pubkey: String,
        /// The fingerprint of the master key
        pub master_fingerprint: String,
        /// The path
        pub path: String,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DecodepsbtResultOutputsItemTaprootTreeItem {
        /// The depth of this element in the tree
        pub depth: f64,
        /// The version of this leaf
        pub leaf_ver: f64,
        /// The hex-encoded script itself
        pub script: String,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DecodepsbtResultOutputsItemTaprootBip32DerivsItem {
        /// The x-only public key this path corresponds to
        pub pubkey: String,
        /// The fingerprint of the master key
        pub master_fingerprint: String,
        /// The path
        pub path: String,
        /// The hashes of the leaves this pubkey appears in
        pub leaf_hashes: Vec<String>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DecodepsbtResultOutputsItemMusig2ParticipantPubkeysItem {
        /// The compressed aggregate public key for which the participants create.
        pub aggregate_pubkey: String,
        pub participant_pubkeys: Vec<String>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DecodepsbtResultOutputsItemProprietaryItem {
        /// The hex string for the proprietary identifier
        pub identifier: String,
        /// The number for the subtype
        pub subtype: f64,
        /// The hex for the key
        pub key: String,
        /// The hex for the value
        pub value: String,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DecodepsbtResultOutputsItem {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub redeem_script: Option<DecodepsbtResultOutputsItemRedeemScript>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub witness_script: Option<DecodepsbtResultOutputsItemWitnessScript>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub bip32_derivs: Option<Vec<DecodepsbtResultOutputsItemBip32DerivsItem>>,
        /// The hex-encoded Taproot x-only internal key
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub taproot_internal_key: Option<String>,
        /// The tuples that make up the Taproot tree, in depth first search order
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub taproot_tree: Option<Vec<DecodepsbtResultOutputsItemTaprootTreeItem>>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub taproot_bip32_derivs: Option<Vec<DecodepsbtResultOutputsItemTaprootBip32DerivsItem>>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub musig2_participant_pubkeys: Option<Vec<DecodepsbtResultOutputsItemMusig2ParticipantPubkeysItem>>,
        /// The unknown output fields
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub unknown: Option<std::collections::BTreeMap<String, String>>,
        /// The output proprietary map
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub proprietary: Option<Vec<DecodepsbtResultOutputsItemProprietaryItem>>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DecodepsbtResult {
        /// The decoded network-serialized unsigned transaction.
        pub tx: std::collections::BTreeMap<String, Value>,
        pub global_xpubs: Vec<DecodepsbtResultGlobalXpubsItem>,
        /// The PSBT version number. Not to be confused with the unsigned transaction version
        pub psbt_version: f64,
        /// The global proprietary map
        pub proprietary: Vec<DecodepsbtResultProprietaryItem>,
        /// The unknown global fields
        pub unknown: std::collections::BTreeMap<String, String>,
        pub inputs: Vec<DecodepsbtResultInputsItem>,
        pub outputs: Vec<DecodepsbtResultOutputsItem>,
        /// The transaction fee paid if all UTXOs slots in the PSBT have been filled.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fee: Option<rust_decimal::Decimal>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DecoderawtransactionResultVinItemScriptSig {
        /// Disassembly of the signature script
        pub asm: String,
        /// The raw signature script bytes, hex-encoded
        pub hex: String,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DecoderawtransactionResultVinItem {
        /// The coinbase value (only if coinbase transaction)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub coinbase: Option<String>,
        /// The transaction id (if not coinbase transaction)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub txid: Option<String>,
        /// The output number (if not coinbase transaction)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub vout: Option<f64>,
        /// The script (if not coinbase transaction)
        #[serde(rename = "scriptSig")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub script_sig: Option<DecoderawtransactionResultVinItemScriptSig>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub txinwitness: Option<Vec<String>>,
        /// The script sequence number
        pub sequence: f64,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DecoderawtransactionResultVoutItemScriptPubKey {
        /// Disassembly of the output script
        pub asm: String,
        /// Inferred descriptor for the output
        pub desc: String,
        /// The raw output script bytes, hex-encoded
        pub hex: String,
        /// The Bitcoin address (only if a well-defined address exists)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub address: Option<String>,
        /// The type (one of: nonstandard, anchor, pubkey, pubkeyhash, scripthash, multisig, nulldata, witness_v0_scripthash, witness_v0_keyhash, witness_v1_taproot, witness_unknown)
        #[serde(rename = "type")]
        pub type_: String,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DecoderawtransactionResultVoutItem {
        /// The value in BTC
        pub value: rust_decimal::Decimal,
        /// index
        pub n: f64,
        #[serde(rename = "scriptPubKey")]
        pub script_pub_key: DecoderawtransactionResultVoutItemScriptPubKey,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DecoderawtransactionResult {
        /// The transaction id
        pub txid: String,
        /// The transaction hash (differs from txid for witness transactions)
        pub hash: String,
        /// The serialized transaction size
        pub size: f64,
        /// The virtual transaction size (differs from size for witness transactions)
        pub vsize: f64,
        /// The transaction's weight (between vsize*4-3 and vsize*4)
        pub weight: f64,
        /// The version
        pub version: f64,
        /// The lock time
        pub locktime: i64,
        pub vin: Vec<DecoderawtransactionResultVinItem>,
        pub vout: Vec<DecoderawtransactionResultVoutItem>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DecodescriptResultSegwit {
        /// Disassembly of the output script
        pub asm: String,
        /// The raw output script bytes, hex-encoded
        pub hex: String,
        /// The type of the output script (e.g. witness_v0_keyhash or witness_v0_scripthash)
        #[serde(rename = "type")]
        pub type_: String,
        /// The Bitcoin address (only if a well-defined address exists)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub address: Option<String>,
        /// Inferred descriptor for the script
        pub desc: String,
        /// address of the P2SH script wrapping this witness redeem script
        #[serde(rename = "p2sh-segwit")]
        pub p2sh_segwit: String,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DecodescriptResult {
        /// Disassembly of the script
        pub asm: String,
        /// Inferred descriptor for the script
        pub desc: String,
        /// The output type (e.g. nonstandard, anchor, pubkey, pubkeyhash, scripthash, multisig, nulldata, witness_v0_scripthash, witness_v0_keyhash, witness_v1_taproot, witness_unknown)
        #[serde(rename = "type")]
        pub type_: String,
        /// The Bitcoin address (only if a well-defined address exists)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub address: Option<String>,
        /// address of P2SH script wrapping this redeem script (not returned for types that should not be wrapped)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub p2sh: Option<String>,
        /// Result of a witness output script wrapping this redeem script (not returned for types that should not be wrapped)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub segwit: Option<DecodescriptResultSegwit>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    #[serde(untagged)]
    pub enum DeriveaddressesResult {
        /// for single derivation descriptors
        Variant0(Vec<String>),
        /// The derived addresses for each of the multipath expansions of the descriptor, in multipath specifier order
        Variant1(Vec<Vec<String>>),
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DescriptorprocesspsbtResult {
        /// The base64-encoded partially signed transaction
        pub psbt: String,
        /// If the transaction has a complete set of signatures
        pub complete: bool,
        /// The hex-encoded network transaction if complete
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub hex: Option<String>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DumptxoutsetOptions {
        /// Height or hash of the block to roll back to before creating the snapshot. Note: The further this number is from the tip, the longer this process will take. Consider setting a higher -rpcclienttimeout value in this case.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub rollback: Option<f64>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct DumptxoutsetResult {
        /// the number of coins written in the snapshot
        pub coins_written: f64,
        /// the hash of the base of the snapshot
        pub base_hash: String,
        /// the height of the base of the snapshot
        pub base_height: f64,
        /// the absolute path that the snapshot was written to
        pub path: String,
        /// the hash of the UTXO set contents
        pub txoutset_hash: String,
        /// the number of transactions in the chain up to and including the base block
        pub nchaintx: f64,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct EnumeratesignersResultSignersItem {
        /// Master key fingerprint
        pub fingerprint: String,
        /// Device name
        pub name: String,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct EnumeratesignersResult {
        pub signers: Vec<EnumeratesignersResultSignersItem>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct EstimaterawfeeResultShortPass {
        /// start of feerate range
        pub startrange: f64,
        /// end of feerate range
        pub endrange: f64,
        /// number of txs over history horizon in the feerate range that were confirmed within target
        pub withintarget: f64,
        /// number of txs over history horizon in the feerate range that were confirmed at any point
        pub totalconfirmed: f64,
        /// current number of txs in mempool in the feerate range unconfirmed for at least target blocks
        pub inmempool: f64,
        /// number of txs over history horizon in the feerate range that left mempool unconfirmed after target
        pub leftmempool: f64,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct EstimaterawfeeResultShort {
        /// estimate fee rate in BTC/kvB
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub feerate: Option<f64>,
        /// exponential decay (per block) for historical moving average of confirmation data
        pub decay: f64,
        /// The resolution of confirmation targets at this time horizon
        pub scale: f64,
        /// information about the lowest range of feerates to succeed in meeting the threshold
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pass: Option<EstimaterawfeeResultShortPass>,
        /// information about the highest range of feerates to fail to meet the threshold
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fail: Option<std::collections::BTreeMap<String, Value>>,
        /// Errors encountered during processing (if there are any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub errors: Option<Vec<String>>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct EstimaterawfeeResult {
        /// estimate for short time horizon
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub short: Option<EstimaterawfeeResultShort>,
        /// estimate for medium time horizon
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub medium: Option<std::collections::BTreeMap<String, Value>>,
        /// estimate for long time horizon
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub long: Option<std::collections::BTreeMap<String, Value>>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct EstimatesmartfeeResult {
        /// estimate fee rate in BTC/kvB (only present if no errors were encountered)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub feerate: Option<f64>,
        /// Errors encountered during processing (if there are any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub errors: Option<Vec<String>>,
        /// block number where estimate was found
        /// The request target will be clamped between 2 and the highest target
        /// fee estimation is able to return based on how long it has been running.
        /// An error is returned if not enough transactions and blocks
        /// have been observed to make an estimate for any number of blocks.
        pub blocks: f64,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct FinalizepsbtResult {
        /// The base64-encoded partially signed transaction if not extracted
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub psbt: Option<String>,
        /// The hex-encoded network transaction if extracted
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub hex: Option<String>,
        /// If the transaction has a complete set of signatures
        pub complete: bool,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct FundrawtransactionOptionsInputWeightsItem {
        /// The transaction id
        pub txid: String,
        /// The output index
        pub vout: f64,
        /// The maximum weight for this input, including the weight of the outpoint and sequence number. Note that serialized signature sizes are not guaranteed to be consistent, so the maximum DER signatures size of 73 bytes should be used when considering ECDSA signatures.Remember to convert serialized sizes to weight units when necessary.
        pub weight: f64,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct FundrawtransactionOptionsSolvingData {
        /// Public keys involved in this transaction.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pubkeys: Option<Vec<String>>,
        /// Scripts involved in this transaction.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub scripts: Option<Vec<String>>,
        /// Descriptors that provide solving data for this transaction.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub descriptors: Option<Vec<String>>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct FundrawtransactionOptions {
        /// For a transaction with existing inputs, automatically include more if they are not enough.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub add_inputs: Option<bool>,
        /// Include inputs that are not safe to spend (unconfirmed transactions from outside keys and unconfirmed replacement transactions).
        /// Warning: the resulting transaction may become invalid if one of the unsafe inputs disappears.
        /// If that happens, you will need to fund the transaction with different inputs and republish it.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub include_unsafe: Option<bool>,
        /// If add_inputs is specified, require inputs with at least this many confirmations.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub minconf: Option<f64>,
        /// If add_inputs is specified, require inputs with at most this many confirmations.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub maxconf: Option<f64>,
        /// The bitcoin address to receive the change
        #[serde(rename = "changeAddress")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub change_address: Option<String>,
        /// The index of the change output
        #[serde(rename = "changePosition")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub change_position: Option<f64>,
        /// The output type to use. Only valid if changeAddress is not specified. Options are "legacy", "p2sh-segwit", "bech32", "bech32m".
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub change_type: Option<String>,
        /// (DEPRECATED) No longer used
        #[serde(rename = "includeWatching")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub include_watching: Option<bool>,
        /// Lock selected unspent outputs
        #[serde(rename = "lockUnspents")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub lock_unspents: Option<bool>,
        /// Specify a fee rate in sat/vB.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fee_rate: Option<rust_decimal::Decimal>,
        /// Specify a fee rate in BTC/kvB.
        #[serde(rename = "feeRate")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fee_rate: Option<rust_decimal::Decimal>,
        /// The integers.
        /// The fee will be equally deducted from the amount of each specified output.
        /// Those recipients will receive less bitcoins than you enter in their corresponding amount field.
        /// If no outputs are specified here, the sender pays the fee.
        #[serde(rename = "subtractFeeFromOutputs")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub subtract_fee_from_outputs: Option<Vec<f64>>,
        /// Inputs and their corresponding weights
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub input_weights: Option<Vec<FundrawtransactionOptionsInputWeightsItem>>,
        /// The maximum acceptable transaction weight.
        /// Transaction building will fail if this can not be satisfied.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub max_tx_weight: Option<f64>,
        /// Confirmation target in blocks
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub conf_target: Option<f64>,
        /// The fee estimate mode, must be one of (case insensitive):
        /// unset, economical, conservative
        /// unset means no mode set (economical mode is used if the transaction is replaceable;
        /// otherwise, conservative mode is used).
        /// economical estimates use a shorter time horizon, making them more
        /// responsive to short-term drops in the prevailing fee market. This mode
        /// potentially returns a lower fee rate estimate.
        /// conservative estimates use a longer time horizon, making them
        /// less responsive to short-term drops in the prevailing fee market. This mode
        /// potentially returns a higher fee rate estimate.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub estimate_mode: Option<String>,
        /// Marks this transaction as BIP125-replaceable.
        /// Allows this transaction to be replaced by a transaction with higher fees
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub replaceable: Option<bool>,
        /// Keys and scripts needed for producing a final transaction with a dummy signature.
        /// Used for fee estimation during coin selection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub solving_data: Option<FundrawtransactionOptionsSolvingData>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct FundrawtransactionResult {
        /// The resulting raw transaction (hex-encoded string)
        pub hex: String,
        /// Fee in BTC the resulting transaction pays
        pub fee: rust_decimal::Decimal,
        /// The position of the added change output, or -1
        pub changepos: f64,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GenerateblockResult {
        /// hash of generated block
        pub hash: String,
        /// hex of generated block, only present when submit=false
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub hex: Option<String>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetaddednodeinfoResultItemAddressesItem {
        /// The bitcoin server IP and port we're connected to
        pub address: String,
        /// connection, inbound or outbound
        pub connected: String,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetaddednodeinfoResultItem {
        /// The node IP address or name (as provided to addnode)
        pub addednode: String,
        /// If connected
        pub connected: bool,
        /// Only when connected = true
        pub addresses: Vec<GetaddednodeinfoResultItemAddressesItem>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetaddressesbylabelResultValue {
        /// Purpose of address ("send" for sending address, "receive" for receiving address)
        pub purpose: String,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetaddressinfoResult {
        /// The bitcoin address validated.
        pub address: String,
        /// The hex-encoded output script generated by the address.
        #[serde(rename = "scriptPubKey")]
        pub script_pub_key: String,
        /// If the address is yours.
        pub ismine: bool,
        /// (DEPRECATED) Always false.
        pub iswatchonly: bool,
        /// If we know how to spend coins sent to this address, ignoring the possible lack of private keys.
        pub solvable: bool,
        /// A descriptor for spending coins sent to this address (only when solvable).
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub desc: Option<String>,
        /// The descriptor used to derive this address if this is a descriptor wallet
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub parent_desc: Option<String>,
        /// If the key is a script.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub isscript: Option<bool>,
        /// If the address was used for change output.
        pub ischange: bool,
        /// If the address is a witness address.
        pub iswitness: bool,
        /// The version number of the witness program.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub witness_version: Option<f64>,
        /// The hex value of the witness program.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub witness_program: Option<String>,
        /// The output script type. Only if isscript is true and the redeemscript is known. Possible
        /// types: nonstandard, pubkey, pubkeyhash, scripthash, multisig, nulldata, witness_v0_keyhash,
        /// witness_v0_scripthash, witness_unknown.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub script: Option<String>,
        /// The redeemscript for the p2sh address.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub hex: Option<String>,
        /// Array of pubkeys associated with the known redeemscript (only if script is multisig).
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pubkeys: Option<Vec<String>>,
        /// The number of signatures required to spend multisig output (only if script is multisig).
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub sigsrequired: Option<f64>,
        /// The hex value of the raw public key for single-key addresses (possibly embedded in P2SH or P2WSH).
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pubkey: Option<String>,
        /// Information about the address embedded in P2SH or P2WSH, if relevant and known.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub embedded: Option<std::collections::BTreeMap<String, Value>>,
        /// If the pubkey is compressed.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub iscompressed: Option<bool>,
        /// The creation time of the key, if available, expressed in UNIX epoch time.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub timestamp: Option<i64>,
        /// The HD keypath, if the key is HD and available.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub hdkeypath: Option<String>,
        /// The Hash160 of the HD seed.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub hdseedid: Option<String>,
        /// The fingerprint of the master key.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub hdmasterfingerprint: Option<String>,
        /// Array of labels associated with the address. Currently limited to one label but returned
        /// as an array to keep the API stable if multiple labels are enabled in the future.
        pub labels: Vec<String>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetaddrmaninfoResultValue {
        /// number of addresses in the new table, which represent potential peers the node has discovered but hasn't yet successfully connected to.
        pub new: f64,
        /// number of addresses in the tried table, which represent peers the node has successfully connected to in the past.
        pub tried: f64,
        /// total number of addresses in both new/tried tables
        pub total: f64,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetbalancesResultMine {
        /// trusted balance (outputs created by the wallet or confirmed outputs)
        pub trusted: rust_decimal::Decimal,
        /// untrusted pending balance (outputs created by others that are in the mempool)
        pub untrusted_pending: rust_decimal::Decimal,
        /// balance from immature coinbase outputs
        pub immature: rust_decimal::Decimal,
        /// (only present if avoid_reuse is set) balance from coins sent to addresses that were previously spent from (potentially privacy violating)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub used: Option<rust_decimal::Decimal>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetbalancesResultLastprocessedblock {
        /// hash of the block this information was generated on
        pub hash: String,
        /// height of the block this information was generated on
        pub height: f64,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetbalancesResult {
        /// balances from outputs that the wallet can sign
        pub mine: GetbalancesResultMine,
        /// hash and height of the block this information was generated on
        pub lastprocessedblock: GetbalancesResultLastprocessedblock,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetblockResultVariant1 {
        /// the block hash (same as provided)
        pub hash: String,
        /// The number of confirmations, or -1 if the block is not on the main chain
        pub confirmations: f64,
        /// The block size
        pub size: f64,
        /// The block size excluding witness data
        pub strippedsize: f64,
        /// The block weight as defined in BIP 141
        pub weight: f64,
        /// The block height or index
        pub height: f64,
        /// The block version
        pub version: f64,
        /// The block version formatted in hexadecimal
        #[serde(rename = "versionHex")]
        pub version_hex: String,
        /// The merkle root
        pub merkleroot: String,
        /// The transaction ids
        pub tx: Vec<String>,
        /// The block time expressed in UNIX epoch time
        pub time: i64,
        /// The median block time expressed in UNIX epoch time
        pub mediantime: i64,
        /// The nonce
        pub nonce: f64,
        /// nBits: compact representation of the block difficulty target
        pub bits: String,
        /// The difficulty target
        pub target: String,
        /// The difficulty
        pub difficulty: f64,
        /// Expected number of hashes required to produce the chain up to this block (in hex)
        pub chainwork: String,
        /// The number of transactions in the block
        #[serde(rename = "nTx")]
        pub n_tx: f64,
        /// The hash of the previous block (if available)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub previousblockhash: Option<String>,
        /// The hash of the next block (if available)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub nextblockhash: Option<String>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetblockResultVariant2TxItem {
        /// The transaction fee in BTC, omitted if block undo data is not available
        pub fee: f64,
        /// Additional properties
        #[serde(flatten)]
        pub extra: std::collections::BTreeMap<String, Value>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetblockResultVariant2 {
        pub tx: Vec<GetblockResultVariant2TxItem>,
        /// Additional properties
        #[serde(flatten)]
        pub extra: std::collections::BTreeMap<String, Value>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetblockResultVariant3TxItemVinItemPrevoutScriptPubKey {
        /// Disassembly of the output script
        pub asm: String,
        /// Inferred descriptor for the output
        pub desc: String,
        /// The raw output script bytes, hex-encoded
        pub hex: String,
        /// The Bitcoin address (only if a well-defined address exists)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub address: Option<String>,
        /// The type (one of: nonstandard, anchor, pubkey, pubkeyhash, scripthash, multisig, nulldata, witness_v0_scripthash, witness_v0_keyhash, witness_v1_taproot, witness_unknown)
        #[serde(rename = "type")]
        pub type_: String,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetblockResultVariant3TxItemVinItemPrevout {
        /// Coinbase or not
        pub generated: bool,
        /// The height of the prevout
        pub height: f64,
        /// The value in BTC
        pub value: rust_decimal::Decimal,
        #[serde(rename = "scriptPubKey")]
        pub script_pub_key: GetblockResultVariant3TxItemVinItemPrevoutScriptPubKey,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetblockResultVariant3TxItemVinItem {
        /// (Only if undo information is available)
        pub prevout: GetblockResultVariant3TxItemVinItemPrevout,
        /// Additional properties
        #[serde(flatten)]
        pub extra: std::collections::BTreeMap<String, Value>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetblockResultVariant3TxItem {
        pub vin: Vec<GetblockResultVariant3TxItemVinItem>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetblockResultVariant3 {
        pub tx: Vec<GetblockResultVariant3TxItem>,
        /// Additional properties
        #[serde(flatten)]
        pub extra: std::collections::BTreeMap<String, Value>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    #[serde(untagged)]
    pub enum GetblockResult {
        /// A string that is serialized, hex-encoded data for block 'hash'
        Variant0(String),
        /// for verbosity = 1
        Variant1(GetblockResultVariant1),
        /// for verbosity = 2
        Variant2(GetblockResultVariant2),
        /// for verbosity = 3
        Variant3(GetblockResultVariant3),
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetblockchaininfoResult {
        /// current network name (main, test, testnet4, signet, regtest)
        pub chain: String,
        /// the height of the most-work fully-validated chain. The genesis block has height 0
        pub blocks: f64,
        /// the current number of headers we have validated
        pub headers: f64,
        /// the hash of the currently best block
        pub bestblockhash: String,
        /// nBits: compact representation of the block difficulty target
        pub bits: String,
        /// The difficulty target
        pub target: String,
        /// the current difficulty
        pub difficulty: f64,
        /// The block time expressed in UNIX epoch time
        pub time: i64,
        /// The median block time expressed in UNIX epoch time
        pub mediantime: i64,
        /// estimate of verification progress [0..1]
        pub verificationprogress: f64,
        /// (debug information) estimate of whether this node is in Initial Block Download mode
        pub initialblockdownload: bool,
        /// total amount of work in active chain, in hexadecimal
        pub chainwork: String,
        /// the estimated size of the block and undo files on disk
        pub size_on_disk: f64,
        /// if the blocks are subject to pruning
        pub pruned: bool,
        /// height of the last block pruned, plus one (only present if pruning is enabled)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pruneheight: Option<f64>,
        /// whether automatic pruning is enabled (only present if pruning is enabled)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub automatic_pruning: Option<bool>,
        /// the target size used by pruning (only present if automatic pruning is enabled)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub prune_target_size: Option<f64>,
        /// the block challenge (aka. block script), in hexadecimal (only present if the current network is a signet)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub signet_challenge: Option<String>,
        /// any network and blockchain warnings (run with `-deprecatedrpc=warnings` to return the latest warning as a single string)
        pub warnings: Vec<String>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetblockfilterResult {
        /// the hex-encoded filter data
        pub filter: String,
        /// the hex-encoded filter header
        pub header: String,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetblockheaderResultVariant0 {
        /// the block hash (same as provided)
        pub hash: String,
        /// The number of confirmations, or -1 if the block is not on the main chain
        pub confirmations: f64,
        /// The block height or index
        pub height: f64,
        /// The block version
        pub version: f64,
        /// The block version formatted in hexadecimal
        #[serde(rename = "versionHex")]
        pub version_hex: String,
        /// The merkle root
        pub merkleroot: String,
        /// The block time expressed in UNIX epoch time
        pub time: i64,
        /// The median block time expressed in UNIX epoch time
        pub mediantime: i64,
        /// The nonce
        pub nonce: f64,
        /// nBits: compact representation of the block difficulty target
        pub bits: String,
        /// The difficulty target
        pub target: String,
        /// The difficulty
        pub difficulty: f64,
        /// Expected number of hashes required to produce the current chain
        pub chainwork: String,
        /// The number of transactions in the block
        #[serde(rename = "nTx")]
        pub n_tx: f64,
        /// The hash of the previous block (if available)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub previousblockhash: Option<String>,
        /// The hash of the next block (if available)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub nextblockhash: Option<String>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    #[serde(untagged)]
    pub enum GetblockheaderResult {
        /// for verbose = true
        Variant0(GetblockheaderResultVariant0),
        /// A string that is serialized, hex-encoded data for block 'hash'
        Variant1(String),
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetblockstatsResult {
        /// Average fee in the block
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub avgfee: Option<f64>,
        /// Average feerate (in satoshis per virtual byte)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub avgfeerate: Option<f64>,
        /// Average transaction size
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub avgtxsize: Option<f64>,
        /// The block hash (to check for potential reorgs)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub blockhash: Option<String>,
        /// Feerates at the 10th, 25th, 50th, 75th, and 90th percentile weight unit (in satoshis per virtual byte)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub feerate_percentiles: Option<Vec<Value>>,
        /// The height of the block
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub height: Option<f64>,
        /// The number of inputs (excluding coinbase)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ins: Option<f64>,
        /// Maximum fee in the block
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub maxfee: Option<f64>,
        /// Maximum feerate (in satoshis per virtual byte)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub maxfeerate: Option<f64>,
        /// Maximum transaction size
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub maxtxsize: Option<f64>,
        /// Truncated median fee in the block
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub medianfee: Option<f64>,
        /// The block median time past
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub mediantime: Option<f64>,
        /// Truncated median transaction size
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub mediantxsize: Option<f64>,
        /// Minimum fee in the block
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub minfee: Option<f64>,
        /// Minimum feerate (in satoshis per virtual byte)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub minfeerate: Option<f64>,
        /// Minimum transaction size
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub mintxsize: Option<f64>,
        /// The number of outputs
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub outs: Option<f64>,
        /// The block subsidy
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub subsidy: Option<f64>,
        /// Total size of all segwit transactions
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub swtotal_size: Option<f64>,
        /// Total weight of all segwit transactions
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub swtotal_weight: Option<f64>,
        /// The number of segwit transactions
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub swtxs: Option<f64>,
        /// The block time
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub time: Option<f64>,
        /// Total amount in all outputs (excluding coinbase and thus reward [ie subsidy + totalfee])
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_out: Option<f64>,
        /// Total size of all non-coinbase transactions
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_size: Option<f64>,
        /// Total weight of all non-coinbase transactions
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_weight: Option<f64>,
        /// The fee total
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub totalfee: Option<f64>,
        /// The number of transactions (including coinbase)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub txs: Option<f64>,
        /// The increase/decrease in the number of unspent outputs (not discounting op_return and similar)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub utxo_increase: Option<f64>,
        /// The increase/decrease in size for the utxo index (not discounting op_return and similar)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub utxo_size_inc: Option<f64>,
        /// The increase/decrease in the number of unspent outputs, not counting unspendables
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub utxo_increase_actual: Option<f64>,
        /// The increase/decrease in size for the utxo index, not counting unspendables
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub utxo_size_inc_actual: Option<f64>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetblocktemplateTemplateRequest {
        /// This must be set to "template", "proposal" (see BIP 23), or omitted
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub mode: Option<String>,
        /// A list of strings
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub capabilities: Option<Vec<String>>,
        /// A list of strings
        pub rules: Vec<Value>,
        /// delay processing request until the result would vary significantly from the "longpollid" of a prior template
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub longpollid: Option<String>,
        /// proposed block data to check, encoded in hexadecimal; valid only for mode="proposal"
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub data: Option<String>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetblocktemplateResultVariant2TransactionsItem {
        /// transaction data encoded in hexadecimal (byte-for-byte)
        pub data: String,
        /// transaction hash excluding witness data, shown in byte-reversed hex
        pub txid: String,
        /// transaction hash including witness data, shown in byte-reversed hex
        pub hash: String,
        /// array of numbers
        pub depends: Vec<f64>,
        /// difference in value between transaction inputs and outputs (in satoshis); for coinbase transactions, this is a negative Number of the total collected block fees (ie, not including the block subsidy); if key is not present, fee is unknown and clients MUST NOT assume there isn't one
        pub fee: f64,
        /// total SigOps cost, as counted for purposes of block limits; if key is not present, sigop cost is unknown and clients MUST NOT assume it is zero
        pub sigops: f64,
        /// total transaction weight, as counted for purposes of block limits
        pub weight: f64,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetblocktemplateResultVariant2 {
        /// The preferred block version
        pub version: f64,
        /// specific block rules that are to be enforced
        pub rules: Vec<String>,
        /// set of pending, supported versionbit (BIP 9) softfork deployments
        pub vbavailable: std::collections::BTreeMap<String, f64>,
        pub capabilities: Vec<String>,
        /// bit mask of versionbits the server requires set in submissions
        pub vbrequired: f64,
        /// The hash of current highest block
        pub previousblockhash: String,
        /// contents of non-coinbase transactions that should be included in the next block
        pub transactions: Vec<GetblocktemplateResultVariant2TransactionsItem>,
        /// data that should be included in the coinbase's scriptSig content
        pub coinbaseaux: std::collections::BTreeMap<String, String>,
        /// maximum allowable input to coinbase transaction, including the generation award and transaction fees (in satoshis)
        pub coinbasevalue: f64,
        /// an id to include with a request to longpoll on an update to this template
        pub longpollid: String,
        /// The hash target
        pub target: String,
        /// The minimum timestamp appropriate for the next block time, expressed in UNIX epoch time. Adjusted for the proposed BIP94 timewarp rule.
        pub mintime: i64,
        /// list of ways the block template may be changed
        pub mutable: Vec<String>,
        /// A range of valid nonces
        pub noncerange: String,
        /// limit of sigops in blocks
        pub sigoplimit: f64,
        /// limit of block size
        pub sizelimit: f64,
        /// limit of block weight
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub weightlimit: Option<f64>,
        /// current timestamp in UNIX epoch time. Adjusted for the proposed BIP94 timewarp rule.
        pub curtime: i64,
        /// compressed target of next block
        pub bits: String,
        /// The height of the next block
        pub height: f64,
        /// Only on signet
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub signet_challenge: Option<String>,
        /// a valid witness commitment for the unmodified block template
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub default_witness_commitment: Option<String>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    #[serde(untagged)]
    pub enum GetblocktemplateResult {
        /// If the proposal was accepted with mode=='proposal'
        Variant0(()),
        /// According to BIP22
        Variant1(String),
        /// Otherwise
        Variant2(GetblocktemplateResultVariant2),
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetchainstatesResultChainstatesItem {
        /// number of blocks in this chainstate
        pub blocks: f64,
        /// blockhash of the tip
        pub bestblockhash: String,
        /// nBits: compact representation of the block difficulty target
        pub bits: String,
        /// The difficulty target
        pub target: String,
        /// difficulty of the tip
        pub difficulty: f64,
        /// progress towards the network tip
        pub verificationprogress: f64,
        /// the base block of the snapshot this chainstate is based on, if any
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub snapshot_blockhash: Option<String>,
        /// size of the coinsdb cache
        pub coins_db_cache_bytes: f64,
        /// size of the coinstip cache
        pub coins_tip_cache_bytes: f64,
        /// whether the chainstate is fully validated. True if all blocks in the chainstate were validated, false if the chain is based on a snapshot and the snapshot has not yet been validated.
        pub validated: bool,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetchainstatesResult {
        /// the number of headers seen so far
        pub headers: f64,
        /// list of the chainstates ordered by work, with the most-work (active) chainstate last
        pub chainstates: Vec<GetchainstatesResultChainstatesItem>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetchaintipsResultItem {
        /// height of the chain tip
        pub height: f64,
        /// block hash of the tip
        pub hash: String,
        /// zero for main chain, otherwise length of branch connecting the tip to the main chain
        pub branchlen: f64,
        /// status of the chain, "active" for the main chain
        /// Possible values for status:
        /// 1.  "invalid"               This branch contains at least one invalid block
        /// 2.  "headers-only"          Not all blocks for this branch are available, but the headers are valid
        /// 3.  "valid-headers"         All blocks are available for this branch, but they were never fully validated
        /// 4.  "valid-fork"            This branch is not part of the active chain, but is fully validated
        /// 5.  "active"                This is the tip of the active main chain, which is certainly valid
        pub status: String,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetchaintxstatsResult {
        /// The timestamp for the final block in the window, expressed in UNIX epoch time
        pub time: i64,
        /// The total number of transactions in the chain up to that point, if known. It may be unknown when using assumeutxo.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub txcount: Option<f64>,
        /// The hash of the final block in the window
        pub window_final_block_hash: String,
        /// The height of the final block in the window.
        pub window_final_block_height: f64,
        /// Size of the window in number of blocks
        pub window_block_count: f64,
        /// The elapsed time in the window in seconds. Only returned if "window_block_count" is > 0
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub window_interval: Option<f64>,
        /// The number of transactions in the window. Only returned if "window_block_count" is > 0 and if txcount exists for the start and end of the window.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub window_tx_count: Option<f64>,
        /// The average rate of transactions per second in the window. Only returned if "window_interval" is > 0 and if window_tx_count exists.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub txrate: Option<f64>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetdeploymentinfoResultDeploymentsValueBip9Statistics {
        /// the length in blocks of the signalling period
        pub period: f64,
        /// the number of blocks with the version bit set required to activate the feature (only for "started" status)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub threshold: Option<f64>,
        /// the number of blocks elapsed since the beginning of the current period
        pub elapsed: f64,
        /// the number of blocks with the version bit set in the current period
        pub count: f64,
        /// returns false if there are not enough blocks left in this period to pass activation threshold (only for "started" status)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub possible: Option<bool>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetdeploymentinfoResultDeploymentsValueBip9 {
        /// the bit (0-28) in the block version field used to signal this softfork (only for "started" and "locked_in" status)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub bit: Option<f64>,
        /// the minimum median time past of a block at which the bit gains its meaning
        pub start_time: i64,
        /// the median time past of a block at which the deployment is considered failed if not yet locked in
        pub timeout: i64,
        /// minimum height of blocks for which the rules may be enforced
        pub min_activation_height: f64,
        /// status of deployment at specified block (one of "defined", "started", "locked_in", "active", "failed")
        pub status: String,
        /// height of the first block to which the status applies
        pub since: f64,
        /// status of deployment at the next block
        pub status_next: String,
        /// numeric statistics about signalling for a softfork (only for "started" and "locked_in" status)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub statistics: Option<GetdeploymentinfoResultDeploymentsValueBip9Statistics>,
        /// indicates blocks that signalled with a # and blocks that did not with a -
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub signalling: Option<String>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetdeploymentinfoResultDeploymentsValue {
        /// one of "buried", "bip9"
        #[serde(rename = "type")]
        pub type_: String,
        /// height of the first block which the rules are or will be enforced (only for "buried" type, or "bip9" type with "active" status)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub height: Option<f64>,
        /// true if the rules are enforced for the mempool and the next block
        pub active: bool,
        /// status of bip9 softforks (only for "bip9" type)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub bip9: Option<GetdeploymentinfoResultDeploymentsValueBip9>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetdeploymentinfoResult {
        /// requested block hash (or tip)
        pub hash: String,
        /// requested block height (or tip)
        pub height: f64,
        pub deployments: std::collections::BTreeMap<String, GetdeploymentinfoResultDeploymentsValue>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetdescriptoractivityResult {
        /// events
        pub activity: Vec<Value>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetdescriptorinfoResult {
        /// The descriptor in canonical form, without private keys. For a multipath descriptor, only the first will be returned.
        pub descriptor: String,
        /// All descriptors produced by expanding multipath derivation elements. Only if the provided descriptor specifies multipath derivation elements.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub multipath_expansion: Option<Vec<String>>,
        /// The checksum for the input descriptor
        pub checksum: String,
        /// Whether the descriptor is ranged
        pub isrange: bool,
        /// Whether the descriptor is solvable
        pub issolvable: bool,
        /// Whether the input descriptor contained at least one private key
        pub hasprivatekeys: bool,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GethdkeysOptions {
        /// Show the keys for only active descriptors
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub active_only: Option<bool>,
        /// Show private keys
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub private: Option<bool>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GethdkeysResultItemDescriptorsItem {
        /// Descriptor string representation
        pub desc: String,
        /// Whether this descriptor is currently used to generate new addresses
        pub active: bool,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GethdkeysResultItem {
        /// The extended public key
        pub xpub: String,
        /// Whether the wallet has the private key for this xpub
        pub has_private: bool,
        /// The extended private key if "private" is true
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub xprv: Option<String>,
        /// Array of descriptor objects that use this HD key
        pub descriptors: Vec<GethdkeysResultItemDescriptorsItem>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetindexinfoResultValue {
        /// Whether the index is synced or not
        pub synced: bool,
        /// The block height to which the index is synced
        pub best_block_height: f64,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetmemoryinfoResultVariant0Locked {
        /// Number of bytes used
        pub used: f64,
        /// Number of bytes available in current arenas
        pub free: f64,
        /// Total number of bytes managed
        pub total: f64,
        /// Amount of bytes that succeeded locking. If this number is smaller than total, locking pages failed at some point and key data could be swapped to disk.
        pub locked: f64,
        /// Number allocated chunks
        pub chunks_used: f64,
        /// Number unused chunks
        pub chunks_free: f64,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetmemoryinfoResultVariant0 {
        /// Information about locked memory manager
        pub locked: GetmemoryinfoResultVariant0Locked,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    #[serde(untagged)]
    pub enum GetmemoryinfoResult {
        /// mode "stats"
        Variant0(GetmemoryinfoResultVariant0),
        /// "<malloc version="1">..."
        Variant1(String),
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetmempoolancestorsResultVariant1ValueFees {
        /// transaction fee, denominated in BTC
        pub base: rust_decimal::Decimal,
        /// transaction fee with fee deltas used for mining priority, denominated in BTC
        pub modified: rust_decimal::Decimal,
        /// transaction fees of in-mempool ancestors (including this one) with fee deltas used for mining priority, denominated in BTC
        pub ancestor: rust_decimal::Decimal,
        /// transaction fees of in-mempool descendants (including this one) with fee deltas used for mining priority, denominated in BTC
        pub descendant: rust_decimal::Decimal,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetmempoolancestorsResultVariant1Value {
        /// virtual transaction size as defined in BIP 141. This is different from actual serialized size for witness transactions as witness data is discounted.
        pub vsize: f64,
        /// transaction weight as defined in BIP 141.
        pub weight: f64,
        /// local time transaction entered pool in seconds since 1 Jan 1970 GMT
        pub time: i64,
        /// block height when transaction entered pool
        pub height: f64,
        /// number of in-mempool descendant transactions (including this one)
        pub descendantcount: f64,
        /// virtual transaction size of in-mempool descendants (including this one)
        pub descendantsize: f64,
        /// number of in-mempool ancestor transactions (including this one)
        pub ancestorcount: f64,
        /// virtual transaction size of in-mempool ancestors (including this one)
        pub ancestorsize: f64,
        /// hash of serialized transaction, including witness data
        pub wtxid: String,
        pub fees: GetmempoolancestorsResultVariant1ValueFees,
        /// unconfirmed transactions used as inputs for this transaction
        pub depends: Vec<String>,
        /// unconfirmed transactions spending outputs from this transaction
        pub spentby: Vec<String>,
        /// Whether this transaction signals BIP125 replaceability or has an unconfirmed ancestor signaling BIP125 replaceability. (DEPRECATED)
        #[serde(rename = "bip125-replaceable")]
        pub bip125_replaceable: bool,
        /// Whether this transaction is currently unbroadcast (initial broadcast not yet acknowledged by any peers)
        pub unbroadcast: bool,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    #[serde(untagged)]
    pub enum GetmempoolancestorsResult {
        /// for verbose = false
        Variant0(Vec<String>),
        /// for verbose = true
        Variant1(std::collections::BTreeMap<String, GetmempoolancestorsResultVariant1Value>),
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetmempooldescendantsResultVariant1ValueFees {
        /// transaction fee, denominated in BTC
        pub base: rust_decimal::Decimal,
        /// transaction fee with fee deltas used for mining priority, denominated in BTC
        pub modified: rust_decimal::Decimal,
        /// transaction fees of in-mempool ancestors (including this one) with fee deltas used for mining priority, denominated in BTC
        pub ancestor: rust_decimal::Decimal,
        /// transaction fees of in-mempool descendants (including this one) with fee deltas used for mining priority, denominated in BTC
        pub descendant: rust_decimal::Decimal,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetmempooldescendantsResultVariant1Value {
        /// virtual transaction size as defined in BIP 141. This is different from actual serialized size for witness transactions as witness data is discounted.
        pub vsize: f64,
        /// transaction weight as defined in BIP 141.
        pub weight: f64,
        /// local time transaction entered pool in seconds since 1 Jan 1970 GMT
        pub time: i64,
        /// block height when transaction entered pool
        pub height: f64,
        /// number of in-mempool descendant transactions (including this one)
        pub descendantcount: f64,
        /// virtual transaction size of in-mempool descendants (including this one)
        pub descendantsize: f64,
        /// number of in-mempool ancestor transactions (including this one)
        pub ancestorcount: f64,
        /// virtual transaction size of in-mempool ancestors (including this one)
        pub ancestorsize: f64,
        /// hash of serialized transaction, including witness data
        pub wtxid: String,
        pub fees: GetmempooldescendantsResultVariant1ValueFees,
        /// unconfirmed transactions used as inputs for this transaction
        pub depends: Vec<String>,
        /// unconfirmed transactions spending outputs from this transaction
        pub spentby: Vec<String>,
        /// Whether this transaction signals BIP125 replaceability or has an unconfirmed ancestor signaling BIP125 replaceability. (DEPRECATED)
        #[serde(rename = "bip125-replaceable")]
        pub bip125_replaceable: bool,
        /// Whether this transaction is currently unbroadcast (initial broadcast not yet acknowledged by any peers)
        pub unbroadcast: bool,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    #[serde(untagged)]
    pub enum GetmempooldescendantsResult {
        /// for verbose = false
        Variant0(Vec<String>),
        /// for verbose = true
        Variant1(std::collections::BTreeMap<String, GetmempooldescendantsResultVariant1Value>),
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetmempoolentryResultFees {
        /// transaction fee, denominated in BTC
        pub base: rust_decimal::Decimal,
        /// transaction fee with fee deltas used for mining priority, denominated in BTC
        pub modified: rust_decimal::Decimal,
        /// transaction fees of in-mempool ancestors (including this one) with fee deltas used for mining priority, denominated in BTC
        pub ancestor: rust_decimal::Decimal,
        /// transaction fees of in-mempool descendants (including this one) with fee deltas used for mining priority, denominated in BTC
        pub descendant: rust_decimal::Decimal,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetmempoolentryResult {
        /// virtual transaction size as defined in BIP 141. This is different from actual serialized size for witness transactions as witness data is discounted.
        pub vsize: f64,
        /// transaction weight as defined in BIP 141.
        pub weight: f64,
        /// local time transaction entered pool in seconds since 1 Jan 1970 GMT
        pub time: i64,
        /// block height when transaction entered pool
        pub height: f64,
        /// number of in-mempool descendant transactions (including this one)
        pub descendantcount: f64,
        /// virtual transaction size of in-mempool descendants (including this one)
        pub descendantsize: f64,
        /// number of in-mempool ancestor transactions (including this one)
        pub ancestorcount: f64,
        /// virtual transaction size of in-mempool ancestors (including this one)
        pub ancestorsize: f64,
        /// hash of serialized transaction, including witness data
        pub wtxid: String,
        pub fees: GetmempoolentryResultFees,
        /// unconfirmed transactions used as inputs for this transaction
        pub depends: Vec<String>,
        /// unconfirmed transactions spending outputs from this transaction
        pub spentby: Vec<String>,
        /// Whether this transaction signals BIP125 replaceability or has an unconfirmed ancestor signaling BIP125 replaceability. (DEPRECATED)
        #[serde(rename = "bip125-replaceable")]
        pub bip125_replaceable: bool,
        /// Whether this transaction is currently unbroadcast (initial broadcast not yet acknowledged by any peers)
        pub unbroadcast: bool,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetmempoolinfoResult {
        /// True if the initial load attempt of the persisted mempool finished
        pub loaded: bool,
        /// Current tx count
        pub size: f64,
        /// Sum of all virtual transaction sizes as defined in BIP 141. Differs from actual serialized size because witness data is discounted
        pub bytes: f64,
        /// Total memory usage for the mempool
        pub usage: f64,
        /// Total fees for the mempool in BTC, ignoring modified fees through prioritisetransaction
        pub total_fee: rust_decimal::Decimal,
        /// Maximum memory usage for the mempool
        pub maxmempool: f64,
        /// Minimum fee rate in BTC/kvB for tx to be accepted. Is the maximum of minrelaytxfee and minimum mempool fee
        pub mempoolminfee: rust_decimal::Decimal,
        /// Current minimum relay fee for transactions
        pub minrelaytxfee: rust_decimal::Decimal,
        /// minimum fee rate increment for mempool limiting or replacement in BTC/kvB
        pub incrementalrelayfee: f64,
        /// Current number of transactions that haven't passed initial broadcast yet
        pub unbroadcastcount: f64,
        /// True if the mempool accepts RBF without replaceability signaling inspection (DEPRECATED)
        pub fullrbf: bool,
        /// True if the mempool accepts transactions with bare multisig outputs
        pub permitbaremultisig: bool,
        /// Maximum number of bytes that can be used by OP_RETURN outputs in the mempool
        pub maxdatacarriersize: f64,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetmininginfoResultNext {
        /// The next height
        pub height: f64,
        /// The next target nBits
        pub bits: String,
        /// The next difficulty
        pub difficulty: f64,
        /// The next target
        pub target: String,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetmininginfoResult {
        /// The current block
        pub blocks: f64,
        /// The block weight (including reserved weight for block header, txs count and coinbase tx) of the last assembled block (only present if a block was ever assembled)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub currentblockweight: Option<f64>,
        /// The number of block transactions (excluding coinbase) of the last assembled block (only present if a block was ever assembled)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub currentblocktx: Option<f64>,
        /// The current nBits, compact representation of the block difficulty target
        pub bits: String,
        /// The current difficulty
        pub difficulty: f64,
        /// The current target
        pub target: String,
        /// The network hashes per second
        pub networkhashps: f64,
        /// The size of the mempool
        pub pooledtx: f64,
        /// Minimum feerate of packages selected for block inclusion in BTC/kvB
        pub blockmintxfee: rust_decimal::Decimal,
        /// current network name (main, test, testnet4, signet, regtest)
        pub chain: String,
        /// The block challenge (aka. block script), in hexadecimal (only present if the current network is a signet)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub signet_challenge: Option<String>,
        /// The next block
        pub next: GetmininginfoResultNext,
        /// any network and blockchain warnings (run with `-deprecatedrpc=warnings` to return the latest warning as a single string)
        pub warnings: Vec<String>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetnettotalsResultUploadtarget {
        /// Length of the measuring timeframe in seconds
        pub timeframe: f64,
        /// Target in bytes
        pub target: f64,
        /// True if target is reached
        pub target_reached: bool,
        /// True if serving historical blocks
        pub serve_historical_blocks: bool,
        /// Bytes left in current time cycle
        pub bytes_left_in_cycle: f64,
        /// Seconds left in current time cycle
        pub time_left_in_cycle: f64,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetnettotalsResult {
        /// Total bytes received
        pub totalbytesrecv: f64,
        /// Total bytes sent
        pub totalbytessent: f64,
        /// Current system UNIX epoch time in milliseconds
        pub timemillis: i64,
        pub uploadtarget: GetnettotalsResultUploadtarget,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetnetworkinfoResultNetworksItem {
        /// network (ipv4, ipv6, onion, i2p, cjdns)
        pub name: String,
        /// is the network limited using -onlynet?
        pub limited: bool,
        /// is the network reachable?
        pub reachable: bool,
        /// ("host:port") the proxy that is used for this network, or empty if none
        pub proxy: String,
        /// Whether randomized credentials are used
        pub proxy_randomize_credentials: bool,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetnetworkinfoResultLocaladdressesItem {
        /// network address
        pub address: String,
        /// network port
        pub port: f64,
        /// relative score
        pub score: f64,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetnetworkinfoResult {
        /// the server version
        pub version: f64,
        /// the server subversion string
        pub subversion: String,
        /// the protocol version
        pub protocolversion: f64,
        /// the services we offer to the network
        pub localservices: String,
        /// the services we offer to the network, in human-readable form
        pub localservicesnames: Vec<String>,
        /// true if transaction relay is requested from peers
        pub localrelay: bool,
        /// the time offset
        pub timeoffset: f64,
        /// the total number of connections
        pub connections: f64,
        /// the number of inbound connections
        pub connections_in: f64,
        /// the number of outbound connections
        pub connections_out: f64,
        /// whether p2p networking is enabled
        pub networkactive: bool,
        /// information per network
        pub networks: Vec<GetnetworkinfoResultNetworksItem>,
        /// minimum relay fee rate for transactions in BTC/kvB
        pub relayfee: f64,
        /// minimum fee rate increment for mempool limiting or replacement in BTC/kvB
        pub incrementalfee: f64,
        /// list of local addresses
        pub localaddresses: Vec<GetnetworkinfoResultLocaladdressesItem>,
        /// any network and blockchain warnings (run with `-deprecatedrpc=warnings` to return the latest warning as a single string)
        pub warnings: Vec<String>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetnodeaddressesResultItem {
        /// The UNIX epoch time when the node was last seen
        pub time: i64,
        /// The services offered by the node
        pub services: f64,
        /// The address of the node
        pub address: String,
        /// The port number of the node
        pub port: f64,
        /// The network (ipv4, ipv6, onion, i2p, cjdns) the node connected through
        pub network: String,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetorphantxsResultVariant1Item {
        /// The transaction hash in hex
        pub txid: String,
        /// The transaction witness hash in hex
        pub wtxid: String,
        /// The serialized transaction size in bytes
        pub bytes: f64,
        /// The virtual transaction size as defined in BIP 141. This is different from actual serialized size for witness transactions as witness data is discounted.
        pub vsize: f64,
        /// The transaction weight as defined in BIP 141.
        pub weight: f64,
        pub from: Vec<f64>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetorphantxsResultVariant2Item {
        /// The transaction hash in hex
        pub txid: String,
        /// The transaction witness hash in hex
        pub wtxid: String,
        /// The serialized transaction size in bytes
        pub bytes: f64,
        /// The virtual transaction size as defined in BIP 141. This is different from actual serialized size for witness transactions as witness data is discounted.
        pub vsize: f64,
        /// The transaction weight as defined in BIP 141.
        pub weight: f64,
        pub from: Vec<f64>,
        /// The serialized, hex-encoded transaction data
        pub hex: String,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    #[serde(untagged)]
    pub enum GetorphantxsResult {
        /// for verbose = 0
        Variant0(Vec<String>),
        /// for verbose = 1
        Variant1(Vec<GetorphantxsResultVariant1Item>),
        /// for verbose = 2
        Variant2(Vec<GetorphantxsResultVariant2Item>),
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetpeerinfoResultItem {
        /// Peer index
        pub id: f64,
        /// (host:port) The IP address and port of the peer
        pub addr: String,
        /// (ip:port) Bind address of the connection to the peer
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub addrbind: Option<String>,
        /// (ip:port) Local address as reported by the peer
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub addrlocal: Option<String>,
        /// Network (ipv4, ipv6, onion, i2p, cjdns, not_publicly_routable)
        pub network: String,
        /// Mapped AS (Autonomous System) number at the end of the BGP route to the peer, used for diversifying
        /// peer selection (only displayed if the -asmap config option is set)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub mapped_as: Option<f64>,
        /// The services offered
        pub services: String,
        /// the services offered, in human-readable form
        pub servicesnames: Vec<String>,
        /// Whether we relay transactions to this peer
        pub relaytxes: bool,
        /// The UNIX epoch time of the last send
        pub lastsend: i64,
        /// The UNIX epoch time of the last receive
        pub lastrecv: i64,
        /// The UNIX epoch time of the last valid transaction received from this peer
        pub last_transaction: i64,
        /// The UNIX epoch time of the last block received from this peer
        pub last_block: i64,
        /// The total bytes sent
        pub bytessent: f64,
        /// The total bytes received
        pub bytesrecv: f64,
        /// The UNIX epoch time of the connection
        pub conntime: i64,
        /// The time offset in seconds
        pub timeoffset: f64,
        /// The last ping time in seconds, if any
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pingtime: Option<f64>,
        /// The minimum observed ping time in seconds, if any
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub minping: Option<f64>,
        /// The duration in seconds of an outstanding ping (if non-zero)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pingwait: Option<f64>,
        /// The peer version, such as 70001
        pub version: f64,
        /// The string version
        pub subver: String,
        /// Inbound (true) or Outbound (false)
        pub inbound: bool,
        /// Whether we selected peer as (compact blocks) high-bandwidth peer
        pub bip152_hb_to: bool,
        /// Whether peer selected us as (compact blocks) high-bandwidth peer
        pub bip152_hb_from: bool,
        /// The starting height (block) of the peer
        pub startingheight: f64,
        /// The current height of header pre-synchronization with this peer, or -1 if no low-work sync is in progress
        pub presynced_headers: f64,
        /// The last header we have in common with this peer
        pub synced_headers: f64,
        /// The last block we have in common with this peer
        pub synced_blocks: f64,
        pub inflight: Vec<f64>,
        /// Whether we participate in address relay with this peer
        pub addr_relay_enabled: bool,
        /// The total number of addresses processed, excluding those dropped due to rate limiting
        pub addr_processed: f64,
        /// The total number of addresses dropped due to rate limiting
        pub addr_rate_limited: f64,
        /// Any special permissions that have been granted to this peer
        pub permissions: Vec<String>,
        /// The minimum fee rate for transactions this peer accepts
        pub minfeefilter: f64,
        pub bytessent_per_msg: std::collections::BTreeMap<String, f64>,
        pub bytesrecv_per_msg: std::collections::BTreeMap<String, f64>,
        /// Type of connection:
        /// outbound-full-relay (default automatic connections),
        /// block-relay-only (does not relay transactions or addresses),
        /// inbound (initiated by the peer),
        /// manual (added via addnode RPC or -addnode/-connect configuration options),
        /// addr-fetch (short-lived automatic connection for soliciting addresses),
        /// feeler (short-lived automatic connection for testing addresses).
        /// Please note this output is unlikely to be stable in upcoming releases as we iterate to
        /// best capture connection behaviors.
        pub connection_type: String,
        /// Type of transport protocol:
        /// detecting (peer could be v1 or v2),
        /// v1 (plaintext transport protocol),
        /// v2 (BIP324 encrypted transport protocol).
        pub transport_protocol_type: String,
        /// The session ID for this connection, or "" if there is none ("v2" transport protocol only).
        pub session_id: String,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetprioritisedtransactionsResultValue {
        /// transaction fee delta in satoshis
        pub fee_delta: f64,
        /// whether this transaction is currently in mempool
        pub in_mempool: bool,
        /// modified fee in satoshis. Only returned if in_mempool=true
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub modified_fee: Option<f64>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetrawaddrmanResultValueValue {
        /// The address of the node
        pub address: String,
        /// Mapped AS (Autonomous System) number at the end of the BGP route to the peer, used for diversifying peer selection (only displayed if the -asmap config option is set)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub mapped_as: Option<f64>,
        /// The port number of the node
        pub port: f64,
        /// The network (ipv4, ipv6, onion, i2p, cjdns) of the address
        pub network: String,
        /// The services offered by the node
        pub services: f64,
        /// The UNIX epoch time when the node was last seen
        pub time: i64,
        /// The address that relayed the address to us
        pub source: String,
        /// The network (ipv4, ipv6, onion, i2p, cjdns) of the source address
        pub source_network: String,
        /// Mapped AS (Autonomous System) number at the end of the BGP route to the source, used for diversifying peer selection (only displayed if the -asmap config option is set)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub source_mapped_as: Option<f64>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetrawmempoolResultVariant1ValueFees {
        /// transaction fee, denominated in BTC
        pub base: rust_decimal::Decimal,
        /// transaction fee with fee deltas used for mining priority, denominated in BTC
        pub modified: rust_decimal::Decimal,
        /// transaction fees of in-mempool ancestors (including this one) with fee deltas used for mining priority, denominated in BTC
        pub ancestor: rust_decimal::Decimal,
        /// transaction fees of in-mempool descendants (including this one) with fee deltas used for mining priority, denominated in BTC
        pub descendant: rust_decimal::Decimal,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetrawmempoolResultVariant1Value {
        /// virtual transaction size as defined in BIP 141. This is different from actual serialized size for witness transactions as witness data is discounted.
        pub vsize: f64,
        /// transaction weight as defined in BIP 141.
        pub weight: f64,
        /// local time transaction entered pool in seconds since 1 Jan 1970 GMT
        pub time: i64,
        /// block height when transaction entered pool
        pub height: f64,
        /// number of in-mempool descendant transactions (including this one)
        pub descendantcount: f64,
        /// virtual transaction size of in-mempool descendants (including this one)
        pub descendantsize: f64,
        /// number of in-mempool ancestor transactions (including this one)
        pub ancestorcount: f64,
        /// virtual transaction size of in-mempool ancestors (including this one)
        pub ancestorsize: f64,
        /// hash of serialized transaction, including witness data
        pub wtxid: String,
        pub fees: GetrawmempoolResultVariant1ValueFees,
        /// unconfirmed transactions used as inputs for this transaction
        pub depends: Vec<String>,
        /// unconfirmed transactions spending outputs from this transaction
        pub spentby: Vec<String>,
        /// Whether this transaction signals BIP125 replaceability or has an unconfirmed ancestor signaling BIP125 replaceability. (DEPRECATED)
        #[serde(rename = "bip125-replaceable")]
        pub bip125_replaceable: bool,
        /// Whether this transaction is currently unbroadcast (initial broadcast not yet acknowledged by any peers)
        pub unbroadcast: bool,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetrawmempoolResultVariant2 {
        pub txids: Vec<String>,
        /// The mempool sequence value.
        pub mempool_sequence: f64,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    #[serde(untagged)]
    pub enum GetrawmempoolResult {
        /// for verbose = false
        Variant0(Vec<String>),
        /// for verbose = true
        Variant1(std::collections::BTreeMap<String, GetrawmempoolResultVariant1Value>),
        /// for verbose = false and mempool_sequence = true
        Variant2(GetrawmempoolResultVariant2),
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetrawtransactionResultVariant1VinItemScriptSig {
        /// Disassembly of the signature script
        pub asm: String,
        /// The raw signature script bytes, hex-encoded
        pub hex: String,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetrawtransactionResultVariant1VinItem {
        /// The coinbase value (only if coinbase transaction)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub coinbase: Option<String>,
        /// The transaction id (if not coinbase transaction)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub txid: Option<String>,
        /// The output number (if not coinbase transaction)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub vout: Option<f64>,
        /// The script (if not coinbase transaction)
        #[serde(rename = "scriptSig")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub script_sig: Option<GetrawtransactionResultVariant1VinItemScriptSig>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub txinwitness: Option<Vec<String>>,
        /// The script sequence number
        pub sequence: f64,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetrawtransactionResultVariant1VoutItemScriptPubKey {
        /// Disassembly of the output script
        pub asm: String,
        /// Inferred descriptor for the output
        pub desc: String,
        /// The raw output script bytes, hex-encoded
        pub hex: String,
        /// The Bitcoin address (only if a well-defined address exists)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub address: Option<String>,
        /// The type (one of: nonstandard, anchor, pubkey, pubkeyhash, scripthash, multisig, nulldata, witness_v0_scripthash, witness_v0_keyhash, witness_v1_taproot, witness_unknown)
        #[serde(rename = "type")]
        pub type_: String,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetrawtransactionResultVariant1VoutItem {
        /// The value in BTC
        pub value: rust_decimal::Decimal,
        /// index
        pub n: f64,
        #[serde(rename = "scriptPubKey")]
        pub script_pub_key: GetrawtransactionResultVariant1VoutItemScriptPubKey,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetrawtransactionResultVariant1 {
        /// Whether specified block is in the active chain or not (only present with explicit "blockhash" argument)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub in_active_chain: Option<bool>,
        /// the block hash
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub blockhash: Option<String>,
        /// The confirmations
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub confirmations: Option<f64>,
        /// The block time expressed in UNIX epoch time
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub blocktime: Option<i64>,
        /// Same as "blocktime"
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub time: Option<f64>,
        /// The serialized, hex-encoded data for 'txid'
        pub hex: String,
        /// The transaction id (same as provided)
        pub txid: String,
        /// The transaction hash (differs from txid for witness transactions)
        pub hash: String,
        /// The serialized transaction size
        pub size: f64,
        /// The virtual transaction size (differs from size for witness transactions)
        pub vsize: f64,
        /// The transaction's weight (between vsize*4-3 and vsize*4)
        pub weight: f64,
        /// The version
        pub version: f64,
        /// The lock time
        pub locktime: i64,
        pub vin: Vec<GetrawtransactionResultVariant1VinItem>,
        pub vout: Vec<GetrawtransactionResultVariant1VoutItem>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetrawtransactionResultVariant2VinItemPrevoutScriptPubKey {
        /// Disassembly of the output script
        pub asm: String,
        /// Inferred descriptor for the output
        pub desc: String,
        /// The raw output script bytes, hex-encoded
        pub hex: String,
        /// The Bitcoin address (only if a well-defined address exists)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub address: Option<String>,
        /// The type (one of: nonstandard, anchor, pubkey, pubkeyhash, scripthash, multisig, nulldata, witness_v0_scripthash, witness_v0_keyhash, witness_v1_taproot, witness_unknown)
        #[serde(rename = "type")]
        pub type_: String,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetrawtransactionResultVariant2VinItemPrevout {
        /// Coinbase or not
        pub generated: bool,
        /// The height of the prevout
        pub height: f64,
        /// The value in BTC
        pub value: rust_decimal::Decimal,
        #[serde(rename = "scriptPubKey")]
        pub script_pub_key: GetrawtransactionResultVariant2VinItemPrevoutScriptPubKey,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetrawtransactionResultVariant2VinItem {
        /// The previous output, omitted if block undo data is not available
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub prevout: Option<GetrawtransactionResultVariant2VinItemPrevout>,
        /// Additional properties
        #[serde(flatten)]
        pub extra: std::collections::BTreeMap<String, Value>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetrawtransactionResultVariant2 {
        /// transaction fee in BTC, omitted if block undo data is not available
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fee: Option<f64>,
        pub vin: Vec<GetrawtransactionResultVariant2VinItem>,
        /// Additional properties
        #[serde(flatten)]
        pub extra: std::collections::BTreeMap<String, Value>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    #[serde(untagged)]
    pub enum GetrawtransactionResult {
        /// The serialized transaction as a hex-encoded string for 'txid'
        Variant0(String),
        /// if verbosity is set to 1
        Variant1(GetrawtransactionResultVariant1),
        /// for verbosity = 2
        Variant2(GetrawtransactionResultVariant2),
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetrpcinfoResultActiveCommandsItem {
        /// The name of the RPC command
        pub method: String,
        /// The running time in microseconds
        pub duration: f64,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetrpcinfoResult {
        /// All active commands
        pub active_commands: Vec<GetrpcinfoResultActiveCommandsItem>,
        /// The complete file path to the debug log
        pub logpath: String,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GettransactionResultDetailsItem {
        /// The bitcoin address involved in the transaction.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub address: Option<String>,
        /// The transaction category.
        /// "send"                  Transactions sent.
        /// "receive"               Non-coinbase transactions received.
        /// "generate"              Coinbase transactions received with more than 100 confirmations.
        /// "immature"              Coinbase transactions received with 100 or fewer confirmations.
        /// "orphan"                Orphaned coinbase transactions received.
        pub category: String,
        /// The amount in BTC
        pub amount: rust_decimal::Decimal,
        /// A comment for the address/transaction, if any
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub label: Option<String>,
        /// the vout value
        pub vout: f64,
        /// The amount of the fee in BTC. This is negative and only available for the
        /// 'send' category of transactions.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fee: Option<rust_decimal::Decimal>,
        /// 'true' if the transaction has been abandoned (inputs are respendable).
        pub abandoned: bool,
        /// Only if 'category' is 'received'. List of parent descriptors for the output script of this coin.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub parent_descs: Option<Vec<String>>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GettransactionResultLastprocessedblock {
        /// hash of the block this information was generated on
        pub hash: String,
        /// height of the block this information was generated on
        pub height: f64,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GettransactionResult {
        /// The amount in BTC
        pub amount: rust_decimal::Decimal,
        /// The amount of the fee in BTC. This is negative and only available for the
        /// 'send' category of transactions.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fee: Option<rust_decimal::Decimal>,
        /// The number of confirmations for the transaction. Negative confirmations means the
        /// transaction conflicted that many blocks ago.
        pub confirmations: f64,
        /// Only present if the transaction's only input is a coinbase one.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub generated: Option<bool>,
        /// Whether we consider the transaction to be trusted and safe to spend from.
        /// Only present when the transaction has 0 confirmations (or negative confirmations, if conflicted).
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub trusted: Option<bool>,
        /// The block hash containing the transaction.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub blockhash: Option<String>,
        /// The block height containing the transaction.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub blockheight: Option<f64>,
        /// The index of the transaction in the block that includes it.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub blockindex: Option<f64>,
        /// The block time expressed in UNIX epoch time.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub blocktime: Option<i64>,
        /// The transaction id.
        pub txid: String,
        /// The hash of serialized transaction, including witness data.
        pub wtxid: String,
        /// Confirmed transactions that have been detected by the wallet to conflict with this transaction.
        pub walletconflicts: Vec<String>,
        /// Only if 'category' is 'send'. The txid if this tx was replaced.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub replaced_by_txid: Option<String>,
        /// Only if 'category' is 'send'. The txid if this tx replaces another.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub replaces_txid: Option<String>,
        /// Transactions in the mempool that directly conflict with either this transaction or an ancestor transaction
        pub mempoolconflicts: Vec<String>,
        /// If a comment to is associated with the transaction.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub to: Option<String>,
        /// The transaction time expressed in UNIX epoch time.
        pub time: i64,
        /// The time received expressed in UNIX epoch time.
        pub timereceived: i64,
        /// If a comment is associated with the transaction, only present if not empty.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub comment: Option<String>,
        /// ("yes|no|unknown") Whether this transaction signals BIP125 replaceability or has an unconfirmed ancestor signaling BIP125 replaceability.
        /// May be unknown for unconfirmed transactions not in the mempool because their unconfirmed ancestors are unknown.
        #[serde(rename = "bip125-replaceable")]
        pub bip125_replaceable: String,
        /// Only if 'category' is 'received'. List of parent descriptors for the output script of this coin.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub parent_descs: Option<Vec<String>>,
        pub details: Vec<GettransactionResultDetailsItem>,
        /// Raw data for transaction
        pub hex: String,
        /// The decoded transaction (only present when `verbose` is passed)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub decoded: Option<std::collections::BTreeMap<String, Value>>,
        /// hash and height of the block this information was generated on
        pub lastprocessedblock: GettransactionResultLastprocessedblock,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GettxoutResultScriptPubKey {
        /// Disassembly of the output script
        pub asm: String,
        /// Inferred descriptor for the output
        pub desc: String,
        /// The raw output script bytes, hex-encoded
        pub hex: String,
        /// The type, eg pubkeyhash
        #[serde(rename = "type")]
        pub type_: String,
        /// The Bitcoin address (only if a well-defined address exists)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub address: Option<String>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GettxoutResult {
        /// The hash of the block at the tip of the chain
        pub bestblock: String,
        /// The number of confirmations
        pub confirmations: f64,
        /// The transaction value in BTC
        pub value: rust_decimal::Decimal,
        #[serde(rename = "scriptPubKey")]
        pub script_pub_key: GettxoutResultScriptPubKey,
        /// Coinbase or not
        pub coinbase: bool,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GettxoutsetinfoResultBlockInfoUnspendables {
        /// The unspendable amount of the Genesis block subsidy
        pub genesis_block: rust_decimal::Decimal,
        /// Transactions overridden by duplicates (no longer possible with BIP30)
        pub bip30: rust_decimal::Decimal,
        /// Amounts sent to scripts that are unspendable (for example OP_RETURN outputs)
        pub scripts: rust_decimal::Decimal,
        /// Fee rewards that miners did not claim in their coinbase transaction
        pub unclaimed_rewards: rust_decimal::Decimal,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GettxoutsetinfoResultBlockInfo {
        /// Total amount of all prevouts spent in this block
        pub prevout_spent: rust_decimal::Decimal,
        /// Coinbase subsidy amount of this block
        pub coinbase: rust_decimal::Decimal,
        /// Total amount of new outputs created by this block
        pub new_outputs_ex_coinbase: rust_decimal::Decimal,
        /// Total amount of unspendable outputs created in this block
        pub unspendable: rust_decimal::Decimal,
        /// Detailed view of the unspendable categories
        pub unspendables: GettxoutsetinfoResultBlockInfoUnspendables,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GettxoutsetinfoResult {
        /// The block height (index) of the returned statistics
        pub height: f64,
        /// The hash of the block at which these statistics are calculated
        pub bestblock: String,
        /// The number of unspent transaction outputs
        pub txouts: f64,
        /// Database-independent, meaningless metric indicating the UTXO set size
        pub bogosize: f64,
        /// The serialized hash (only present if 'hash_serialized_3' hash_type is chosen)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub hash_serialized_3: Option<String>,
        /// The serialized hash (only present if 'muhash' hash_type is chosen)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub muhash: Option<String>,
        /// The number of transactions with unspent outputs (not available when coinstatsindex is used)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub transactions: Option<f64>,
        /// The estimated size of the chainstate on disk (not available when coinstatsindex is used)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub disk_size: Option<f64>,
        /// The total amount of coins in the UTXO set
        pub total_amount: rust_decimal::Decimal,
        /// The total amount of coins permanently excluded from the UTXO set (only available if coinstatsindex is used)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_unspendable_amount: Option<rust_decimal::Decimal>,
        /// Info on amounts in the block at this block height (only available if coinstatsindex is used)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub block_info: Option<GettxoutsetinfoResultBlockInfo>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GettxspendingprevoutOutputsItem {
        /// The transaction id
        pub txid: String,
        /// The output number
        pub vout: f64,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GettxspendingprevoutResultItem {
        /// the transaction id of the checked output
        pub txid: String,
        /// the vout value of the checked output
        pub vout: f64,
        /// the transaction id of the mempool transaction spending this output (omitted if unspent)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub spendingtxid: Option<String>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetwalletinfoResultScanning {
        /// elapsed seconds since scan start
        pub duration: f64,
        /// scanning progress percentage [0.0, 1.0]
        pub progress: f64,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetwalletinfoResultLastprocessedblock {
        /// hash of the block this information was generated on
        pub hash: String,
        /// height of the block this information was generated on
        pub height: f64,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct GetwalletinfoResult {
        /// the wallet name
        pub walletname: String,
        /// (DEPRECATED) only related to unsupported legacy wallet, returns the latest version 169900 for backwards compatibility
        pub walletversion: f64,
        /// the database format (only sqlite)
        pub format: String,
        /// the total number of transactions in the wallet
        pub txcount: f64,
        /// how many new keys are pre-generated (only counts external keys)
        pub keypoolsize: f64,
        /// how many new keys are pre-generated for internal use (used for change outputs, only appears if the wallet is using this feature, otherwise external keys are used)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub keypoolsize_hd_internal: Option<f64>,
        /// the UNIX epoch time until which the wallet is unlocked for transfers, or 0 if the wallet is locked (only present for passphrase-encrypted wallets)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub unlocked_until: Option<i64>,
        /// the transaction fee configuration, set in BTC/kvB
        pub paytxfee: rust_decimal::Decimal,
        /// false if privatekeys are disabled for this wallet (enforced watch-only wallet)
        pub private_keys_enabled: bool,
        /// whether this wallet tracks clean/dirty coins in terms of reuse
        pub avoid_reuse: bool,
        /// current scanning details, or false if no scan is in progress
        pub scanning: GetwalletinfoResultScanning,
        /// whether this wallet uses descriptors for output script management
        pub descriptors: bool,
        /// whether this wallet is configured to use an external signer such as a hardware wallet
        pub external_signer: bool,
        /// Whether this wallet intentionally does not contain any keys, scripts, or descriptors
        pub blank: bool,
        /// The start time for blocks scanning. It could be modified by (re)importing any descriptor with an earlier timestamp.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub birthtime: Option<i64>,
        /// The flags currently set on the wallet
        pub flags: Vec<String>,
        /// hash and height of the block this information was generated on
        pub lastprocessedblock: GetwalletinfoResultLastprocessedblock,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ImportdescriptorsRequestsItem {
        /// Descriptor to import.
        pub desc: String,
        /// Set this descriptor to be the active descriptor for the corresponding output type/externality
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub active: Option<bool>,
        /// If a ranged descriptor is used, this specifies the end or the range (in the form [begin,end]) to import
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub range: Option<RangeParam>,
        /// If a ranged descriptor is set to active, this specifies the next index to generate addresses from
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_index: Option<f64>,
        /// Time from which to start rescanning the blockchain for this descriptor, in UNIX epoch time
        /// Use the string "now" to substitute the current synced blockchain time.
        /// "now" can be specified to bypass scanning, for outputs which are known to never have been used, and
        /// 0 can be specified to scan the entire blockchain. Blocks up to 2 hours before the earliest timestamp
        /// of all descriptors being imported will be scanned as well as the mempool.
        pub timestamp: f64,
        /// Whether matching outputs should be treated as not incoming payments (e.g. change)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub internal: Option<bool>,
        /// Label to assign to the address, only allowed with internal=false. Disabled for ranged descriptors
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub label: Option<String>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ImportdescriptorsResultItem {
        pub success: bool,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub warnings: Option<Vec<String>>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub error: Option<std::collections::BTreeMap<String, Value>>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ImportmempoolOptions {
        /// Whether to use the current system time or use the entry time metadata from the mempool file.
        /// Warning: Importing untrusted metadata may lead to unexpected issues and undesirable behavior.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub use_current_time: Option<bool>,
        /// Whether to apply the fee delta metadata from the mempool file.
        /// It will be added to any existing fee deltas.
        /// The fee delta can be set by the prioritisetransaction RPC.
        /// Warning: Importing untrusted metadata may lead to unexpected issues and undesirable behavior.
        /// Only set this bool if you understand what it does.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub apply_fee_delta_priority: Option<bool>,
        /// Whether to apply the unbroadcast set metadata from the mempool file.
        /// Warning: Importing untrusted metadata may lead to unexpected issues and undesirable behavior.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub apply_unbroadcast_set: Option<bool>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ListbannedResultItem {
        /// The IP/Subnet of the banned node
        pub address: String,
        /// The UNIX epoch time the ban was created
        pub ban_created: i64,
        /// The UNIX epoch time the ban expires
        pub banned_until: i64,
        /// The ban duration, in seconds
        pub ban_duration: i64,
        /// The time remaining until the ban expires, in seconds
        pub time_remaining: i64,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ListdescriptorsResultDescriptorsItem {
        /// Descriptor string representation
        pub desc: String,
        /// The creation time of the descriptor
        pub timestamp: f64,
        /// Whether this descriptor is currently used to generate new addresses
        pub active: bool,
        /// True if this descriptor is used to generate change addresses. False if this descriptor is used to generate receiving addresses; defined only for active descriptors
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub internal: Option<bool>,
        /// Defined only for ranged descriptors
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub range: Option<Vec<Value>>,
        /// Same as next_index field. Kept for compatibility reason.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next: Option<f64>,
        /// The next index to generate addresses from; defined only for ranged descriptors
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_index: Option<f64>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ListdescriptorsResult {
        /// Name of wallet this operation was performed on
        pub wallet_name: String,
        /// Array of descriptor objects (sorted by descriptor string representation)
        pub descriptors: Vec<ListdescriptorsResultDescriptorsItem>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ListlockunspentResultItem {
        /// The transaction id locked
        pub txid: String,
        /// The vout value
        pub vout: f64,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ListreceivedbyaddressResultItem {
        /// The receiving address
        pub address: String,
        /// The total amount in BTC received by the address
        pub amount: rust_decimal::Decimal,
        /// The number of confirmations of the most recent transaction included
        pub confirmations: f64,
        /// The label of the receiving address. The default label is ""
        pub label: String,
        pub txids: Vec<String>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ListreceivedbylabelResultItem {
        /// The total amount received by addresses with this label
        pub amount: rust_decimal::Decimal,
        /// The number of confirmations of the most recent transaction included
        pub confirmations: f64,
        /// The label of the receiving address. The default label is ""
        pub label: String,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ListsinceblockResultTransactionsItem {
        /// The bitcoin address of the transaction (not returned if the output does not have an address, e.g. OP_RETURN null data).
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub address: Option<String>,
        /// The transaction category.
        /// "send"                  Transactions sent.
        /// "receive"               Non-coinbase transactions received.
        /// "generate"              Coinbase transactions received with more than 100 confirmations.
        /// "immature"              Coinbase transactions received with 100 or fewer confirmations.
        /// "orphan"                Orphaned coinbase transactions received.
        pub category: String,
        /// The amount in BTC. This is negative for the 'send' category, and is positive
        /// for all other categories
        pub amount: rust_decimal::Decimal,
        /// the vout value
        pub vout: f64,
        /// The amount of the fee in BTC. This is negative and only available for the
        /// 'send' category of transactions.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fee: Option<rust_decimal::Decimal>,
        /// The number of confirmations for the transaction. Negative confirmations means the
        /// transaction conflicted that many blocks ago.
        pub confirmations: f64,
        /// Only present if the transaction's only input is a coinbase one.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub generated: Option<bool>,
        /// Whether we consider the transaction to be trusted and safe to spend from.
        /// Only present when the transaction has 0 confirmations (or negative confirmations, if conflicted).
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub trusted: Option<bool>,
        /// The block hash containing the transaction.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub blockhash: Option<String>,
        /// The block height containing the transaction.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub blockheight: Option<f64>,
        /// The index of the transaction in the block that includes it.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub blockindex: Option<f64>,
        /// The block time expressed in UNIX epoch time.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub blocktime: Option<i64>,
        /// The transaction id.
        pub txid: String,
        /// The hash of serialized transaction, including witness data.
        pub wtxid: String,
        /// Confirmed transactions that have been detected by the wallet to conflict with this transaction.
        pub walletconflicts: Vec<String>,
        /// Only if 'category' is 'send'. The txid if this tx was replaced.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub replaced_by_txid: Option<String>,
        /// Only if 'category' is 'send'. The txid if this tx replaces another.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub replaces_txid: Option<String>,
        /// Transactions in the mempool that directly conflict with either this transaction or an ancestor transaction
        pub mempoolconflicts: Vec<String>,
        /// If a comment to is associated with the transaction.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub to: Option<String>,
        /// The transaction time expressed in UNIX epoch time.
        pub time: i64,
        /// The time received expressed in UNIX epoch time.
        pub timereceived: i64,
        /// If a comment is associated with the transaction, only present if not empty.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub comment: Option<String>,
        /// ("yes|no|unknown") Whether this transaction signals BIP125 replaceability or has an unconfirmed ancestor signaling BIP125 replaceability.
        /// May be unknown for unconfirmed transactions not in the mempool because their unconfirmed ancestors are unknown.
        #[serde(rename = "bip125-replaceable")]
        pub bip125_replaceable: String,
        /// Only if 'category' is 'received'. List of parent descriptors for the output script of this coin.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub parent_descs: Option<Vec<String>>,
        /// 'true' if the transaction has been abandoned (inputs are respendable).
        pub abandoned: bool,
        /// A comment for the address/transaction, if any
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub label: Option<String>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ListsinceblockResult {
        pub transactions: Vec<ListsinceblockResultTransactionsItem>,
        /// <structure is the same as "transactions" above, only present if include_removed=true>
        /// Note: transactions that were re-added in the active chain will appear as-is in this array, and may thus have a positive confirmation count.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub removed: Option<Vec<Value>>,
        /// The hash of the block (target_confirmations-1) from the best block on the main chain, or the genesis hash if the referenced block does not exist yet. This is typically used to feed back into listsinceblock the next time you call it. So you would generally use a target_confirmations of say 6, so you will be continually re-notified of transactions until they've reached 6 confirmations plus any new ones
        pub lastblock: String,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ListtransactionsResultItem {
        /// The bitcoin address of the transaction (not returned if the output does not have an address, e.g. OP_RETURN null data).
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub address: Option<String>,
        /// The transaction category.
        /// "send"                  Transactions sent.
        /// "receive"               Non-coinbase transactions received.
        /// "generate"              Coinbase transactions received with more than 100 confirmations.
        /// "immature"              Coinbase transactions received with 100 or fewer confirmations.
        /// "orphan"                Orphaned coinbase transactions received.
        pub category: String,
        /// The amount in BTC. This is negative for the 'send' category, and is positive
        /// for all other categories
        pub amount: rust_decimal::Decimal,
        /// A comment for the address/transaction, if any
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub label: Option<String>,
        /// the vout value
        pub vout: f64,
        /// The amount of the fee in BTC. This is negative and only available for the
        /// 'send' category of transactions.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fee: Option<rust_decimal::Decimal>,
        /// The number of confirmations for the transaction. Negative confirmations means the
        /// transaction conflicted that many blocks ago.
        pub confirmations: f64,
        /// Only present if the transaction's only input is a coinbase one.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub generated: Option<bool>,
        /// Whether we consider the transaction to be trusted and safe to spend from.
        /// Only present when the transaction has 0 confirmations (or negative confirmations, if conflicted).
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub trusted: Option<bool>,
        /// The block hash containing the transaction.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub blockhash: Option<String>,
        /// The block height containing the transaction.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub blockheight: Option<f64>,
        /// The index of the transaction in the block that includes it.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub blockindex: Option<f64>,
        /// The block time expressed in UNIX epoch time.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub blocktime: Option<i64>,
        /// The transaction id.
        pub txid: String,
        /// The hash of serialized transaction, including witness data.
        pub wtxid: String,
        /// Confirmed transactions that have been detected by the wallet to conflict with this transaction.
        pub walletconflicts: Vec<String>,
        /// Only if 'category' is 'send'. The txid if this tx was replaced.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub replaced_by_txid: Option<String>,
        /// Only if 'category' is 'send'. The txid if this tx replaces another.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub replaces_txid: Option<String>,
        /// Transactions in the mempool that directly conflict with either this transaction or an ancestor transaction
        pub mempoolconflicts: Vec<String>,
        /// If a comment to is associated with the transaction.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub to: Option<String>,
        /// The transaction time expressed in UNIX epoch time.
        pub time: i64,
        /// The time received expressed in UNIX epoch time.
        pub timereceived: i64,
        /// If a comment is associated with the transaction, only present if not empty.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub comment: Option<String>,
        /// ("yes|no|unknown") Whether this transaction signals BIP125 replaceability or has an unconfirmed ancestor signaling BIP125 replaceability.
        /// May be unknown for unconfirmed transactions not in the mempool because their unconfirmed ancestors are unknown.
        #[serde(rename = "bip125-replaceable")]
        pub bip125_replaceable: String,
        /// Only if 'category' is 'received'. List of parent descriptors for the output script of this coin.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub parent_descs: Option<Vec<String>>,
        /// 'true' if the transaction has been abandoned (inputs are respendable).
        pub abandoned: bool,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ListunspentQueryOptions {
        /// Minimum value of each UTXO in BTC
        #[serde(rename = "minimumAmount")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub minimum_amount: Option<rust_decimal::Decimal>,
        /// Maximum value of each UTXO in BTC
        #[serde(rename = "maximumAmount")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub maximum_amount: Option<rust_decimal::Decimal>,
        /// Maximum number of UTXOs
        #[serde(rename = "maximumCount")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub maximum_count: Option<f64>,
        /// Minimum sum value of all UTXOs in BTC
        #[serde(rename = "minimumSumAmount")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub minimum_sum_amount: Option<rust_decimal::Decimal>,
        /// Include immature coinbase UTXOs
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub include_immature_coinbase: Option<bool>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ListunspentResultItem {
        /// the transaction id
        pub txid: String,
        /// the vout value
        pub vout: f64,
        /// the bitcoin address
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub address: Option<String>,
        /// The associated label, or "" for the default label
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub label: Option<String>,
        /// the output script
        #[serde(rename = "scriptPubKey")]
        pub script_pub_key: String,
        /// the transaction output amount in BTC
        pub amount: rust_decimal::Decimal,
        /// The number of confirmations
        pub confirmations: f64,
        /// The number of in-mempool ancestor transactions, including this one (if transaction is in the mempool)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ancestorcount: Option<f64>,
        /// The virtual transaction size of in-mempool ancestors, including this one (if transaction is in the mempool)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ancestorsize: Option<f64>,
        /// The total fees of in-mempool ancestors (including this one) with fee deltas used for mining priority in sat (if transaction is in the mempool)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ancestorfees: Option<rust_decimal::Decimal>,
        /// The redeem script if the output script is P2SH
        #[serde(rename = "redeemScript")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub redeem_script: Option<String>,
        /// witness script if the output script is P2WSH or P2SH-P2WSH
        #[serde(rename = "witnessScript")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub witness_script: Option<String>,
        /// (DEPRECATED) Always true
        pub spendable: bool,
        /// Whether we know how to spend this output, ignoring the lack of keys
        pub solvable: bool,
        /// (only present if avoid_reuse is set) Whether this output is reused/dirty (sent to an address that was previously spent from)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub reused: Option<bool>,
        /// (only when solvable) A descriptor for spending this output
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub desc: Option<String>,
        /// List of parent descriptors for the output script of this coin.
        pub parent_descs: Vec<String>,
        /// Whether this output is considered safe to spend. Unconfirmed transactions
        /// from outside keys and unconfirmed replacement transactions are considered unsafe
        /// and are not eligible for spending by fundrawtransaction and sendtoaddress.
        pub safe: bool,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ListwalletdirResultWalletsItem {
        /// The wallet name
        pub name: String,
        /// Warning messages, if any, related to loading the wallet.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub warnings: Option<Vec<String>>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ListwalletdirResult {
        pub wallets: Vec<ListwalletdirResultWalletsItem>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct LoadtxoutsetResult {
        /// the number of coins loaded from the snapshot
        pub coins_loaded: f64,
        /// the hash of the base of the snapshot
        pub tip_hash: String,
        /// the height of the base of the snapshot
        pub base_height: f64,
        /// the absolute path that the snapshot was loaded from
        pub path: String,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct LoadwalletResult {
        /// The wallet name if loaded successfully.
        pub name: String,
        /// Warning messages, if any, related to loading the wallet.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub warnings: Option<Vec<String>>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct LockunspentTransactionsItem {
        /// The transaction id
        pub txid: String,
        /// The output number
        pub vout: f64,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct MigratewalletResult {
        /// The name of the primary migrated wallet
        pub wallet_name: String,
        /// The name of the migrated wallet containing the watchonly scripts
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub watchonly_name: Option<String>,
        /// The name of the migrated wallet containing solvable but not watched scripts
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub solvables_name: Option<String>,
        /// The location of the backup of the original wallet
        pub backup_path: String,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PsbtbumpfeeOptions {
        /// Confirmation target in blocks
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub conf_target: Option<f64>,
        /// Specify a fee rate in sat/vB instead of relying on the built-in fee estimator.
        /// Must be at least 0.100 sat/vB higher than the current transaction fee rate.
        /// WARNING: before version 0.21, fee_rate was in BTC/kvB. As of 0.21, fee_rate is in sat/vB.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fee_rate: Option<rust_decimal::Decimal>,
        /// Whether the new transaction should be
        /// marked bip-125 replaceable. If true, the sequence numbers in the transaction will
        /// be set to 0xfffffffd. If false, any input sequence numbers in the
        /// transaction will be set to 0xfffffffe
        /// so the new transaction will not be explicitly bip-125 replaceable (though it may
        /// still be replaceable in practice, for example if it has unconfirmed ancestors which
        /// are replaceable).
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub replaceable: Option<bool>,
        /// The fee estimate mode, must be one of (case insensitive):
        /// unset, economical, conservative
        /// unset means no mode set (economical mode is used if the transaction is replaceable;
        /// otherwise, conservative mode is used).
        /// economical estimates use a shorter time horizon, making them more
        /// responsive to short-term drops in the prevailing fee market. This mode
        /// potentially returns a lower fee rate estimate.
        /// conservative estimates use a longer time horizon, making them
        /// less responsive to short-term drops in the prevailing fee market. This mode
        /// potentially returns a higher fee rate estimate.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub estimate_mode: Option<String>,
        /// The outputs specified as key-value pairs.
        /// Each key may only appear once, i.e. there can only be one 'data' output, and no address may be duplicated.
        /// At least one output of either type must be specified.
        /// Cannot be provided if 'original_change_index' is specified.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub outputs: Option<Vec<Value>>,
        /// The 0-based index of the change output on the original transaction. The indicated output will be recycled into the new change output on the bumped transaction. The remainder after paying the recipients and fees will be sent to the output script of the original change output. The change outputâ€™s amount can increase if bumping the transaction adds new inputs, otherwise it will decrease. Cannot be used in combination with the 'outputs' option.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub original_change_index: Option<f64>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct PsbtbumpfeeResult {
        /// The base64-encoded unsigned PSBT of the new transaction.
        pub psbt: String,
        /// The fee of the replaced transaction.
        pub origfee: rust_decimal::Decimal,
        /// The fee of the new transaction.
        pub fee: rust_decimal::Decimal,
        /// Errors encountered during processing (may be empty).
        pub errors: Vec<String>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RescanblockchainResult {
        /// The block height where the rescan started (the requested height or 0)
        pub start_height: f64,
        /// The height of the last rescanned block. May be null in rare cases if there was a reorg and the call didn't scan any blocks because they were already scanned in the background.
        pub stop_height: f64,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct RestorewalletResult {
        /// The wallet name if restored successfully.
        pub name: String,
        /// Warning messages, if any, related to restoring and loading the wallet.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub warnings: Option<Vec<String>>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SavemempoolResult {
        /// the directory and file where the mempool was saved
        pub filename: String,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ScanblocksOptions {
        /// Filter false positives (slower and may fail on pruned nodes). Otherwise they may occur at a rate of 1/M
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub filter_false_positives: Option<bool>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ScanblocksResultVariant1 {
        /// The height we started the scan from
        pub from_height: f64,
        /// The height we ended the scan at
        pub to_height: f64,
        /// Blocks that may have matched a scanobject.
        pub relevant_blocks: Vec<String>,
        /// true if the scan process was not aborted
        pub completed: bool,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ScanblocksResultVariant2 {
        /// Approximate percent complete
        pub progress: f64,
        /// Height of the block currently being scanned
        pub current_height: f64,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    #[serde(untagged)]
    pub enum ScanblocksResult {
        /// when action=='status' and no scan is in progress - possibly already completed
        Variant0(()),
        /// When action=='start'; only returns after scan completes
        Variant1(ScanblocksResultVariant1),
        /// when action=='status' and a scan is currently in progress
        Variant2(ScanblocksResultVariant2),
        /// True if scan will be aborted (not necessarily before this RPC returns), or false if there is no scan to abort
        Variant3(bool),
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ScantxoutsetResultVariant0UnspentsItem {
        /// The transaction id
        pub txid: String,
        /// The vout value
        pub vout: f64,
        /// The output script
        #[serde(rename = "scriptPubKey")]
        pub script_pub_key: String,
        /// A specialized descriptor for the matched output script
        pub desc: String,
        /// The total amount in BTC of the unspent output
        pub amount: rust_decimal::Decimal,
        /// Whether this is a coinbase output
        pub coinbase: bool,
        /// Height of the unspent transaction output
        pub height: f64,
        /// Blockhash of the unspent transaction output
        pub blockhash: String,
        /// Number of confirmations of the unspent transaction output when the scan was done
        pub confirmations: f64,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ScantxoutsetResultVariant0 {
        /// Whether the scan was completed
        pub success: bool,
        /// The number of unspent transaction outputs scanned
        pub txouts: f64,
        /// The block height at which the scan was done
        pub height: f64,
        /// The hash of the block at the tip of the chain
        pub bestblock: String,
        pub unspents: Vec<ScantxoutsetResultVariant0UnspentsItem>,
        /// The total amount of all found unspent outputs in BTC
        pub total_amount: rust_decimal::Decimal,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ScantxoutsetResultVariant2 {
        /// Approximate percent complete
        pub progress: f64,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    #[serde(untagged)]
    pub enum ScantxoutsetResult {
        /// when action=='start'; only returns after scan completes
        Variant0(ScantxoutsetResultVariant0),
        /// True if scan will be aborted (not necessarily before this RPC returns), or false if there is no scan to abort
        Variant1(bool),
        /// when action=='status' and a scan is currently in progress
        Variant2(ScantxoutsetResultVariant2),
        /// when action=='status' and no scan is in progress - possibly already completed
        Variant3(()),
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SendOptionsInputsItem {
        /// The transaction id
        pub txid: String,
        /// The output number
        pub vout: f64,
        /// The sequence number
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub sequence: Option<f64>,
        /// The maximum weight for this input, including the weight of the outpoint and sequence number. Note that signature sizes are not guaranteed to be consistent, so the maximum DER signatures size of 73 bytes should be used when considering ECDSA signatures.Remember to convert serialized sizes to weight units when necessary.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub weight: Option<f64>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SendOptionsSolvingData {
        /// Public keys involved in this transaction.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pubkeys: Option<Vec<String>>,
        /// Scripts involved in this transaction.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub scripts: Option<Vec<String>>,
        /// Descriptors that provide solving data for this transaction.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub descriptors: Option<Vec<String>>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SendOptions {
        /// Automatically include coins from the wallet to cover the target amount.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub add_inputs: Option<bool>,
        /// Include inputs that are not safe to spend (unconfirmed transactions from outside keys and unconfirmed replacement transactions).
        /// Warning: the resulting transaction may become invalid if one of the unsafe inputs disappears.
        /// If that happens, you will need to fund the transaction with different inputs and republish it.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub include_unsafe: Option<bool>,
        /// If add_inputs is specified, require inputs with at least this many confirmations.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub minconf: Option<f64>,
        /// If add_inputs is specified, require inputs with at most this many confirmations.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub maxconf: Option<f64>,
        /// When false, returns a serialized transaction which will not be added to the wallet or broadcast
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub add_to_wallet: Option<bool>,
        /// The bitcoin address to receive the change
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub change_address: Option<String>,
        /// The index of the change output
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub change_position: Option<f64>,
        /// The output type to use. Only valid if change_address is not specified. Options are "legacy", "p2sh-segwit", "bech32", "bech32m".
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub change_type: Option<String>,
        /// Specify a fee rate in sat/vB.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fee_rate: Option<rust_decimal::Decimal>,
        /// (DEPRECATED) No longer used
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub include_watching: Option<bool>,
        /// Specify inputs instead of adding them automatically.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub inputs: Option<Vec<SendOptionsInputsItem>>,
        /// Raw locktime. Non-0 value also locktime-activates inputs
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub locktime: Option<f64>,
        /// Lock selected unspent outputs
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub lock_unspents: Option<bool>,
        /// Always return a PSBT, implies add_to_wallet=false.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub psbt: Option<bool>,
        /// Outputs to subtract the fee from, specified as integer indices.
        /// The fee will be equally deducted from the amount of each specified output.
        /// Those recipients will receive less bitcoins than you enter in their corresponding amount field.
        /// If no outputs are specified here, the sender pays the fee.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub subtract_fee_from_outputs: Option<Vec<f64>>,
        /// The maximum acceptable transaction weight.
        /// Transaction building will fail if this can not be satisfied.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub max_tx_weight: Option<f64>,
        /// Confirmation target in blocks
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub conf_target: Option<f64>,
        /// The fee estimate mode, must be one of (case insensitive):
        /// unset, economical, conservative
        /// unset means no mode set (economical mode is used if the transaction is replaceable;
        /// otherwise, conservative mode is used).
        /// economical estimates use a shorter time horizon, making them more
        /// responsive to short-term drops in the prevailing fee market. This mode
        /// potentially returns a lower fee rate estimate.
        /// conservative estimates use a longer time horizon, making them
        /// less responsive to short-term drops in the prevailing fee market. This mode
        /// potentially returns a higher fee rate estimate.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub estimate_mode: Option<String>,
        /// Marks this transaction as BIP125-replaceable.
        /// Allows this transaction to be replaced by a transaction with higher fees
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub replaceable: Option<bool>,
        /// Keys and scripts needed for producing a final transaction with a dummy signature.
        /// Used for fee estimation during coin selection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub solving_data: Option<SendOptionsSolvingData>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SendResult {
        /// If the transaction has a complete set of signatures
        pub complete: bool,
        /// The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub txid: Option<String>,
        /// If add_to_wallet is false, the hex-encoded raw transaction with signature(s)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub hex: Option<String>,
        /// If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub psbt: Option<String>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SendallOptionsInputsItem {
        /// The transaction id
        pub txid: String,
        /// The output number
        pub vout: f64,
        /// The sequence number
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub sequence: Option<f64>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SendallOptionsSolvingData {
        /// Public keys involved in this transaction.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pubkeys: Option<Vec<String>>,
        /// Scripts involved in this transaction.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub scripts: Option<Vec<String>>,
        /// Descriptors that provide solving data for this transaction.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub descriptors: Option<Vec<String>>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SendallOptions {
        /// When false, returns the serialized transaction without broadcasting or adding it to the wallet
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub add_to_wallet: Option<bool>,
        /// Specify a fee rate in sat/vB.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fee_rate: Option<rust_decimal::Decimal>,
        /// (DEPRECATED) No longer used
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub include_watching: Option<bool>,
        /// Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with the send_max, minconf, and maxconf options.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub inputs: Option<Vec<SendallOptionsInputsItem>>,
        /// Raw locktime. Non-0 value also locktime-activates inputs
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub locktime: Option<f64>,
        /// Lock selected unspent outputs
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub lock_unspents: Option<bool>,
        /// Always return a PSBT, implies add_to_wallet=false.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub psbt: Option<bool>,
        /// When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub send_max: Option<bool>,
        /// Require inputs with at least this many confirmations.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub minconf: Option<f64>,
        /// Require inputs with at most this many confirmations.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub maxconf: Option<f64>,
        /// Transaction version
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub version: Option<f64>,
        /// Confirmation target in blocks
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub conf_target: Option<f64>,
        /// The fee estimate mode, must be one of (case insensitive):
        /// unset, economical, conservative
        /// unset means no mode set (economical mode is used if the transaction is replaceable;
        /// otherwise, conservative mode is used).
        /// economical estimates use a shorter time horizon, making them more
        /// responsive to short-term drops in the prevailing fee market. This mode
        /// potentially returns a lower fee rate estimate.
        /// conservative estimates use a longer time horizon, making them
        /// less responsive to short-term drops in the prevailing fee market. This mode
        /// potentially returns a higher fee rate estimate.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub estimate_mode: Option<String>,
        /// Marks this transaction as BIP125-replaceable.
        /// Allows this transaction to be replaced by a transaction with higher fees
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub replaceable: Option<bool>,
        /// Keys and scripts needed for producing a final transaction with a dummy signature.
        /// Used for fee estimation during coin selection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub solving_data: Option<SendallOptionsSolvingData>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SendallResult {
        /// If the transaction has a complete set of signatures
        pub complete: bool,
        /// The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub txid: Option<String>,
        /// If add_to_wallet is false, the hex-encoded raw transaction with signature(s)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub hex: Option<String>,
        /// If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub psbt: Option<String>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SendmanyResultVariant1 {
        /// The transaction id for the send. Only 1 transaction is created regardless of
        /// the number of addresses.
        pub txid: String,
        /// The transaction fee reason.
        pub fee_reason: String,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    #[serde(untagged)]
    pub enum SendmanyResult {
        /// The transaction id for the send. Only 1 transaction is created regardless of
        /// the number of addresses.
        Variant0(String),
        /// if verbose is set to true
        Variant1(SendmanyResultVariant1),
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SendtoaddressResultVariant1 {
        /// The transaction id.
        pub txid: String,
        /// The transaction fee reason.
        pub fee_reason: String,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    #[serde(untagged)]
    pub enum SendtoaddressResult {
        /// The transaction id.
        Variant0(String),
        /// if verbose is set to true
        Variant1(SendtoaddressResultVariant1),
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SetwalletflagResult {
        /// The name of the flag that was modified
        pub flag_name: String,
        /// The new state of the flag
        pub flag_state: bool,
        /// Any warnings associated with the change
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub warnings: Option<String>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SignrawtransactionwithkeyPrevtxsItem {
        /// The transaction id
        pub txid: String,
        /// The output number
        pub vout: f64,
        /// output script
        #[serde(rename = "scriptPubKey")]
        pub script_pub_key: String,
        /// (required for P2SH) redeem script
        #[serde(rename = "redeemScript")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub redeem_script: Option<String>,
        /// (required for P2WSH or P2SH-P2WSH) witness script
        #[serde(rename = "witnessScript")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub witness_script: Option<String>,
        /// (required for Segwit inputs) the amount spent
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub amount: Option<rust_decimal::Decimal>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SignrawtransactionwithkeyResultErrorsItem {
        /// The hash of the referenced, previous transaction
        pub txid: String,
        /// The index of the output to spent and used as input
        pub vout: f64,
        pub witness: Vec<String>,
        /// The hex-encoded signature script
        #[serde(rename = "scriptSig")]
        pub script_sig: String,
        /// Script sequence number
        pub sequence: f64,
        /// Verification or signing error related to the input
        pub error: String,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SignrawtransactionwithkeyResult {
        /// The hex-encoded raw transaction with signature(s)
        pub hex: String,
        /// If the transaction has a complete set of signatures
        pub complete: bool,
        /// Script verification errors (if there are any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub errors: Option<Vec<SignrawtransactionwithkeyResultErrorsItem>>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SignrawtransactionwithwalletPrevtxsItem {
        /// The transaction id
        pub txid: String,
        /// The output number
        pub vout: f64,
        /// The output script
        #[serde(rename = "scriptPubKey")]
        pub script_pub_key: String,
        /// (required for P2SH) redeem script
        #[serde(rename = "redeemScript")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub redeem_script: Option<String>,
        /// (required for P2WSH or P2SH-P2WSH) witness script
        #[serde(rename = "witnessScript")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub witness_script: Option<String>,
        /// (required for Segwit inputs) the amount spent
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub amount: Option<rust_decimal::Decimal>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SignrawtransactionwithwalletResultErrorsItem {
        /// The hash of the referenced, previous transaction
        pub txid: String,
        /// The index of the output to spent and used as input
        pub vout: f64,
        pub witness: Vec<String>,
        /// The hex-encoded signature script
        #[serde(rename = "scriptSig")]
        pub script_sig: String,
        /// Script sequence number
        pub sequence: f64,
        /// Verification or signing error related to the input
        pub error: String,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SignrawtransactionwithwalletResult {
        /// The hex-encoded raw transaction with signature(s)
        pub hex: String,
        /// If the transaction has a complete set of signatures
        pub complete: bool,
        /// Script verification errors (if there are any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub errors: Option<Vec<SignrawtransactionwithwalletResultErrorsItem>>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SimulaterawtransactionOptions {
        /// (DEPRECATED) No longer used
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub include_watchonly: Option<bool>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SimulaterawtransactionResult {
        /// The wallet balance change (negative means decrease).
        pub balance_change: rust_decimal::Decimal,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SubmitpackageResultTxResultsValueFees {
        /// transaction fee in BTC
        pub base: rust_decimal::Decimal,
        /// if the transaction was not already in the mempool, the effective feerate in BTC per KvB. For example, the package feerate and/or feerate with modified fees from prioritisetransaction.
        #[serde(rename = "effective-feerate")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub effective_feerate: Option<rust_decimal::Decimal>,
        /// if effective-feerate is provided, the wtxids of the transactions whose fees and vsizes are included in effective-feerate.
        #[serde(rename = "effective-includes")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub effective_includes: Option<Vec<String>>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SubmitpackageResultTxResultsValue {
        /// The transaction hash in hex
        pub txid: String,
        /// The wtxid of a different transaction with the same txid but different witness found in the mempool. This means the submitted transaction was ignored.
        #[serde(rename = "other-wtxid")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub other_wtxid: Option<String>,
        /// Sigops-adjusted virtual transaction size.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub vsize: Option<f64>,
        /// Transaction fees
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fees: Option<SubmitpackageResultTxResultsValueFees>,
        /// The transaction error string, if it was rejected by the mempool
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub error: Option<String>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct SubmitpackageResult {
        /// The transaction package result message. "success" indicates all transactions were accepted into or are already in the mempool.
        pub package_msg: String,
        /// transaction results keyed by wtxid
        #[serde(rename = "tx-results")]
        pub tx_results: std::collections::BTreeMap<String, SubmitpackageResultTxResultsValue>,
        /// List of txids of replaced transactions
        #[serde(rename = "replaced-transactions")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub replaced_transactions: Option<Vec<String>>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TestmempoolacceptResultItemFees {
        /// transaction fee in BTC
        pub base: rust_decimal::Decimal,
        /// the effective feerate in BTC per KvB. May differ from the base feerate if, for example, there are modified fees from prioritisetransaction or a package feerate was used.
        #[serde(rename = "effective-feerate")]
        pub effective_feerate: rust_decimal::Decimal,
        /// transactions whose fees and vsizes are included in effective-feerate.
        #[serde(rename = "effective-includes")]
        pub effective_includes: Vec<String>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct TestmempoolacceptResultItem {
        /// The transaction hash in hex
        pub txid: String,
        /// The transaction witness hash in hex
        pub wtxid: String,
        /// Package validation error, if any (only possible if rawtxs had more than 1 transaction).
        #[serde(rename = "package-error")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub package_error: Option<String>,
        /// Whether this tx would be accepted to the mempool and pass client-specified maxfeerate. If not present, the tx was not fully validated due to a failure in another tx in the list.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allowed: Option<bool>,
        /// Virtual transaction size as defined in BIP 141. This is different from actual serialized size for witness transactions as witness data is discounted (only present when 'allowed' is true)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub vsize: Option<f64>,
        /// Transaction fees (only present if 'allowed' is true)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fees: Option<TestmempoolacceptResultItemFees>,
        /// Rejection reason (only present when 'allowed' is false)
        #[serde(rename = "reject-reason")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub reject_reason: Option<String>,
        /// Rejection details (only present when 'allowed' is false and rejection details exist)
        #[serde(rename = "reject-details")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub reject_details: Option<String>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct UnloadwalletResult {
        /// Warning messages, if any, related to unloading the wallet.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub warnings: Option<Vec<String>>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct ValidateaddressResult {
        /// If the address is valid or not
        pub isvalid: bool,
        /// The bitcoin address validated
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub address: Option<String>,
        /// The hex-encoded output script generated by the address
        #[serde(rename = "scriptPubKey")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub script_pub_key: Option<String>,
        /// If the key is a script
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub isscript: Option<bool>,
        /// If the address is a witness address
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub iswitness: Option<bool>,
        /// The version number of the witness program
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub witness_version: Option<f64>,
        /// The hex value of the witness program
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub witness_program: Option<String>,
        /// Error message, if any
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub error: Option<String>,
        /// Indices of likely error locations in address, if known (e.g. Bech32 errors)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub error_locations: Option<Vec<f64>>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct WaitforblockResult {
        /// The blockhash
        pub hash: String,
        /// Block height
        pub height: f64,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct WaitforblockheightResult {
        /// The blockhash
        pub hash: String,
        /// Block height
        pub height: f64,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct WaitfornewblockResult {
        /// The blockhash
        pub hash: String,
        /// Block height
        pub height: f64,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct WalletcreatefundedpsbtInputsItem {
        /// The transaction id
        pub txid: String,
        /// The output number
        pub vout: f64,
        /// The sequence number
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub sequence: Option<f64>,
        /// The maximum weight for this input, including the weight of the outpoint and sequence number. Note that signature sizes are not guaranteed to be consistent, so the maximum DER signatures size of 73 bytes should be used when considering ECDSA signatures.Remember to convert serialized sizes to weight units when necessary.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub weight: Option<f64>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct WalletcreatefundedpsbtOptionsSolvingData {
        /// Public keys involved in this transaction.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pubkeys: Option<Vec<String>>,
        /// Scripts involved in this transaction.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub scripts: Option<Vec<String>>,
        /// Descriptors that provide solving data for this transaction.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub descriptors: Option<Vec<String>>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct WalletcreatefundedpsbtOptions {
        /// Automatically include coins from the wallet to cover the target amount.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub add_inputs: Option<bool>,
        /// Include inputs that are not safe to spend (unconfirmed transactions from outside keys and unconfirmed replacement transactions).
        /// Warning: the resulting transaction may become invalid if one of the unsafe inputs disappears.
        /// If that happens, you will need to fund the transaction with different inputs and republish it.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub include_unsafe: Option<bool>,
        /// If add_inputs is specified, require inputs with at least this many confirmations.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub minconf: Option<f64>,
        /// If add_inputs is specified, require inputs with at most this many confirmations.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub maxconf: Option<f64>,
        /// The bitcoin address to receive the change
        #[serde(rename = "changeAddress")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub change_address: Option<String>,
        /// The index of the change output
        #[serde(rename = "changePosition")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub change_position: Option<f64>,
        /// The output type to use. Only valid if changeAddress is not specified. Options are "legacy", "p2sh-segwit", "bech32", "bech32m".
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub change_type: Option<String>,
        /// (DEPRECATED) No longer used
        #[serde(rename = "includeWatching")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub include_watching: Option<bool>,
        /// Lock selected unspent outputs
        #[serde(rename = "lockUnspents")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub lock_unspents: Option<bool>,
        /// Specify a fee rate in sat/vB.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fee_rate: Option<rust_decimal::Decimal>,
        /// Specify a fee rate in BTC/kvB.
        #[serde(rename = "feeRate")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fee_rate: Option<rust_decimal::Decimal>,
        /// The outputs to subtract the fee from.
        /// The fee will be equally deducted from the amount of each specified output.
        /// Those recipients will receive less bitcoins than you enter in their corresponding amount field.
        /// If no outputs are specified here, the sender pays the fee.
        #[serde(rename = "subtractFeeFromOutputs")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub subtract_fee_from_outputs: Option<Vec<f64>>,
        /// The maximum acceptable transaction weight.
        /// Transaction building will fail if this can not be satisfied.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub max_tx_weight: Option<f64>,
        /// Confirmation target in blocks
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub conf_target: Option<f64>,
        /// The fee estimate mode, must be one of (case insensitive):
        /// unset, economical, conservative
        /// unset means no mode set (economical mode is used if the transaction is replaceable;
        /// otherwise, conservative mode is used).
        /// economical estimates use a shorter time horizon, making them more
        /// responsive to short-term drops in the prevailing fee market. This mode
        /// potentially returns a lower fee rate estimate.
        /// conservative estimates use a longer time horizon, making them
        /// less responsive to short-term drops in the prevailing fee market. This mode
        /// potentially returns a higher fee rate estimate.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub estimate_mode: Option<String>,
        /// Marks this transaction as BIP125-replaceable.
        /// Allows this transaction to be replaced by a transaction with higher fees
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub replaceable: Option<bool>,
        /// Keys and scripts needed for producing a final transaction with a dummy signature.
        /// Used for fee estimation during coin selection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub solving_data: Option<WalletcreatefundedpsbtOptionsSolvingData>,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct WalletcreatefundedpsbtResult {
        /// The resulting raw transaction (base64-encoded string)
        pub psbt: String,
        /// Fee in BTC the resulting transaction pays
        pub fee: rust_decimal::Decimal,
        /// The position of the added change output, or -1
        pub changepos: f64,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct WalletdisplayaddressResult {
        /// The address as confirmed by the signer
        pub address: String,
    }

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    pub struct WalletprocesspsbtResult {
        /// The base64-encoded partially signed transaction
        pub psbt: String,
        /// If the transaction has a complete set of signatures
        pub complete: bool,
        /// The hex-encoded network transaction if complete
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub hex: Option<String>,
    }

}

use self::types::*;

impl crate::RpcClient {

    /// Mark in-wallet transaction <txid> as abandoned
    pub async fn abandontransaction(&self, txid: String) -> crate::RpcResult<()> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(txid)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("abandontransaction", out).await
    }

    /// Stops current wallet rescan triggered by an RPC call, e.g. by a rescanblockchain call.
    pub async fn abortrescan(&self) -> crate::RpcResult<bool> {
        self.call("abortrescan", Vec::new()).await
    }

    /// Open an outbound connection to a specified node. This RPC is for testing only.
    pub async fn addconnection(&self, address: String, connection_type: String, v2transport: bool) -> crate::RpcResult<AddconnectionResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(address)?);
        params[1] = Some(serde_json::to_value(connection_type)?);
        params[2] = Some(serde_json::to_value(v2transport)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("addconnection", out).await
    }

    /// Attempts to add or remove a node from the addnode list.
    pub async fn addnode(&self, node: String, command: String, v2transport: Option<bool>) -> crate::RpcResult<()> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(node)?);
        params[1] = Some(serde_json::to_value(command)?);
        if let Some(value) = v2transport {
            params[2] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("addnode", out).await
    }

    /// Add the address of a potential peer to an address manager table. This RPC is for testing only.
    pub async fn addpeeraddress(&self, address: String, port: f64, tried: Option<bool>) -> crate::RpcResult<AddpeeraddressResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(address)?);
        params[1] = Some(serde_json::to_value(port)?);
        if let Some(value) = tried {
            params[2] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("addpeeraddress", out).await
    }

    /// Analyzes and provides information about the current status of a PSBT and its inputs
    pub async fn analyzepsbt(&self, psbt: String) -> crate::RpcResult<AnalyzepsbtResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(psbt)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("analyzepsbt", out).await
    }

    /// Return an OpenRPC document describing the RPC API.
    pub async fn api(&self) -> crate::RpcResult<Value> {
        self.call("api", Vec::new()).await
    }

    /// Safely copies the current wallet file to the specified destination, which can either be a directory or a path with a filename.
    pub async fn backupwallet(&self, destination: String) -> crate::RpcResult<()> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(destination)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("backupwallet", out).await
    }

    /// Bumps the fee of a transaction T, replacing it with a new transaction B.
    pub async fn bumpfee(&self, txid: String, options: Option<BumpfeeOptions>) -> crate::RpcResult<BumpfeeResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(txid)?);
        if let Some(value) = options {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("bumpfee", out).await
    }

    /// Clear all banned IPs.
    pub async fn clearbanned(&self) -> crate::RpcResult<()> {
        self.call("clearbanned", Vec::new()).await
    }

    /// Combine multiple partially signed Bitcoin transactions into one transaction.
    pub async fn combinepsbt(&self, txs: Vec<String>) -> crate::RpcResult<String> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(txs)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("combinepsbt", out).await
    }

    /// Combine multiple partially signed transactions into one transaction.
    pub async fn combinerawtransaction(&self, txs: Vec<String>) -> crate::RpcResult<String> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(txs)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("combinerawtransaction", out).await
    }

    /// Converts a network serialized transaction to a PSBT. This should be used only with createrawtransaction and fundrawtransaction
    pub async fn converttopsbt(&self, hexstring: String, permitsigdata: Option<bool>, iswitness: Option<bool>) -> crate::RpcResult<String> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(hexstring)?);
        if let Some(value) = permitsigdata {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = iswitness {
            params[2] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("converttopsbt", out).await
    }

    /// Creates a multi-signature address with n signatures of m keys required.
    pub async fn createmultisig(&self, nrequired: f64, keys: Vec<String>, address_type: Option<String>) -> crate::RpcResult<CreatemultisigResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(nrequired)?);
        params[1] = Some(serde_json::to_value(keys)?);
        if let Some(value) = address_type {
            params[2] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("createmultisig", out).await
    }

    /// Creates a transaction in the Partially Signed Transaction format.
    pub async fn createpsbt(&self, inputs: Vec<CreatepsbtInputsItem>, outputs: Vec<Value>, locktime: Option<f64>, replaceable: Option<bool>, version: Option<f64>) -> crate::RpcResult<String> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 5];
        params[0] = Some(serde_json::to_value(inputs)?);
        params[1] = Some(serde_json::to_value(outputs)?);
        if let Some(value) = locktime {
            params[2] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = replaceable {
            params[3] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = version {
            params[4] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("createpsbt", out).await
    }

    /// Create a transaction spending the given inputs and creating new outputs.
    pub async fn createrawtransaction(&self, inputs: Vec<CreaterawtransactionInputsItem>, outputs: Vec<Value>, locktime: Option<f64>, replaceable: Option<bool>, version: Option<f64>) -> crate::RpcResult<String> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 5];
        params[0] = Some(serde_json::to_value(inputs)?);
        params[1] = Some(serde_json::to_value(outputs)?);
        if let Some(value) = locktime {
            params[2] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = replaceable {
            params[3] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = version {
            params[4] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("createrawtransaction", out).await
    }

    /// Creates and loads a new wallet.
    pub async fn createwallet(&self, wallet_name: String, disable_private_keys: Option<bool>, blank: Option<bool>, passphrase: Option<String>, avoid_reuse: Option<bool>, descriptors: Option<bool>, load_on_startup: Option<bool>, external_signer: Option<bool>) -> crate::RpcResult<CreatewalletResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 8];
        params[0] = Some(serde_json::to_value(wallet_name)?);
        if let Some(value) = disable_private_keys {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = blank {
            params[2] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = passphrase {
            params[3] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = avoid_reuse {
            params[4] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = descriptors {
            params[5] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = load_on_startup {
            params[6] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = external_signer {
            params[7] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("createwallet", out).await
    }

    /// Creates the wallet's descriptor for the given address type. The address type must be one that the wallet does not already have a descriptor for.
    pub async fn createwalletdescriptor(&self, type_: String, options: Option<CreatewalletdescriptorOptions>) -> crate::RpcResult<CreatewalletdescriptorResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(type_)?);
        if let Some(value) = options {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("createwalletdescriptor", out).await
    }

    /// Return a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.
    pub async fn decodepsbt(&self, psbt: String) -> crate::RpcResult<DecodepsbtResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(psbt)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("decodepsbt", out).await
    }

    /// Return a JSON object representing the serialized, hex-encoded transaction.
    pub async fn decoderawtransaction(&self, hexstring: String, iswitness: Option<bool>) -> crate::RpcResult<DecoderawtransactionResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(hexstring)?);
        if let Some(value) = iswitness {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("decoderawtransaction", out).await
    }

    /// Decode a hex-encoded script.
    pub async fn decodescript(&self, hexstring: String) -> crate::RpcResult<DecodescriptResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(hexstring)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("decodescript", out).await
    }

    /// Derives one or more addresses corresponding to an output descriptor.
    pub async fn deriveaddresses(&self, descriptor: String, range: Option<RangeParam>) -> crate::RpcResult<DeriveaddressesResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(descriptor)?);
        if let Some(value) = range {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("deriveaddresses", out).await
    }

    /// Update all segwit inputs in a PSBT with information from output descriptors, the UTXO set or the mempool.
    pub async fn descriptorprocesspsbt(&self, psbt: String, descriptors: Vec<Value>, sighashtype: Option<String>, bip32derivs: Option<bool>, finalize: Option<bool>) -> crate::RpcResult<DescriptorprocesspsbtResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 5];
        params[0] = Some(serde_json::to_value(psbt)?);
        params[1] = Some(serde_json::to_value(descriptors)?);
        if let Some(value) = sighashtype {
            params[2] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = bip32derivs {
            params[3] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = finalize {
            params[4] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("descriptorprocesspsbt", out).await
    }

    /// Immediately disconnects from the specified peer node.
    pub async fn disconnectnode(&self, address: Option<String>, nodeid: Option<f64>) -> crate::RpcResult<()> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        if let Some(value) = address {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = nodeid {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("disconnectnode", out).await
    }

    /// Write the serialized UTXO set to a file. This can be used in loadtxoutset afterwards if this snapshot height is supported in the chainparams as well.
    pub async fn dumptxoutset(&self, path: String, type_: Option<String>, options: Option<DumptxoutsetOptions>) -> crate::RpcResult<DumptxoutsetResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(path)?);
        if let Some(value) = type_ {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = options {
            params[2] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("dumptxoutset", out).await
    }

    /// Simply echo back the input arguments. This command is for testing.
    pub async fn echo(&self, arg0: Option<String>, arg1: Option<String>, arg2: Option<String>, arg3: Option<String>, arg4: Option<String>, arg5: Option<String>, arg6: Option<String>, arg7: Option<String>, arg8: Option<String>, arg9: Option<String>) -> crate::RpcResult<Value> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 10];
        if let Some(value) = arg0 {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = arg1 {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = arg2 {
            params[2] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = arg3 {
            params[3] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = arg4 {
            params[4] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = arg5 {
            params[5] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = arg6 {
            params[6] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = arg7 {
            params[7] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = arg8 {
            params[8] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = arg9 {
            params[9] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("echo", out).await
    }

    /// Echo back the input argument, passing it through a spawned process in a multiprocess build.
    pub async fn echoipc(&self, arg: String) -> crate::RpcResult<String> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(arg)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("echoipc", out).await
    }

    /// Simply echo back the input arguments. This command is for testing.
    pub async fn echojson(&self, arg0: Option<String>, arg1: Option<String>, arg2: Option<String>, arg3: Option<String>, arg4: Option<String>, arg5: Option<String>, arg6: Option<String>, arg7: Option<String>, arg8: Option<String>, arg9: Option<String>) -> crate::RpcResult<Value> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 10];
        if let Some(value) = arg0 {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = arg1 {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = arg2 {
            params[2] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = arg3 {
            params[3] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = arg4 {
            params[4] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = arg5 {
            params[5] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = arg6 {
            params[6] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = arg7 {
            params[7] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = arg8 {
            params[8] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = arg9 {
            params[9] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("echojson", out).await
    }

    /// Encrypts the wallet with 'passphrase'. This is for first time encryption.
    pub async fn encryptwallet(&self, passphrase: String) -> crate::RpcResult<String> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(passphrase)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("encryptwallet", out).await
    }

    /// Returns a list of external signers from -signer.
    pub async fn enumeratesigners(&self) -> crate::RpcResult<EnumeratesignersResult> {
        self.call("enumeratesigners", Vec::new()).await
    }

    /// WARNING: This interface is unstable and may disappear or change!
    pub async fn estimaterawfee(&self, conf_target: f64, threshold: Option<f64>) -> crate::RpcResult<EstimaterawfeeResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(conf_target)?);
        if let Some(value) = threshold {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("estimaterawfee", out).await
    }

    /// Estimates the approximate fee per kilobyte needed for a transaction to begin
    pub async fn estimatesmartfee(&self, conf_target: f64, estimate_mode: Option<String>) -> crate::RpcResult<EstimatesmartfeeResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(conf_target)?);
        if let Some(value) = estimate_mode {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("estimatesmartfee", out).await
    }

    /// Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a
    pub async fn finalizepsbt(&self, psbt: String, extract: Option<bool>) -> crate::RpcResult<FinalizepsbtResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(psbt)?);
        if let Some(value) = extract {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("finalizepsbt", out).await
    }

    /// If the transaction has no inputs, they will be automatically selected to meet its out value.
    pub async fn fundrawtransaction(&self, hexstring: String, options: Option<FundrawtransactionOptions>, iswitness: Option<bool>) -> crate::RpcResult<FundrawtransactionResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(hexstring)?);
        if let Some(value) = options {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = iswitness {
            params[2] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("fundrawtransaction", out).await
    }

    /// has been replaced by the -generate cli option. Refer to -help for more information.
    pub async fn generate(&self) -> crate::RpcResult<Value> {
        self.call("generate", Vec::new()).await
    }

    /// Mine a set of ordered transactions to a specified address or descriptor and return the block hash.
    pub async fn generateblock(&self, output: String, transactions: Vec<String>, submit: Option<bool>) -> crate::RpcResult<GenerateblockResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(output)?);
        params[1] = Some(serde_json::to_value(transactions)?);
        if let Some(value) = submit {
            params[2] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("generateblock", out).await
    }

    /// Mine to a specified address and return the block hashes.
    pub async fn generatetoaddress(&self, nblocks: f64, address: String, maxtries: Option<f64>) -> crate::RpcResult<Vec<String>> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(nblocks)?);
        params[1] = Some(serde_json::to_value(address)?);
        if let Some(value) = maxtries {
            params[2] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("generatetoaddress", out).await
    }

    /// Mine to a specified descriptor and return the block hashes.
    pub async fn generatetodescriptor(&self, num_blocks: f64, descriptor: String, maxtries: Option<f64>) -> crate::RpcResult<Vec<String>> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(num_blocks)?);
        params[1] = Some(serde_json::to_value(descriptor)?);
        if let Some(value) = maxtries {
            params[2] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("generatetodescriptor", out).await
    }

    /// Returns information about the given added node, or all added nodes
    pub async fn getaddednodeinfo(&self, node: Option<String>) -> crate::RpcResult<Vec<GetaddednodeinfoResultItem>> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        if let Some(value) = node {
            params[0] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getaddednodeinfo", out).await
    }

    /// Returns the list of addresses assigned the specified label.
    pub async fn getaddressesbylabel(&self, label: String) -> crate::RpcResult<std::collections::BTreeMap<String, GetaddressesbylabelResultValue>> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(label)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getaddressesbylabel", out).await
    }

    /// Return information about the given bitcoin address.
    pub async fn getaddressinfo(&self, address: String) -> crate::RpcResult<GetaddressinfoResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(address)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getaddressinfo", out).await
    }

    /// Provides information about the node's address manager by returning the number of addresses in the `new` and `tried` tables and their sum for all networks.
    pub async fn getaddrmaninfo(&self) -> crate::RpcResult<std::collections::BTreeMap<String, GetaddrmaninfoResultValue>> {
        self.call("getaddrmaninfo", Vec::new()).await
    }

    /// Returns the total available balance.
    pub async fn getbalance(&self, dummy: Option<String>, minconf: Option<f64>, include_watchonly: Option<bool>, avoid_reuse: Option<bool>) -> crate::RpcResult<rust_decimal::Decimal> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 4];
        if let Some(value) = dummy {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = minconf {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = include_watchonly {
            params[2] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = avoid_reuse {
            params[3] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getbalance", out).await
    }

    /// Returns an object with all balances in BTC.
    pub async fn getbalances(&self) -> crate::RpcResult<GetbalancesResult> {
        self.call("getbalances", Vec::new()).await
    }

    /// Returns the hash of the best (tip) block in the most-work fully-validated chain.
    pub async fn getbestblockhash(&self) -> crate::RpcResult<String> {
        self.call("getbestblockhash", Vec::new()).await
    }

    /// If verbosity is 0, returns a string that is serialized, hex-encoded data for block 'hash'.
    pub async fn getblock(&self, blockhash: String, verbosity: Option<f64>) -> crate::RpcResult<GetblockResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(blockhash)?);
        if let Some(value) = verbosity {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getblock", out).await
    }

    /// Returns an object containing various state info regarding blockchain processing.
    pub async fn getblockchaininfo(&self) -> crate::RpcResult<GetblockchaininfoResult> {
        self.call("getblockchaininfo", Vec::new()).await
    }

    /// Returns the height of the most-work fully-validated chain.
    pub async fn getblockcount(&self) -> crate::RpcResult<f64> {
        self.call("getblockcount", Vec::new()).await
    }

    /// Retrieve a BIP 157 content filter for a particular block.
    pub async fn getblockfilter(&self, blockhash: String, filtertype: Option<String>) -> crate::RpcResult<GetblockfilterResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(blockhash)?);
        if let Some(value) = filtertype {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getblockfilter", out).await
    }

    /// Attempt to fetch block from a given peer.
    pub async fn getblockfrompeer(&self, blockhash: String, peer_id: f64) -> crate::RpcResult<Value> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(blockhash)?);
        params[1] = Some(serde_json::to_value(peer_id)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getblockfrompeer", out).await
    }

    /// Returns hash of block in best-block-chain at height provided.
    pub async fn getblockhash(&self, height: f64) -> crate::RpcResult<String> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(height)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getblockhash", out).await
    }

    /// If verbose is false, returns a string that is serialized, hex-encoded data for blockheader 'hash'.
    pub async fn getblockheader(&self, blockhash: String, verbose: Option<bool>) -> crate::RpcResult<GetblockheaderResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(blockhash)?);
        if let Some(value) = verbose {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getblockheader", out).await
    }

    /// Compute per block statistics for a given window. All amounts are in satoshis.
    pub async fn getblockstats(&self, hash_or_height: f64, stats: Option<Vec<Value>>) -> crate::RpcResult<GetblockstatsResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(hash_or_height)?);
        if let Some(value) = stats {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getblockstats", out).await
    }

    /// If the request parameters include a 'mode' key, that is used to explicitly select between the default 'template' request or a 'proposal'.
    pub async fn getblocktemplate(&self, template_request: GetblocktemplateTemplateRequest) -> crate::RpcResult<GetblocktemplateResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(template_request)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getblocktemplate", out).await
    }

    /// Return information about chainstates.
    pub async fn getchainstates(&self) -> crate::RpcResult<GetchainstatesResult> {
        self.call("getchainstates", Vec::new()).await
    }

    /// Return information about all known tips in the block tree, including the main chain as well as orphaned branches.
    pub async fn getchaintips(&self) -> crate::RpcResult<Vec<GetchaintipsResultItem>> {
        self.call("getchaintips", Vec::new()).await
    }

    /// Compute statistics about the total number and rate of transactions in the chain.
    pub async fn getchaintxstats(&self, nblocks: Option<f64>, blockhash: Option<String>) -> crate::RpcResult<GetchaintxstatsResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        if let Some(value) = nblocks {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = blockhash {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getchaintxstats", out).await
    }

    /// Returns the number of connections to other nodes.
    pub async fn getconnectioncount(&self) -> crate::RpcResult<f64> {
        self.call("getconnectioncount", Vec::new()).await
    }

    /// Returns an object containing various state info regarding deployments of consensus changes.
    pub async fn getdeploymentinfo(&self, blockhash: Option<String>) -> crate::RpcResult<GetdeploymentinfoResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        if let Some(value) = blockhash {
            params[0] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getdeploymentinfo", out).await
    }

    /// Get spend and receive activity associated with a set of descriptors for a set of blocks. This command pairs well with the `relevant_blocks` output of `scanblocks()`.
    pub async fn getdescriptoractivity(&self, blockhashes: Vec<String>, scanobjects: Vec<Value>, include_mempool: Option<bool>) -> crate::RpcResult<GetdescriptoractivityResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(blockhashes)?);
        params[1] = Some(serde_json::to_value(scanobjects)?);
        if let Some(value) = include_mempool {
            params[2] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getdescriptoractivity", out).await
    }

    /// Analyses a descriptor.
    pub async fn getdescriptorinfo(&self, descriptor: String) -> crate::RpcResult<GetdescriptorinfoResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(descriptor)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getdescriptorinfo", out).await
    }

    /// Returns the proof-of-work difficulty as a multiple of the minimum difficulty.
    pub async fn getdifficulty(&self) -> crate::RpcResult<f64> {
        self.call("getdifficulty", Vec::new()).await
    }

    /// List all BIP 32 HD keys in the wallet and which descriptors use them.
    pub async fn gethdkeys(&self, options: Option<GethdkeysOptions>) -> crate::RpcResult<Vec<GethdkeysResultItem>> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        if let Some(value) = options {
            params[0] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("gethdkeys", out).await
    }

    /// Returns the status of one or all available indices currently running in the node.
    pub async fn getindexinfo(&self, index_name: Option<String>) -> crate::RpcResult<std::collections::BTreeMap<String, GetindexinfoResultValue>> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        if let Some(value) = index_name {
            params[0] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getindexinfo", out).await
    }

    /// Returns an object containing information about memory usage.
    pub async fn getmemoryinfo(&self, mode: Option<String>) -> crate::RpcResult<GetmemoryinfoResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        if let Some(value) = mode {
            params[0] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getmemoryinfo", out).await
    }

    /// If txid is in the mempool, returns all in-mempool ancestors.
    pub async fn getmempoolancestors(&self, txid: String, verbose: Option<bool>) -> crate::RpcResult<GetmempoolancestorsResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(txid)?);
        if let Some(value) = verbose {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getmempoolancestors", out).await
    }

    /// If txid is in the mempool, returns all in-mempool descendants.
    pub async fn getmempooldescendants(&self, txid: String, verbose: Option<bool>) -> crate::RpcResult<GetmempooldescendantsResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(txid)?);
        if let Some(value) = verbose {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getmempooldescendants", out).await
    }

    /// Returns mempool data for given transaction
    pub async fn getmempoolentry(&self, txid: String) -> crate::RpcResult<GetmempoolentryResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(txid)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getmempoolentry", out).await
    }

    /// Returns details on the active state of the TX memory pool.
    pub async fn getmempoolinfo(&self) -> crate::RpcResult<GetmempoolinfoResult> {
        self.call("getmempoolinfo", Vec::new()).await
    }

    /// Returns a json object containing mining-related information.
    pub async fn getmininginfo(&self) -> crate::RpcResult<GetmininginfoResult> {
        self.call("getmininginfo", Vec::new()).await
    }

    /// Returns information about network traffic, including bytes in, bytes out,
    pub async fn getnettotals(&self) -> crate::RpcResult<GetnettotalsResult> {
        self.call("getnettotals", Vec::new()).await
    }

    /// Returns the estimated network hashes per second based on the last n blocks.
    pub async fn getnetworkhashps(&self, nblocks: Option<f64>, height: Option<f64>) -> crate::RpcResult<f64> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        if let Some(value) = nblocks {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = height {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getnetworkhashps", out).await
    }

    /// Returns an object containing various state info regarding P2P networking.
    pub async fn getnetworkinfo(&self) -> crate::RpcResult<GetnetworkinfoResult> {
        self.call("getnetworkinfo", Vec::new()).await
    }

    /// Returns a new Bitcoin address for receiving payments.
    pub async fn getnewaddress(&self, label: Option<String>, address_type: Option<String>) -> crate::RpcResult<String> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        if let Some(value) = label {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = address_type {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getnewaddress", out).await
    }

    /// Return known addresses, after filtering for quality and recency.
    pub async fn getnodeaddresses(&self, count: Option<f64>, network: Option<String>) -> crate::RpcResult<Vec<GetnodeaddressesResultItem>> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        if let Some(value) = count {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = network {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getnodeaddresses", out).await
    }

    /// Shows transactions in the tx orphanage.
    pub async fn getorphantxs(&self, verbosity: Option<f64>) -> crate::RpcResult<GetorphantxsResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        if let Some(value) = verbosity {
            params[0] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getorphantxs", out).await
    }

    /// Returns data about each connected network peer as a json array of objects.
    pub async fn getpeerinfo(&self) -> crate::RpcResult<Vec<GetpeerinfoResultItem>> {
        self.call("getpeerinfo", Vec::new()).await
    }

    /// Returns a map of all user-created (see prioritisetransaction) fee deltas by txid, and whether the tx is present in mempool.
    pub async fn getprioritisedtransactions(&self) -> crate::RpcResult<std::collections::BTreeMap<String, GetprioritisedtransactionsResultValue>> {
        self.call("getprioritisedtransactions", Vec::new()).await
    }

    /// EXPERIMENTAL warning: this call may be changed in future releases.
    pub async fn getrawaddrman(&self) -> crate::RpcResult<std::collections::BTreeMap<String, std::collections::BTreeMap<String, GetrawaddrmanResultValueValue>>> {
        self.call("getrawaddrman", Vec::new()).await
    }

    /// Returns a new Bitcoin address, for receiving change.
    pub async fn getrawchangeaddress(&self, address_type: Option<String>) -> crate::RpcResult<String> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        if let Some(value) = address_type {
            params[0] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getrawchangeaddress", out).await
    }

    /// Returns all transaction ids in memory pool as a json array of string transaction ids.
    pub async fn getrawmempool(&self, verbose: Option<bool>, mempool_sequence: Option<bool>) -> crate::RpcResult<GetrawmempoolResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        if let Some(value) = verbose {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = mempool_sequence {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getrawmempool", out).await
    }

    /// By default, this call only returns a transaction if it is in the mempool. If -txindex is enabled
    pub async fn getrawtransaction(&self, txid: String, verbosity: Option<f64>, blockhash: Option<String>) -> crate::RpcResult<GetrawtransactionResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(txid)?);
        if let Some(value) = verbosity {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = blockhash {
            params[2] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getrawtransaction", out).await
    }

    /// Returns the total amount received by the given address in transactions with at least minconf confirmations.
    pub async fn getreceivedbyaddress(&self, address: String, minconf: Option<f64>, include_immature_coinbase: Option<bool>) -> crate::RpcResult<rust_decimal::Decimal> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(address)?);
        if let Some(value) = minconf {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = include_immature_coinbase {
            params[2] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getreceivedbyaddress", out).await
    }

    /// Returns the total amount received by addresses with <label> in transactions with at least [minconf] confirmations.
    pub async fn getreceivedbylabel(&self, label: String, minconf: Option<f64>, include_immature_coinbase: Option<bool>) -> crate::RpcResult<rust_decimal::Decimal> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(label)?);
        if let Some(value) = minconf {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = include_immature_coinbase {
            params[2] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getreceivedbylabel", out).await
    }

    /// Returns details of the RPC server.
    pub async fn getrpcinfo(&self) -> crate::RpcResult<GetrpcinfoResult> {
        self.call("getrpcinfo", Vec::new()).await
    }

    /// Get detailed information about in-wallet transaction <txid>
    pub async fn gettransaction(&self, txid: String, include_watchonly: Option<bool>, verbose: Option<bool>) -> crate::RpcResult<GettransactionResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(txid)?);
        if let Some(value) = include_watchonly {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = verbose {
            params[2] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("gettransaction", out).await
    }

    /// Returns details about an unspent transaction output.
    pub async fn gettxout(&self, txid: String, n: f64, include_mempool: Option<bool>) -> crate::RpcResult<Option<GettxoutResult>> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(txid)?);
        params[1] = Some(serde_json::to_value(n)?);
        if let Some(value) = include_mempool {
            params[2] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("gettxout", out).await
    }

    /// Returns a hex-encoded proof that "txid" was included in a block.
    pub async fn gettxoutproof(&self, txids: Vec<String>, blockhash: Option<String>) -> crate::RpcResult<String> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(txids)?);
        if let Some(value) = blockhash {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("gettxoutproof", out).await
    }

    /// Returns statistics about the unspent transaction output set.
    pub async fn gettxoutsetinfo(&self, hash_type: Option<String>, hash_or_height: Option<f64>, use_index: Option<bool>) -> crate::RpcResult<GettxoutsetinfoResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        if let Some(value) = hash_type {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = hash_or_height {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = use_index {
            params[2] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("gettxoutsetinfo", out).await
    }

    /// Scans the mempool to find transactions spending any of the given outputs
    pub async fn gettxspendingprevout(&self, outputs: Vec<GettxspendingprevoutOutputsItem>) -> crate::RpcResult<Vec<GettxspendingprevoutResultItem>> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(outputs)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("gettxspendingprevout", out).await
    }

    /// Returns an object containing various wallet state info.
    pub async fn getwalletinfo(&self) -> crate::RpcResult<GetwalletinfoResult> {
        self.call("getwalletinfo", Vec::new()).await
    }

    /// List all commands, or get help for a specified command.
    pub async fn help(&self, command: Option<String>) -> crate::RpcResult<String> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        if let Some(value) = command {
            params[0] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("help", out).await
    }

    /// Import descriptors. This will trigger a rescan of the blockchain based on the earliest timestamp of all descriptors being imported. Requires a new wallet backup.
    pub async fn importdescriptors(&self, requests: Vec<ImportdescriptorsRequestsItem>) -> crate::RpcResult<Vec<ImportdescriptorsResultItem>> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(requests)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("importdescriptors", out).await
    }

    /// Import a mempool.dat file and attempt to add its contents to the mempool.
    pub async fn importmempool(&self, filepath: String, options: Option<ImportmempoolOptions>) -> crate::RpcResult<Value> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(filepath)?);
        if let Some(value) = options {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("importmempool", out).await
    }

    /// Imports funds without rescan. Corresponding address or script must previously be included in wallet. Aimed towards pruned wallets. The end-user is responsible to import additional transactions that subsequently spend the imported outputs or rescan after the point in the blockchain the transaction is included.
    pub async fn importprunedfunds(&self, rawtransaction: String, txoutproof: String) -> crate::RpcResult<()> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(rawtransaction)?);
        params[1] = Some(serde_json::to_value(txoutproof)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("importprunedfunds", out).await
    }

    /// Permanently marks a block as invalid, as if it violated a consensus rule.
    pub async fn invalidateblock(&self, blockhash: String) -> crate::RpcResult<()> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(blockhash)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("invalidateblock", out).await
    }

    /// Joins multiple distinct PSBTs with different inputs and outputs into one PSBT with inputs and outputs from all of the PSBTs
    pub async fn joinpsbts(&self, txs: Vec<String>) -> crate::RpcResult<String> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(txs)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("joinpsbts", out).await
    }

    /// Refills each descriptor keypool in the wallet up to the specified number of new keys.
    pub async fn keypoolrefill(&self, newsize: Option<f64>) -> crate::RpcResult<()> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        if let Some(value) = newsize {
            params[0] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("keypoolrefill", out).await
    }

    /// Lists groups of addresses which have had their common ownership
    pub async fn listaddressgroupings(&self) -> crate::RpcResult<Vec<Vec<Vec<Value>>>> {
        self.call("listaddressgroupings", Vec::new()).await
    }

    /// List all manually banned IPs/Subnets.
    pub async fn listbanned(&self) -> crate::RpcResult<Vec<ListbannedResultItem>> {
        self.call("listbanned", Vec::new()).await
    }

    /// List all descriptors present in a wallet.
    pub async fn listdescriptors(&self, private: Option<bool>) -> crate::RpcResult<ListdescriptorsResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        if let Some(value) = private {
            params[0] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("listdescriptors", out).await
    }

    /// Returns the list of all labels, or labels that are assigned to addresses with a specific purpose.
    pub async fn listlabels(&self, purpose: Option<String>) -> crate::RpcResult<Vec<String>> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        if let Some(value) = purpose {
            params[0] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("listlabels", out).await
    }

    /// Returns list of temporarily unspendable outputs.
    pub async fn listlockunspent(&self) -> crate::RpcResult<Vec<ListlockunspentResultItem>> {
        self.call("listlockunspent", Vec::new()).await
    }

    /// List balances by receiving address.
    pub async fn listreceivedbyaddress(&self, minconf: Option<f64>, include_empty: Option<bool>, include_watchonly: Option<bool>, address_filter: Option<String>, include_immature_coinbase: Option<bool>) -> crate::RpcResult<Vec<ListreceivedbyaddressResultItem>> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 5];
        if let Some(value) = minconf {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = include_empty {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = include_watchonly {
            params[2] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = address_filter {
            params[3] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = include_immature_coinbase {
            params[4] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("listreceivedbyaddress", out).await
    }

    /// List received transactions by label.
    pub async fn listreceivedbylabel(&self, minconf: Option<f64>, include_empty: Option<bool>, include_watchonly: Option<bool>, include_immature_coinbase: Option<bool>) -> crate::RpcResult<Vec<ListreceivedbylabelResultItem>> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 4];
        if let Some(value) = minconf {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = include_empty {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = include_watchonly {
            params[2] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = include_immature_coinbase {
            params[3] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("listreceivedbylabel", out).await
    }

    /// Get all transactions in blocks since block [blockhash], or all transactions if omitted.
    pub async fn listsinceblock(&self, blockhash: Option<String>, target_confirmations: Option<f64>, include_watchonly: Option<bool>, include_removed: Option<bool>, include_change: Option<bool>, label: Option<String>) -> crate::RpcResult<ListsinceblockResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 6];
        if let Some(value) = blockhash {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = target_confirmations {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = include_watchonly {
            params[2] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = include_removed {
            params[3] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = include_change {
            params[4] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = label {
            params[5] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("listsinceblock", out).await
    }

    /// If a label name is provided, this will return only incoming transactions paying to addresses with the specified label.
    pub async fn listtransactions(&self, label: Option<String>, count: Option<f64>, skip: Option<f64>, include_watchonly: Option<bool>) -> crate::RpcResult<Vec<ListtransactionsResultItem>> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 4];
        if let Some(value) = label {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = count {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = skip {
            params[2] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = include_watchonly {
            params[3] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("listtransactions", out).await
    }

    /// Returns array of unspent transaction outputs
    pub async fn listunspent(&self, minconf: Option<f64>, maxconf: Option<f64>, addresses: Option<Vec<String>>, include_unsafe: Option<bool>, query_options: Option<ListunspentQueryOptions>) -> crate::RpcResult<Vec<ListunspentResultItem>> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 5];
        if let Some(value) = minconf {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = maxconf {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = addresses {
            params[2] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = include_unsafe {
            params[3] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = query_options {
            params[4] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("listunspent", out).await
    }

    /// Returns a list of wallets in the wallet directory.
    pub async fn listwalletdir(&self) -> crate::RpcResult<ListwalletdirResult> {
        self.call("listwalletdir", Vec::new()).await
    }

    /// Returns a list of currently loaded wallets.
    pub async fn listwallets(&self) -> crate::RpcResult<Vec<String>> {
        self.call("listwallets", Vec::new()).await
    }

    /// Load the serialized UTXO set from a file.
    pub async fn loadtxoutset(&self, path: String) -> crate::RpcResult<LoadtxoutsetResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(path)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("loadtxoutset", out).await
    }

    /// Loads a wallet from a wallet file or directory.
    pub async fn loadwallet(&self, filename: String, load_on_startup: Option<bool>) -> crate::RpcResult<LoadwalletResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(filename)?);
        if let Some(value) = load_on_startup {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("loadwallet", out).await
    }

    /// Updates list of temporarily unspendable outputs.
    pub async fn lockunspent(&self, unlock: bool, transactions: Option<Vec<LockunspentTransactionsItem>>, persistent: Option<bool>) -> crate::RpcResult<bool> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(unlock)?);
        if let Some(value) = transactions {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = persistent {
            params[2] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("lockunspent", out).await
    }

    /// Gets and sets the logging configuration.
    pub async fn logging(&self, include: Option<Vec<String>>, exclude: Option<Vec<String>>) -> crate::RpcResult<std::collections::BTreeMap<String, bool>> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        if let Some(value) = include {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = exclude {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("logging", out).await
    }

    /// Migrate the wallet to a descriptor wallet.
    pub async fn migratewallet(&self, wallet_name: Option<String>, passphrase: Option<String>) -> crate::RpcResult<MigratewalletResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        if let Some(value) = wallet_name {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = passphrase {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("migratewallet", out).await
    }

    /// Bump the scheduler into the future (-regtest only)
    pub async fn mockscheduler(&self, delta_time: f64) -> crate::RpcResult<()> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(delta_time)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("mockscheduler", out).await
    }

    /// Requests that a ping be sent to all other nodes, to measure ping time.
    pub async fn ping(&self) -> crate::RpcResult<()> {
        self.call("ping", Vec::new()).await
    }

    /// Treats a block as if it were received before others with the same work.
    pub async fn preciousblock(&self, blockhash: String) -> crate::RpcResult<()> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(blockhash)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("preciousblock", out).await
    }

    /// Accepts the transaction into mined blocks at a higher (or lower) priority
    pub async fn prioritisetransaction(&self, txid: String, dummy: Option<f64>, fee_delta: f64) -> crate::RpcResult<bool> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(txid)?);
        if let Some(value) = dummy {
            params[1] = Some(serde_json::to_value(value)?);
        }
        params[2] = Some(serde_json::to_value(fee_delta)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("prioritisetransaction", out).await
    }

    /// Attempts to delete block and undo data up to a specified height or timestamp, if eligible for pruning.
    pub async fn pruneblockchain(&self, height: f64) -> crate::RpcResult<f64> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(height)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("pruneblockchain", out).await
    }

    /// Bumps the fee of a transaction T, replacing it with a new transaction B.
    pub async fn psbtbumpfee(&self, txid: String, options: Option<PsbtbumpfeeOptions>) -> crate::RpcResult<PsbtbumpfeeResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(txid)?);
        if let Some(value) = options {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("psbtbumpfee", out).await
    }

    /// Removes invalidity status of a block, its ancestors and its descendants, reconsider them for activation.
    pub async fn reconsiderblock(&self, blockhash: String) -> crate::RpcResult<()> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(blockhash)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("reconsiderblock", out).await
    }

    /// Deletes the specified transaction from the wallet. Meant for use with pruned wallets and as a companion to importprunedfunds. This will affect wallet balances.
    pub async fn removeprunedfunds(&self, txid: String) -> crate::RpcResult<()> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(txid)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("removeprunedfunds", out).await
    }

    /// Rescan the local blockchain for wallet related transactions.
    pub async fn rescanblockchain(&self, start_height: Option<f64>, stop_height: Option<f64>) -> crate::RpcResult<RescanblockchainResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        if let Some(value) = start_height {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = stop_height {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("rescanblockchain", out).await
    }

    /// Restores and loads a wallet from backup.
    pub async fn restorewallet(&self, wallet_name: String, backup_file: String, load_on_startup: Option<bool>) -> crate::RpcResult<RestorewalletResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(wallet_name)?);
        params[1] = Some(serde_json::to_value(backup_file)?);
        if let Some(value) = load_on_startup {
            params[2] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("restorewallet", out).await
    }

    /// Dumps the mempool to disk. It will fail until the previous dump is fully loaded.
    pub async fn savemempool(&self) -> crate::RpcResult<SavemempoolResult> {
        self.call("savemempool", Vec::new()).await
    }

    /// Return relevant blockhashes for given descriptors (requires blockfilterindex).
    pub async fn scanblocks(&self, action: String, scanobjects: Option<Vec<Value>>, start_height: Option<f64>, stop_height: Option<f64>, filtertype: Option<String>, options: Option<ScanblocksOptions>) -> crate::RpcResult<ScanblocksResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 6];
        params[0] = Some(serde_json::to_value(action)?);
        if let Some(value) = scanobjects {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = start_height {
            params[2] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = stop_height {
            params[3] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = filtertype {
            params[4] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = options {
            params[5] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("scanblocks", out).await
    }

    /// Scans the unspent transaction output set for entries that match certain output descriptors.
    pub async fn scantxoutset(&self, action: String, scanobjects: Option<Vec<Value>>) -> crate::RpcResult<ScantxoutsetResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(action)?);
        if let Some(value) = scanobjects {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("scantxoutset", out).await
    }

    /// EXPERIMENTAL warning: this call may be changed in future releases.
    pub async fn send(&self, outputs: Vec<Value>, conf_target: Option<f64>, estimate_mode: Option<String>, fee_rate: Option<rust_decimal::Decimal>, options: Option<SendOptions>, version: Option<f64>) -> crate::RpcResult<SendResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 6];
        params[0] = Some(serde_json::to_value(outputs)?);
        if let Some(value) = conf_target {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = estimate_mode {
            params[2] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = fee_rate {
            params[3] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = options {
            params[4] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = version {
            params[5] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("send", out).await
    }

    /// EXPERIMENTAL warning: this call may be changed in future releases.
    pub async fn sendall(&self, recipients: Vec<Value>, conf_target: Option<f64>, estimate_mode: Option<String>, fee_rate: Option<rust_decimal::Decimal>, options: Option<SendallOptions>) -> crate::RpcResult<SendallResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 5];
        params[0] = Some(serde_json::to_value(recipients)?);
        if let Some(value) = conf_target {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = estimate_mode {
            params[2] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = fee_rate {
            params[3] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = options {
            params[4] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("sendall", out).await
    }

    /// Send multiple times. Amounts are double-precision floating point numbers.
    pub async fn sendmany(&self, dummy: Option<String>, amounts: std::collections::BTreeMap<String, rust_decimal::Decimal>, minconf: Option<f64>, comment: Option<String>, subtractfeefrom: Option<Vec<String>>, replaceable: Option<bool>, conf_target: Option<f64>, estimate_mode: Option<String>, fee_rate: Option<rust_decimal::Decimal>, verbose: Option<bool>) -> crate::RpcResult<SendmanyResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 10];
        if let Some(value) = dummy {
            params[0] = Some(serde_json::to_value(value)?);
        }
        params[1] = Some(serde_json::to_value(amounts)?);
        if let Some(value) = minconf {
            params[2] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = comment {
            params[3] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = subtractfeefrom {
            params[4] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = replaceable {
            params[5] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = conf_target {
            params[6] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = estimate_mode {
            params[7] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = fee_rate {
            params[8] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = verbose {
            params[9] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("sendmany", out).await
    }

    /// Send a p2p message to a peer specified by id.
    pub async fn sendmsgtopeer(&self, peer_id: f64, msg_type: String, msg: String) -> crate::RpcResult<Value> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(peer_id)?);
        params[1] = Some(serde_json::to_value(msg_type)?);
        params[2] = Some(serde_json::to_value(msg)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("sendmsgtopeer", out).await
    }

    /// Submit a raw transaction (serialized, hex-encoded) to local node and network.
    pub async fn sendrawtransaction(&self, hexstring: String, maxfeerate: Option<rust_decimal::Decimal>, maxburnamount: Option<rust_decimal::Decimal>) -> crate::RpcResult<String> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(hexstring)?);
        if let Some(value) = maxfeerate {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = maxburnamount {
            params[2] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("sendrawtransaction", out).await
    }

    /// Send an amount to a given address.
    pub async fn sendtoaddress(&self, address: String, amount: rust_decimal::Decimal, comment: Option<String>, comment_to: Option<String>, subtractfeefromamount: Option<bool>, replaceable: Option<bool>, conf_target: Option<f64>, estimate_mode: Option<String>, avoid_reuse: Option<bool>, fee_rate: Option<rust_decimal::Decimal>, verbose: Option<bool>) -> crate::RpcResult<SendtoaddressResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 11];
        params[0] = Some(serde_json::to_value(address)?);
        params[1] = Some(serde_json::to_value(amount)?);
        if let Some(value) = comment {
            params[2] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = comment_to {
            params[3] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = subtractfeefromamount {
            params[4] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = replaceable {
            params[5] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = conf_target {
            params[6] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = estimate_mode {
            params[7] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = avoid_reuse {
            params[8] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = fee_rate {
            params[9] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = verbose {
            params[10] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("sendtoaddress", out).await
    }

    /// Attempts to add or remove an IP/Subnet from the banned list.
    pub async fn setban(&self, subnet: String, command: String, bantime: Option<f64>, absolute: Option<bool>) -> crate::RpcResult<()> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 4];
        params[0] = Some(serde_json::to_value(subnet)?);
        params[1] = Some(serde_json::to_value(command)?);
        if let Some(value) = bantime {
            params[2] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = absolute {
            params[3] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("setban", out).await
    }

    /// Sets the label associated with the given address.
    pub async fn setlabel(&self, address: String, label: String) -> crate::RpcResult<()> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(address)?);
        params[1] = Some(serde_json::to_value(label)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("setlabel", out).await
    }

    /// Set the local time to given timestamp (-regtest only)
    pub async fn setmocktime(&self, timestamp: f64) -> crate::RpcResult<()> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(timestamp)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("setmocktime", out).await
    }

    /// Disable/enable all p2p network activity.
    pub async fn setnetworkactive(&self, state: bool) -> crate::RpcResult<bool> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(state)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("setnetworkactive", out).await
    }

    /// (DEPRECATED) Set the transaction fee rate in BTC/kvB for this wallet. Overrides the global -paytxfee command line parameter.
    pub async fn settxfee(&self, amount: rust_decimal::Decimal) -> crate::RpcResult<bool> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(amount)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("settxfee", out).await
    }

    /// Change the state of the given wallet flag for a wallet.
    pub async fn setwalletflag(&self, flag: String, value: Option<bool>) -> crate::RpcResult<SetwalletflagResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(flag)?);
        if let Some(value) = value {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("setwalletflag", out).await
    }

    /// Sign a message with the private key of an address
    pub async fn signmessage(&self, address: String, message: String) -> crate::RpcResult<String> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(address)?);
        params[1] = Some(serde_json::to_value(message)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("signmessage", out).await
    }

    /// Sign a message with the private key of an address
    pub async fn signmessagewithprivkey(&self, privkey: String, message: String) -> crate::RpcResult<String> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(privkey)?);
        params[1] = Some(serde_json::to_value(message)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("signmessagewithprivkey", out).await
    }

    /// Sign inputs for raw transaction (serialized, hex-encoded).
    pub async fn signrawtransactionwithkey(&self, hexstring: String, privkeys: Vec<String>, prevtxs: Option<Vec<SignrawtransactionwithkeyPrevtxsItem>>, sighashtype: Option<String>) -> crate::RpcResult<SignrawtransactionwithkeyResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 4];
        params[0] = Some(serde_json::to_value(hexstring)?);
        params[1] = Some(serde_json::to_value(privkeys)?);
        if let Some(value) = prevtxs {
            params[2] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = sighashtype {
            params[3] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("signrawtransactionwithkey", out).await
    }

    /// Sign inputs for raw transaction (serialized, hex-encoded).
    pub async fn signrawtransactionwithwallet(&self, hexstring: String, prevtxs: Option<Vec<SignrawtransactionwithwalletPrevtxsItem>>, sighashtype: Option<String>) -> crate::RpcResult<SignrawtransactionwithwalletResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(hexstring)?);
        if let Some(value) = prevtxs {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = sighashtype {
            params[2] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("signrawtransactionwithwallet", out).await
    }

    /// Calculate the balance change resulting in the signing and broadcasting of the given transaction(s).
    pub async fn simulaterawtransaction(&self, rawtxs: Option<Vec<String>>, options: Option<SimulaterawtransactionOptions>) -> crate::RpcResult<SimulaterawtransactionResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        if let Some(value) = rawtxs {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = options {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("simulaterawtransaction", out).await
    }

    /// Request a graceful shutdown of Bitcoin Core.
    pub async fn stop(&self, wait: Option<f64>) -> crate::RpcResult<String> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        if let Some(value) = wait {
            params[0] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("stop", out).await
    }

    /// Attempts to submit new block to network.
    pub async fn submitblock(&self, hexdata: String, dummy: Option<String>) -> crate::RpcResult<Option<String>> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(hexdata)?);
        if let Some(value) = dummy {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("submitblock", out).await
    }

    /// Decode the given hexdata as a header and submit it as a candidate chain tip if valid.
    pub async fn submitheader(&self, hexdata: String) -> crate::RpcResult<()> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(hexdata)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("submitheader", out).await
    }

    /// Submit a package of raw transactions (serialized, hex-encoded) to local node.
    pub async fn submitpackage(&self, package: Vec<String>, maxfeerate: Option<rust_decimal::Decimal>, maxburnamount: Option<rust_decimal::Decimal>) -> crate::RpcResult<SubmitpackageResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(package)?);
        if let Some(value) = maxfeerate {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = maxburnamount {
            params[2] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("submitpackage", out).await
    }

    /// Waits for the validation interface queue to catch up on everything that was there when we entered this function.
    pub async fn syncwithvalidationinterfacequeue(&self) -> crate::RpcResult<()> {
        self.call("syncwithvalidationinterfacequeue", Vec::new()).await
    }

    /// Returns result of mempool acceptance tests indicating if raw transaction(s) (serialized, hex-encoded) would be accepted by mempool.
    pub async fn testmempoolaccept(&self, rawtxs: Vec<String>, maxfeerate: Option<rust_decimal::Decimal>) -> crate::RpcResult<Vec<TestmempoolacceptResultItem>> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(rawtxs)?);
        if let Some(value) = maxfeerate {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("testmempoolaccept", out).await
    }

    /// Unloads the wallet referenced by the request endpoint or the wallet_name argument.
    pub async fn unloadwallet(&self, wallet_name: Option<String>, load_on_startup: Option<bool>) -> crate::RpcResult<UnloadwalletResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        if let Some(value) = wallet_name {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = load_on_startup {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("unloadwallet", out).await
    }

    /// Returns the total uptime of the server.
    pub async fn uptime(&self) -> crate::RpcResult<f64> {
        self.call("uptime", Vec::new()).await
    }

    /// Updates all segwit inputs and outputs in a PSBT with data from output descriptors, the UTXO set, txindex, or the mempool.
    pub async fn utxoupdatepsbt(&self, psbt: String, descriptors: Option<Vec<Value>>) -> crate::RpcResult<String> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(psbt)?);
        if let Some(value) = descriptors {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("utxoupdatepsbt", out).await
    }

    /// Return information about the given bitcoin address.
    pub async fn validateaddress(&self, address: String) -> crate::RpcResult<ValidateaddressResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(address)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("validateaddress", out).await
    }

    /// Verifies blockchain database.
    pub async fn verifychain(&self, checklevel: Option<f64>, nblocks: Option<f64>) -> crate::RpcResult<bool> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        if let Some(value) = checklevel {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = nblocks {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("verifychain", out).await
    }

    /// Verify a signed message.
    pub async fn verifymessage(&self, address: String, signature: String, message: String) -> crate::RpcResult<bool> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(address)?);
        params[1] = Some(serde_json::to_value(signature)?);
        params[2] = Some(serde_json::to_value(message)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("verifymessage", out).await
    }

    /// Verifies that a proof points to a transaction in a block, returning the transaction it commits to
    pub async fn verifytxoutproof(&self, proof: String) -> crate::RpcResult<Vec<String>> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(proof)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("verifytxoutproof", out).await
    }

    /// Waits for a specific new block and returns useful info about it.
    pub async fn waitforblock(&self, blockhash: String, timeout: Option<f64>) -> crate::RpcResult<WaitforblockResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(blockhash)?);
        if let Some(value) = timeout {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("waitforblock", out).await
    }

    /// Waits for (at least) block height and returns the height and hash
    pub async fn waitforblockheight(&self, height: f64, timeout: Option<f64>) -> crate::RpcResult<WaitforblockheightResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(height)?);
        if let Some(value) = timeout {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("waitforblockheight", out).await
    }

    /// Waits for any new block and returns useful info about it.
    pub async fn waitfornewblock(&self, timeout: Option<f64>, current_tip: Option<String>) -> crate::RpcResult<WaitfornewblockResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        if let Some(value) = timeout {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = current_tip {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("waitfornewblock", out).await
    }

    /// Creates and funds a transaction in the Partially Signed Transaction format.
    pub async fn walletcreatefundedpsbt(&self, inputs: Option<Vec<WalletcreatefundedpsbtInputsItem>>, outputs: Vec<Value>, locktime: Option<f64>, options: Option<WalletcreatefundedpsbtOptions>, bip32derivs: Option<bool>, version: Option<f64>) -> crate::RpcResult<WalletcreatefundedpsbtResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 6];
        if let Some(value) = inputs {
            params[0] = Some(serde_json::to_value(value)?);
        }
        params[1] = Some(serde_json::to_value(outputs)?);
        if let Some(value) = locktime {
            params[2] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = options {
            params[3] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = bip32derivs {
            params[4] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = version {
            params[5] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("walletcreatefundedpsbt", out).await
    }

    /// Display address on an external signer for verification.
    pub async fn walletdisplayaddress(&self, address: String) -> crate::RpcResult<WalletdisplayaddressResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(address)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("walletdisplayaddress", out).await
    }

    /// Removes the wallet encryption key from memory, locking the wallet.
    pub async fn walletlock(&self) -> crate::RpcResult<()> {
        self.call("walletlock", Vec::new()).await
    }

    /// Stores the wallet decryption key in memory for 'timeout' seconds.
    pub async fn walletpassphrase(&self, passphrase: String, timeout: f64) -> crate::RpcResult<()> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(passphrase)?);
        params[1] = Some(serde_json::to_value(timeout)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("walletpassphrase", out).await
    }

    /// Changes the wallet passphrase from 'oldpassphrase' to 'newpassphrase'.
    pub async fn walletpassphrasechange(&self, oldpassphrase: String, newpassphrase: String) -> crate::RpcResult<()> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(oldpassphrase)?);
        params[1] = Some(serde_json::to_value(newpassphrase)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("walletpassphrasechange", out).await
    }

    /// Update a PSBT with input information from our wallet and then sign inputs
    pub async fn walletprocesspsbt(&self, psbt: String, sign: Option<bool>, sighashtype: Option<String>, bip32derivs: Option<bool>, finalize: Option<bool>) -> crate::RpcResult<WalletprocesspsbtResult> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 5];
        params[0] = Some(serde_json::to_value(psbt)?);
        if let Some(value) = sign {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = sighashtype {
            params[2] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = bip32derivs {
            params[3] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = finalize {
            params[4] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("walletprocesspsbt", out).await
    }
}
