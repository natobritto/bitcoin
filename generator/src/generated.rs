// This file is @generated by generator/rust-component.js. Do not edit by hand.

pub mod types {
    use serde::{Deserialize, Serialize};
    use std::collections::BTreeMap;
    pub use serde_json::Value;

    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    #[serde(untagged)]
    pub enum RangeParam {
        Single(u64),
        Range([u64; 2]),
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct AddConnection {
        /// Address of newly added connection.
        pub address: String,
        /// Type of connection opened.
        pub connection_type: String,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct AddPeerAddress {
        /// whether the peer address was successfully added to the address manager table
        pub success: bool,
        /// error description, if the address could not be added
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub error: Option<String>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct AnalyzePsbtInputsItemMissing {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pubkeys: Option<Vec<String>>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub signatures: Option<Vec<String>>,
        /// Hash160 of the redeem script that is missing
        #[serde(rename = "redeemscript")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub redeem_script: Option<String>,
        /// SHA256 of the witness script that is missing
        #[serde(rename = "witnessscript")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub witness_script: Option<String>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct AnalyzePsbtInputsItem {
        /// Whether a UTXO is provided
        pub has_utxo: bool,
        /// Whether the input is finalized
        pub is_final: bool,
        /// Things that are missing that are required to complete this input
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub missing: Option<AnalyzePsbtInputsItemMissing>,
        /// Role of the next person that this input needs to go to
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next: Option<String>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct AnalyzePsbt {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub inputs: Option<Vec<AnalyzePsbtInputsItem>>,
        /// Estimated vsize of the final signed transaction
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub estimated_vsize: Option<f64>,
        /// Estimated feerate of the final signed transaction in BTC/kvB. Shown only if all UTXO slots in the PSBT have been filled
        #[serde(rename = "estimated_feerate")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub estimated_fee_rate: Option<f64>,
        /// The transaction fee paid. Shown only if all UTXO slots in the PSBT have been filled
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fee: Option<f64>,
        /// Role of the next person that this psbt needs to go to
        pub next: String,
        /// Error message (if there is one)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub error: Option<String>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct BumpFeeOptions {
        /// Confirmation target in blocks
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub conf_target: Option<f64>,
        /// Specify a fee rate in sat/vB instead of relying on the built-in fee estimator.
        /// Must be at least 0.100 sat/vB higher than the current transaction fee rate.
        /// WARNING: before version 0.21, fee_rate was in BTC/kvB. As of 0.21, fee_rate is in sat/vB.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fee_rate: Option<f64>,
        /// Whether the new transaction should be
        /// marked bip-125 replaceable. If true, the sequence numbers in the transaction will
        /// be set to 0xfffffffd. If false, any input sequence numbers in the
        /// transaction will be set to 0xfffffffe
        /// so the new transaction will not be explicitly bip-125 replaceable (though it may
        /// still be replaceable in practice, for example if it has unconfirmed ancestors which
        /// are replaceable).
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub replaceable: Option<bool>,
        /// The fee estimate mode, must be one of (case insensitive):
        /// unset, economical, conservative
        /// unset means no mode set (economical mode is used if the transaction is replaceable;
        /// otherwise, conservative mode is used).
        /// economical estimates use a shorter time horizon, making them more
        /// responsive to short-term drops in the prevailing fee market. This mode
        /// potentially returns a lower fee rate estimate.
        /// conservative estimates use a longer time horizon, making them
        /// less responsive to short-term drops in the prevailing fee market. This mode
        /// potentially returns a higher fee rate estimate.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub estimate_mode: Option<String>,
        /// The outputs specified as key-value pairs.
        /// Each key may only appear once, i.e. there can only be one 'data' output, and no address may be duplicated.
        /// At least one output of either type must be specified.
        /// Cannot be provided if 'original_change_index' is specified.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub outputs: Option<Vec<Value>>,
        /// The 0-based index of the change output on the original transaction. The indicated output will be recycled into the new change output on the bumped transaction. The remainder after paying the recipients and fees will be sent to the output script of the original change output. The change outputâ€™s amount can increase if bumping the transaction adds new inputs, otherwise it will decrease. Cannot be used in combination with the 'outputs' option.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub original_change_index: Option<f64>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct BumpFee {
        /// The id of the new transaction.
        pub txid: String,
        /// The fee of the replaced transaction.
        #[serde(rename = "origfee")]
        pub original_fee: f64,
        /// The fee of the new transaction.
        pub fee: f64,
        /// Errors encountered during processing (may be empty).
        pub errors: Vec<String>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct CreateMultisig {
        /// The value of the new multisig address.
        pub address: String,
        /// The string value of the hex-encoded redemption script.
        #[serde(rename = "redeemScript")]
        pub redeem_script: String,
        /// The descriptor for this multisig
        pub descriptor: String,
        /// Any warnings resulting from the creation of this multisig
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub warnings: Option<Vec<String>>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct CreatePsbtInputsItem {
        /// The transaction id
        pub txid: String,
        /// The output number
        #[serde(rename = "vout")]
        pub outputs: f64,
        /// The sequence number
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub sequence: Option<f64>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct CreateRawTransactionInputsItem {
        /// The transaction id
        pub txid: String,
        /// The output number
        #[serde(rename = "vout")]
        pub outputs: f64,
        /// The sequence number
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub sequence: Option<f64>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct CreateWallet {
        /// The wallet name if created successfully. If the wallet was created using a full path, the wallet_name will be the full path.
        pub name: String,
        /// Warning messages, if any, related to creating and loading the wallet.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub warnings: Option<Vec<String>>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct CreateWalletDescriptorOptions {
        /// Whether to only make one descriptor that is internal (if parameter is true) or external (if parameter is false)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub internal: Option<bool>,
        /// The HD key that the wallet knows the private key of, listed using 'gethdkeys', to use for this descriptor's key
        #[serde(rename = "hdkey")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub hd_key: Option<String>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct CreateWalletDescriptor {
        /// The public descriptors that were added to the wallet
        #[serde(rename = "descs")]
        pub descriptors: Vec<String>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct DecodePsbtGlobalXpubsItem {
        /// The extended public key this path corresponds to
        pub xpub: String,
        /// The fingerprint of the master key
        pub master_fingerprint: String,
        /// The path
        pub path: String,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct DecodePsbtProprietaryItem {
        /// The hex string for the proprietary identifier
        pub identifier: String,
        /// The number for the subtype
        pub subtype: f64,
        /// The hex for the key
        pub key: String,
        /// The hex for the value
        pub value: String,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct DecodePsbtInputsItemWitnessUtxoScriptPubkey {
        /// Disassembly of the output script
        pub asm: String,
        /// Inferred descriptor for the output
        #[serde(rename = "desc")]
        pub descriptor: String,
        /// The raw output script bytes, hex-encoded
        pub hex: String,
        /// The type, eg 'pubkeyhash'
        #[serde(rename = "type")]
        pub type_: String,
        /// The Bitcoin address (only if a well-defined address exists)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub address: Option<String>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct DecodePsbtInputsItemWitnessUtxo {
        /// The value in BTC
        pub amount: f64,
        #[serde(rename = "scriptPubKey")]
        pub script_pubkey: DecodePsbtInputsItemWitnessUtxoScriptPubkey,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct DecodePsbtInputsItemRedeemScript {
        /// Disassembly of the redeem script
        pub asm: String,
        /// The raw redeem script bytes, hex-encoded
        pub hex: String,
        /// The type, eg 'pubkeyhash'
        #[serde(rename = "type")]
        pub type_: String,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct DecodePsbtInputsItemWitnessScript {
        /// Disassembly of the witness script
        pub asm: String,
        /// The raw witness script bytes, hex-encoded
        pub hex: String,
        /// The type, eg 'pubkeyhash'
        #[serde(rename = "type")]
        pub type_: String,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct DecodePsbtInputsItemBip32DerivsItem {
        /// The public key with the derivation path as the value.
        pub pubkey: String,
        /// The fingerprint of the master key
        pub master_fingerprint: String,
        /// The path
        pub path: String,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct DecodePsbtInputsItemFinalScriptSig {
        /// Disassembly of the final signature script
        pub asm: String,
        /// The raw final signature script bytes, hex-encoded
        pub hex: String,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct DecodePsbtInputsItemTaprootScriptPathSigsItem {
        /// The x-only pubkey for this signature
        pub pubkey: String,
        /// The leaf hash for this signature
        pub leaf_hash: String,
        /// The signature itself
        pub sig: String,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct DecodePsbtInputsItemTaprootScriptsItem {
        /// A leaf script
        pub script: String,
        /// The version number for the leaf script
        #[serde(rename = "leaf_ver")]
        pub leaf_version: f64,
        /// The control blocks for this script
        pub control_blocks: Vec<String>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct DecodePsbtInputsItemTaprootBip32DerivsItem {
        /// The x-only public key this path corresponds to
        pub pubkey: String,
        /// The fingerprint of the master key
        pub master_fingerprint: String,
        /// The path
        pub path: String,
        /// The hashes of the leaves this pubkey appears in
        pub leaf_hashes: Vec<String>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct DecodePsbtInputsItemMusig2ParticipantPubkeysItem {
        /// The compressed aggregate public key for which the participants create.
        pub aggregate_pubkey: String,
        pub participant_pubkeys: Vec<String>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct DecodePsbtInputsItemMusig2PubnoncesItem {
        /// The compressed public key of the participant that created this pubnonce.
        pub participant_pubkey: String,
        /// The compressed aggregate public key for which this pubnonce is for.
        pub aggregate_pubkey: String,
        /// The hash of the leaf script that contains the aggregate pubkey being signed for. Omitted when signing for the internal key.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub leaf_hash: Option<String>,
        /// The public nonce itself.
        pub pubnonce: String,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct DecodePsbtInputsItemMusig2PartialSigsItem {
        /// The compressed public key of the participant that created this partial signature.
        pub participant_pubkey: String,
        /// The compressed aggregate public key for which this partial signature is for.
        pub aggregate_pubkey: String,
        /// The hash of the leaf script that contains the aggregate pubkey being signed for. Omitted when signing for the internal key.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub leaf_hash: Option<String>,
        /// The partial signature itself.
        pub partial_sig: String,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct DecodePsbtInputsItemProprietaryItem {
        /// The hex string for the proprietary identifier
        pub identifier: String,
        /// The number for the subtype
        pub subtype: f64,
        /// The hex for the key
        pub key: String,
        /// The hex for the value
        pub value: String,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct DecodePsbtInputsItem {
        /// Decoded network transaction for non-witness UTXOs
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub non_witness_utxo: Option<BTreeMap<String, Value>>,
        /// Transaction output for witness UTXOs
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub witness_utxo: Option<DecodePsbtInputsItemWitnessUtxo>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub partial_signatures: Option<BTreeMap<String, String>>,
        /// The sighash type to be used
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub sighash: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub redeem_script: Option<DecodePsbtInputsItemRedeemScript>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub witness_script: Option<DecodePsbtInputsItemWitnessScript>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub bip32_derivs: Option<Vec<DecodePsbtInputsItemBip32DerivsItem>>,
        #[serde(rename = "final_scriptSig")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub final_script_sig: Option<DecodePsbtInputsItemFinalScriptSig>,
        #[serde(rename = "final_scriptwitness")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub final_script_witness: Option<Vec<String>>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ripemd160_preimages: Option<BTreeMap<String, String>>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub sha256_preimages: Option<BTreeMap<String, String>>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub hash160_preimages: Option<BTreeMap<String, String>>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub hash256_preimages: Option<BTreeMap<String, String>>,
        /// hex-encoded signature for the Taproot key path spend
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub taproot_key_path_sig: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub taproot_script_path_sigs: Option<Vec<DecodePsbtInputsItemTaprootScriptPathSigsItem>>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub taproot_scripts: Option<Vec<DecodePsbtInputsItemTaprootScriptsItem>>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub taproot_bip32_derivs: Option<Vec<DecodePsbtInputsItemTaprootBip32DerivsItem>>,
        /// The hex-encoded Taproot x-only internal key
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub taproot_internal_key: Option<String>,
        /// The hex-encoded Taproot merkle root
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub taproot_merkle_root: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub musig2_participant_pubkeys: Option<Vec<DecodePsbtInputsItemMusig2ParticipantPubkeysItem>>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub musig2_pubnonces: Option<Vec<DecodePsbtInputsItemMusig2PubnoncesItem>>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub musig2_partial_sigs: Option<Vec<DecodePsbtInputsItemMusig2PartialSigsItem>>,
        /// The unknown input fields
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub unknown: Option<BTreeMap<String, String>>,
        /// The input proprietary map
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub proprietary: Option<Vec<DecodePsbtInputsItemProprietaryItem>>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct DecodePsbtOutputsItemRedeemScript {
        /// Disassembly of the redeem script
        pub asm: String,
        /// The raw redeem script bytes, hex-encoded
        pub hex: String,
        /// The type, eg 'pubkeyhash'
        #[serde(rename = "type")]
        pub type_: String,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct DecodePsbtOutputsItemWitnessScript {
        /// Disassembly of the witness script
        pub asm: String,
        /// The raw witness script bytes, hex-encoded
        pub hex: String,
        /// The type, eg 'pubkeyhash'
        #[serde(rename = "type")]
        pub type_: String,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct DecodePsbtOutputsItemBip32DerivsItem {
        /// The public key this path corresponds to
        pub pubkey: String,
        /// The fingerprint of the master key
        pub master_fingerprint: String,
        /// The path
        pub path: String,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct DecodePsbtOutputsItemTaprootTreeItem {
        /// The depth of this element in the tree
        pub depth: f64,
        /// The version of this leaf
        #[serde(rename = "leaf_ver")]
        pub leaf_version: f64,
        /// The hex-encoded script itself
        pub script: String,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct DecodePsbtOutputsItemTaprootBip32DerivsItem {
        /// The x-only public key this path corresponds to
        pub pubkey: String,
        /// The fingerprint of the master key
        pub master_fingerprint: String,
        /// The path
        pub path: String,
        /// The hashes of the leaves this pubkey appears in
        pub leaf_hashes: Vec<String>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct DecodePsbtOutputsItemMusig2ParticipantPubkeysItem {
        /// The compressed aggregate public key for which the participants create.
        pub aggregate_pubkey: String,
        pub participant_pubkeys: Vec<String>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct DecodePsbtOutputsItemProprietaryItem {
        /// The hex string for the proprietary identifier
        pub identifier: String,
        /// The number for the subtype
        pub subtype: f64,
        /// The hex for the key
        pub key: String,
        /// The hex for the value
        pub value: String,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct DecodePsbtOutputsItem {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub redeem_script: Option<DecodePsbtOutputsItemRedeemScript>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub witness_script: Option<DecodePsbtOutputsItemWitnessScript>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub bip32_derivs: Option<Vec<DecodePsbtOutputsItemBip32DerivsItem>>,
        /// The hex-encoded Taproot x-only internal key
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub taproot_internal_key: Option<String>,
        /// The tuples that make up the Taproot tree, in depth first search order
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub taproot_tree: Option<Vec<DecodePsbtOutputsItemTaprootTreeItem>>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub taproot_bip32_derivs: Option<Vec<DecodePsbtOutputsItemTaprootBip32DerivsItem>>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub musig2_participant_pubkeys: Option<Vec<DecodePsbtOutputsItemMusig2ParticipantPubkeysItem>>,
        /// The unknown output fields
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub unknown: Option<BTreeMap<String, String>>,
        /// The output proprietary map
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub proprietary: Option<Vec<DecodePsbtOutputsItemProprietaryItem>>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct DecodePsbt {
        /// The decoded network-serialized unsigned transaction.
        pub tx: BTreeMap<String, Value>,
        pub global_xpubs: Vec<DecodePsbtGlobalXpubsItem>,
        /// The PSBT version number. Not to be confused with the unsigned transaction version
        pub psbt_version: f64,
        /// The global proprietary map
        pub proprietary: Vec<DecodePsbtProprietaryItem>,
        /// The unknown global fields
        pub unknown: BTreeMap<String, String>,
        pub inputs: Vec<DecodePsbtInputsItem>,
        pub outputs: Vec<DecodePsbtOutputsItem>,
        /// The transaction fee paid if all UTXOs slots in the PSBT have been filled.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fee: Option<f64>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct DecodeRawTransactionInputsItemScriptSig {
        /// Disassembly of the signature script
        pub asm: String,
        /// The raw signature script bytes, hex-encoded
        pub hex: String,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct DecodeRawTransactionInputsItem {
        /// The coinbase value (only if coinbase transaction)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub coinbase: Option<String>,
        /// The transaction id (if not coinbase transaction)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub txid: Option<String>,
        /// The output number (if not coinbase transaction)
        #[serde(rename = "vout")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub outputs: Option<f64>,
        /// The script (if not coinbase transaction)
        #[serde(rename = "scriptSig")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub script_sig: Option<DecodeRawTransactionInputsItemScriptSig>,
        #[serde(rename = "txinwitness")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub txin_witness: Option<Vec<String>>,
        /// The script sequence number
        pub sequence: f64,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct DecodeRawTransactionOutputsItemScriptPubkey {
        /// Disassembly of the output script
        pub asm: String,
        /// Inferred descriptor for the output
        #[serde(rename = "desc")]
        pub descriptor: String,
        /// The raw output script bytes, hex-encoded
        pub hex: String,
        /// The Bitcoin address (only if a well-defined address exists)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub address: Option<String>,
        /// The type (one of: nonstandard, anchor, pubkey, pubkeyhash, scripthash, multisig, nulldata, witness_v0_scripthash, witness_v0_keyhash, witness_v1_taproot, witness_unknown)
        #[serde(rename = "type")]
        pub type_: String,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct DecodeRawTransactionOutputsItem {
        /// The value in BTC
        pub value: f64,
        /// index
        #[serde(rename = "n")]
        pub index: f64,
        #[serde(rename = "scriptPubKey")]
        pub script_pubkey: DecodeRawTransactionOutputsItemScriptPubkey,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct DecodeRawTransaction {
        /// The transaction id
        pub txid: String,
        /// The transaction hash (differs from txid for witness transactions)
        pub hash: String,
        /// The serialized transaction size
        pub size: f64,
        /// The virtual transaction size (differs from size for witness transactions)
        pub vsize: f64,
        /// The transaction's weight (between vsize*4-3 and vsize*4)
        pub weight: f64,
        /// The version
        pub version: f64,
        /// The lock time
        #[serde(rename = "locktime")]
        pub lock_time: i64,
        #[serde(rename = "vin")]
        pub inputs: Vec<DecodeRawTransactionInputsItem>,
        #[serde(rename = "vout")]
        pub outputs: Vec<DecodeRawTransactionOutputsItem>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct DecodeScriptSegwit {
        /// Disassembly of the output script
        pub asm: String,
        /// The raw output script bytes, hex-encoded
        pub hex: String,
        /// The type of the output script (e.g. witness_v0_keyhash or witness_v0_scripthash)
        #[serde(rename = "type")]
        pub type_: String,
        /// The Bitcoin address (only if a well-defined address exists)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub address: Option<String>,
        /// Inferred descriptor for the script
        #[serde(rename = "desc")]
        pub descriptor: String,
        /// address of the P2SH script wrapping this witness redeem script
        #[serde(rename = "p2sh-segwit")]
        pub p2sh_segwit: String,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct DecodeScript {
        /// Disassembly of the script
        pub asm: String,
        /// Inferred descriptor for the script
        #[serde(rename = "desc")]
        pub descriptor: String,
        /// The output type (e.g. nonstandard, anchor, pubkey, pubkeyhash, scripthash, multisig, nulldata, witness_v0_scripthash, witness_v0_keyhash, witness_v1_taproot, witness_unknown)
        #[serde(rename = "type")]
        pub type_: String,
        /// The Bitcoin address (only if a well-defined address exists)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub address: Option<String>,
        /// address of P2SH script wrapping this redeem script (not returned for types that should not be wrapped)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub p2sh: Option<String>,
        /// Result of a witness output script wrapping this redeem script (not returned for types that should not be wrapped)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub segwit: Option<DecodeScriptSegwit>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[serde(untagged)]
    pub enum DeriveAddresses {
        /// for single derivation descriptors
        Variant0(Vec<String>),
        /// The derived addresses for each of the multipath expansions of the descriptor, in multipath specifier order
        Variant1(Vec<Vec<String>>),
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct DescriptorProcessPsbt {
        /// The base64-encoded partially signed transaction
        pub psbt: String,
        /// If the transaction has a complete set of signatures
        pub complete: bool,
        /// The hex-encoded network transaction if complete
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub hex: Option<String>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct DumpTxOutSetOptions {
        /// Height or hash of the block to roll back to before creating the snapshot. Note: The further this number is from the tip, the longer this process will take. Consider setting a higher -rpcclienttimeout value in this case.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub rollback: Option<f64>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct DumpTxOutSet {
        /// the number of coins written in the snapshot
        pub coins_written: f64,
        /// the hash of the base of the snapshot
        pub base_hash: String,
        /// the height of the base of the snapshot
        pub base_height: f64,
        /// the absolute path that the snapshot was written to
        pub path: String,
        /// the hash of the UTXO set contents
        #[serde(rename = "txoutset_hash")]
        pub tx_out_set_hash: String,
        /// the number of transactions in the chain up to and including the base block
        #[serde(rename = "nchaintx")]
        pub n_chain_tx: f64,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct EnumerateSignersSignersItem {
        /// Master key fingerprint
        pub fingerprint: String,
        /// Device name
        pub name: String,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct EnumerateSigners {
        pub signers: Vec<EnumerateSignersSignersItem>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct EstimateRawFeeShortPass {
        /// start of feerate range
        #[serde(rename = "startrange")]
        pub start_range: f64,
        /// end of feerate range
        #[serde(rename = "endrange")]
        pub end_range: f64,
        /// number of txs over history horizon in the feerate range that were confirmed within target
        #[serde(rename = "withintarget")]
        pub within_target: f64,
        /// number of txs over history horizon in the feerate range that were confirmed at any point
        #[serde(rename = "totalconfirmed")]
        pub total_confirmed: f64,
        /// current number of txs in mempool in the feerate range unconfirmed for at least target blocks
        #[serde(rename = "inmempool")]
        pub in_mempool: f64,
        /// number of txs over history horizon in the feerate range that left mempool unconfirmed after target
        #[serde(rename = "leftmempool")]
        pub left_mempool: f64,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct EstimateRawFeeShort {
        /// estimate fee rate in BTC/kvB
        #[serde(rename = "feerate")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fee_rate: Option<f64>,
        /// exponential decay (per block) for historical moving average of confirmation data
        pub decay: f64,
        /// The resolution of confirmation targets at this time horizon
        pub scale: f64,
        /// information about the lowest range of feerates to succeed in meeting the threshold
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pass: Option<EstimateRawFeeShortPass>,
        /// information about the highest range of feerates to fail to meet the threshold
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fail: Option<BTreeMap<String, Value>>,
        /// Errors encountered during processing (if there are any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub errors: Option<Vec<String>>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct EstimateRawFee {
        /// estimate for short time horizon
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub short: Option<EstimateRawFeeShort>,
        /// estimate for medium time horizon
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub medium: Option<BTreeMap<String, Value>>,
        /// estimate for long time horizon
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub long: Option<BTreeMap<String, Value>>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct EstimateSmartFee {
        /// estimate fee rate in BTC/kvB (only present if no errors were encountered)
        #[serde(rename = "feerate")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fee_rate: Option<f64>,
        /// Errors encountered during processing (if there are any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub errors: Option<Vec<String>>,
        /// block number where estimate was found
        /// The request target will be clamped between 2 and the highest target
        /// fee estimation is able to return based on how long it has been running.
        /// An error is returned if not enough transactions and blocks
        /// have been observed to make an estimate for any number of blocks.
        pub blocks: f64,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct FinalizePsbt {
        /// The base64-encoded partially signed transaction if not extracted
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub psbt: Option<String>,
        /// The hex-encoded network transaction if extracted
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub hex: Option<String>,
        /// If the transaction has a complete set of signatures
        pub complete: bool,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct FundRawTransactionOptionsInputWeightsItem {
        /// The transaction id
        pub txid: String,
        /// The output index
        #[serde(rename = "vout")]
        pub outputs: f64,
        /// The maximum weight for this input, including the weight of the outpoint and sequence number. Note that serialized signature sizes are not guaranteed to be consistent, so the maximum DER signatures size of 73 bytes should be used when considering ECDSA signatures.Remember to convert serialized sizes to weight units when necessary.
        pub weight: f64,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct FundRawTransactionOptionsSolvingData {
        /// Public keys involved in this transaction.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pubkeys: Option<Vec<String>>,
        /// Scripts involved in this transaction.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub scripts: Option<Vec<String>>,
        /// Descriptors that provide solving data for this transaction.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub descriptors: Option<Vec<String>>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct FundRawTransactionOptions {
        /// For a transaction with existing inputs, automatically include more if they are not enough.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub add_inputs: Option<bool>,
        /// Include inputs that are not safe to spend (unconfirmed transactions from outside keys and unconfirmed replacement transactions).
        /// Warning: the resulting transaction may become invalid if one of the unsafe inputs disappears.
        /// If that happens, you will need to fund the transaction with different inputs and republish it.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub include_unsafe: Option<bool>,
        /// If add_inputs is specified, require inputs with at least this many confirmations.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub minconf: Option<f64>,
        /// If add_inputs is specified, require inputs with at most this many confirmations.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub maxconf: Option<f64>,
        /// The bitcoin address to receive the change
        #[serde(rename = "changeAddress")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub change_address: Option<String>,
        /// The index of the change output
        #[serde(rename = "changePosition")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub change_position: Option<f64>,
        /// The output type to use. Only valid if changeAddress is not specified. Options are "legacy", "p2sh-segwit", "bech32", "bech32m".
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub change_type: Option<String>,
        /// (DEPRECATED) No longer used
        #[serde(rename = "includeWatching")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub include_watching: Option<bool>,
        /// Lock selected unspent outputs
        #[serde(rename = "lockUnspents")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub lock_unspents: Option<bool>,
        /// Specify a fee rate in sat/vB.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fee_rate: Option<f64>,
        /// Specify a fee rate in BTC/kvB.
        #[serde(rename = "feeRate")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fee_rate_btc_kvb: Option<f64>,
        /// The integers.
        /// The fee will be equally deducted from the amount of each specified output.
        /// Those recipients will receive less bitcoins than you enter in their corresponding amount field.
        /// If no outputs are specified here, the sender pays the fee.
        #[serde(rename = "subtractFeeFromOutputs")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub subtract_fee_from_outputs: Option<Vec<f64>>,
        /// Inputs and their corresponding weights
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub input_weights: Option<Vec<FundRawTransactionOptionsInputWeightsItem>>,
        /// The maximum acceptable transaction weight.
        /// Transaction building will fail if this can not be satisfied.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub max_tx_weight: Option<f64>,
        /// Confirmation target in blocks
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub conf_target: Option<f64>,
        /// The fee estimate mode, must be one of (case insensitive):
        /// unset, economical, conservative
        /// unset means no mode set (economical mode is used if the transaction is replaceable;
        /// otherwise, conservative mode is used).
        /// economical estimates use a shorter time horizon, making them more
        /// responsive to short-term drops in the prevailing fee market. This mode
        /// potentially returns a lower fee rate estimate.
        /// conservative estimates use a longer time horizon, making them
        /// less responsive to short-term drops in the prevailing fee market. This mode
        /// potentially returns a higher fee rate estimate.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub estimate_mode: Option<String>,
        /// Marks this transaction as BIP125-replaceable.
        /// Allows this transaction to be replaced by a transaction with higher fees
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub replaceable: Option<bool>,
        /// Keys and scripts needed for producing a final transaction with a dummy signature.
        /// Used for fee estimation during coin selection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub solving_data: Option<FundRawTransactionOptionsSolvingData>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct FundRawTransaction {
        /// The resulting raw transaction (hex-encoded string)
        pub hex: String,
        /// Fee in BTC the resulting transaction pays
        pub fee: f64,
        /// The position of the added change output, or -1
        #[serde(rename = "changepos")]
        pub change_position: f64,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GenerateBlock {
        /// hash of generated block
        pub hash: String,
        /// hex of generated block, only present when submit=false
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub hex: Option<String>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetAddedNodeInfoItemAddressesItem {
        /// The bitcoin server IP and port we're connected to
        pub address: String,
        /// connection, inbound or outbound
        pub connected: String,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetAddedNodeInfoItem {
        /// The node IP address or name (as provided to addnode)
        #[serde(rename = "addednode")]
        pub added_node: String,
        /// If connected
        pub connected: bool,
        /// Only when connected = true
        pub addresses: Vec<GetAddedNodeInfoItemAddressesItem>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetAddressesByLabelValue {
        /// Purpose of address ("send" for sending address, "receive" for receiving address)
        pub purpose: String,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetAddressInfo {
        /// The bitcoin address validated.
        pub address: String,
        /// The hex-encoded output script generated by the address.
        #[serde(rename = "scriptPubKey")]
        pub script_pubkey: String,
        /// If the address is yours.
        #[serde(rename = "ismine")]
        pub is_mine: bool,
        /// (DEPRECATED) Always false.
        #[serde(rename = "iswatchonly")]
        pub is_watch_only: bool,
        /// If we know how to spend coins sent to this address, ignoring the possible lack of private keys.
        pub solvable: bool,
        /// A descriptor for spending coins sent to this address (only when solvable).
        #[serde(rename = "desc")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub descriptor: Option<String>,
        /// The descriptor used to derive this address if this is a descriptor wallet
        #[serde(rename = "parent_desc")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub parent_descriptor: Option<String>,
        /// If the key is a script.
        #[serde(rename = "isscript")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_script: Option<bool>,
        /// If the address was used for change output.
        #[serde(rename = "ischange")]
        pub is_change: bool,
        /// If the address is a witness address.
        #[serde(rename = "iswitness")]
        pub is_witness: bool,
        /// The version number of the witness program.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub witness_version: Option<f64>,
        /// The hex value of the witness program.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub witness_program: Option<String>,
        /// The output script type. Only if isscript is true and the redeemscript is known. Possible
        /// types: nonstandard, pubkey, pubkeyhash, scripthash, multisig, nulldata, witness_v0_keyhash,
        /// witness_v0_scripthash, witness_unknown.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub script: Option<String>,
        /// The redeemscript for the p2sh address.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub hex: Option<String>,
        /// Array of pubkeys associated with the known redeemscript (only if script is multisig).
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pubkeys: Option<Vec<String>>,
        /// The number of signatures required to spend multisig output (only if script is multisig).
        #[serde(rename = "sigsrequired")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub sigs_required: Option<f64>,
        /// The hex value of the raw public key for single-key addresses (possibly embedded in P2SH or P2WSH).
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pubkey: Option<String>,
        /// Information about the address embedded in P2SH or P2WSH, if relevant and known.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub embedded: Option<BTreeMap<String, Value>>,
        /// If the pubkey is compressed.
        #[serde(rename = "iscompressed")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_compressed: Option<bool>,
        /// The creation time of the key, if available, expressed in UNIX epoch time.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub timestamp: Option<i64>,
        /// The HD keypath, if the key is HD and available.
        #[serde(rename = "hdkeypath")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub hd_key_path: Option<String>,
        /// The Hash160 of the HD seed.
        #[serde(rename = "hdseedid")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub hd_seed_id: Option<String>,
        /// The fingerprint of the master key.
        #[serde(rename = "hdmasterfingerprint")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub hd_master_fingerprint: Option<String>,
        /// Array of labels associated with the address. Currently limited to one label but returned
        /// as an array to keep the API stable if multiple labels are enabled in the future.
        pub labels: Vec<String>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetAddrmanInfoValue {
        /// number of addresses in the new table, which represent potential peers the node has discovered but hasn't yet successfully connected to.
        pub new: f64,
        /// number of addresses in the tried table, which represent peers the node has successfully connected to in the past.
        pub tried: f64,
        /// total number of addresses in both new/tried tables
        pub total: f64,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetBalancesMine {
        /// trusted balance (outputs created by the wallet or confirmed outputs)
        pub trusted: f64,
        /// untrusted pending balance (outputs created by others that are in the mempool)
        pub untrusted_pending: f64,
        /// balance from immature coinbase outputs
        pub immature: f64,
        /// (only present if avoid_reuse is set) balance from coins sent to addresses that were previously spent from (potentially privacy violating)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub used: Option<f64>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetBalancesLastProcessedBlock {
        /// hash of the block this information was generated on
        pub hash: String,
        /// height of the block this information was generated on
        pub height: f64,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetBalances {
        /// balances from outputs that the wallet can sign
        pub mine: GetBalancesMine,
        /// hash and height of the block this information was generated on
        #[serde(rename = "lastprocessedblock")]
        pub last_processed_block: GetBalancesLastProcessedBlock,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetBlockVariant1 {
        /// the block hash (same as provided)
        pub hash: String,
        /// The number of confirmations, or -1 if the block is not on the main chain
        pub confirmations: f64,
        /// The block size
        pub size: f64,
        /// The block size excluding witness data
        #[serde(rename = "strippedsize")]
        pub stripped_size: f64,
        /// The block weight as defined in BIP 141
        pub weight: f64,
        /// The block height or index
        pub height: f64,
        /// The block version
        pub version: f64,
        /// The block version formatted in hexadecimal
        #[serde(rename = "versionHex")]
        pub version_hex: String,
        /// The merkle root
        #[serde(rename = "merkleroot")]
        pub merkle_root: String,
        /// The transaction ids
        pub tx: Vec<String>,
        /// The block time expressed in UNIX epoch time
        #[serde(rename = "time")]
        pub transaction_time: i64,
        /// The median block time expressed in UNIX epoch time
        #[serde(rename = "mediantime")]
        pub median_time: i64,
        /// The nonce
        pub nonce: f64,
        /// nBits: compact representation of the block difficulty target
        pub bits: String,
        /// The difficulty target
        pub target: String,
        /// The difficulty
        pub difficulty: f64,
        /// Expected number of hashes required to produce the chain up to this block (in hex)
        #[serde(rename = "chainwork")]
        pub chain_work: String,
        /// The number of transactions in the block
        #[serde(rename = "nTx")]
        pub n_tx: f64,
        /// The hash of the previous block (if available)
        #[serde(rename = "previousblockhash")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub previous_block_hash: Option<String>,
        /// The hash of the next block (if available)
        #[serde(rename = "nextblockhash")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_block_hash: Option<String>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetBlockVariant2TxItem {
        /// The transaction fee in BTC, omitted if block undo data is not available
        pub fee: f64,
        /// Additional properties
        #[serde(flatten)]
        pub extra: BTreeMap<String, Value>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetBlockVariant2 {
        pub tx: Vec<GetBlockVariant2TxItem>,
        /// Additional properties
        #[serde(flatten)]
        pub extra: BTreeMap<String, Value>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetBlockVariant3TxItemInputsItemPrevoutScriptPubkey {
        /// Disassembly of the output script
        pub asm: String,
        /// Inferred descriptor for the output
        #[serde(rename = "desc")]
        pub descriptor: String,
        /// The raw output script bytes, hex-encoded
        pub hex: String,
        /// The Bitcoin address (only if a well-defined address exists)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub address: Option<String>,
        /// The type (one of: nonstandard, anchor, pubkey, pubkeyhash, scripthash, multisig, nulldata, witness_v0_scripthash, witness_v0_keyhash, witness_v1_taproot, witness_unknown)
        #[serde(rename = "type")]
        pub type_: String,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetBlockVariant3TxItemInputsItemPrevout {
        /// Coinbase or not
        pub generated: bool,
        /// The height of the prevout
        pub height: f64,
        /// The value in BTC
        pub value: f64,
        #[serde(rename = "scriptPubKey")]
        pub script_pubkey: GetBlockVariant3TxItemInputsItemPrevoutScriptPubkey,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetBlockVariant3TxItemInputsItem {
        /// (Only if undo information is available)
        pub prevout: GetBlockVariant3TxItemInputsItemPrevout,
        /// Additional properties
        #[serde(flatten)]
        pub extra: BTreeMap<String, Value>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetBlockVariant3TxItem {
        #[serde(rename = "vin")]
        pub inputs: Vec<GetBlockVariant3TxItemInputsItem>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetBlockVariant3 {
        pub tx: Vec<GetBlockVariant3TxItem>,
        /// Additional properties
        #[serde(flatten)]
        pub extra: BTreeMap<String, Value>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[serde(untagged)]
    pub enum GetBlock {
        /// A string that is serialized, hex-encoded data for block 'hash'
        Variant0(String),
        /// for verbosity = 1
        Variant1(GetBlockVariant1),
        /// for verbosity = 2
        Variant2(GetBlockVariant2),
        /// for verbosity = 3
        Variant3(GetBlockVariant3),
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetBlockchainInfo {
        /// current network name (main, test, testnet4, signet, regtest)
        pub chain: String,
        /// the height of the most-work fully-validated chain. The genesis block has height 0
        pub blocks: f64,
        /// the current number of headers we have validated
        pub headers: f64,
        /// the hash of the currently best block
        #[serde(rename = "bestblockhash")]
        pub best_block_hash: String,
        /// nBits: compact representation of the block difficulty target
        pub bits: String,
        /// The difficulty target
        pub target: String,
        /// the current difficulty
        pub difficulty: f64,
        /// The block time expressed in UNIX epoch time
        #[serde(rename = "time")]
        pub transaction_time: i64,
        /// The median block time expressed in UNIX epoch time
        #[serde(rename = "mediantime")]
        pub median_time: i64,
        /// estimate of verification progress [0..1]
        #[serde(rename = "verificationprogress")]
        pub verification_progress: f64,
        /// (debug information) estimate of whether this node is in Initial Block Download mode
        #[serde(rename = "initialblockdownload")]
        pub initial_block_download: bool,
        /// total amount of work in active chain, in hexadecimal
        #[serde(rename = "chainwork")]
        pub chain_work: String,
        /// the estimated size of the block and undo files on disk
        pub size_on_disk: f64,
        /// if the blocks are subject to pruning
        pub pruned: bool,
        /// height of the last block pruned, plus one (only present if pruning is enabled)
        #[serde(rename = "pruneheight")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub prune_height: Option<f64>,
        /// whether automatic pruning is enabled (only present if pruning is enabled)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub automatic_pruning: Option<bool>,
        /// the target size used by pruning (only present if automatic pruning is enabled)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub prune_target_size: Option<f64>,
        /// the block challenge (aka. block script), in hexadecimal (only present if the current network is a signet)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub signet_challenge: Option<String>,
        /// any network and blockchain warnings (run with `-deprecatedrpc=warnings` to return the latest warning as a single string)
        pub warnings: Vec<String>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetBlockFilter {
        /// the hex-encoded filter data
        pub filter: String,
        /// the hex-encoded filter header
        pub header: String,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetBlockHeaderVariant0 {
        /// the block hash (same as provided)
        pub hash: String,
        /// The number of confirmations, or -1 if the block is not on the main chain
        pub confirmations: f64,
        /// The block height or index
        pub height: f64,
        /// The block version
        pub version: f64,
        /// The block version formatted in hexadecimal
        #[serde(rename = "versionHex")]
        pub version_hex: String,
        /// The merkle root
        #[serde(rename = "merkleroot")]
        pub merkle_root: String,
        /// The block time expressed in UNIX epoch time
        #[serde(rename = "time")]
        pub transaction_time: i64,
        /// The median block time expressed in UNIX epoch time
        #[serde(rename = "mediantime")]
        pub median_time: i64,
        /// The nonce
        pub nonce: f64,
        /// nBits: compact representation of the block difficulty target
        pub bits: String,
        /// The difficulty target
        pub target: String,
        /// The difficulty
        pub difficulty: f64,
        /// Expected number of hashes required to produce the current chain
        #[serde(rename = "chainwork")]
        pub chain_work: String,
        /// The number of transactions in the block
        #[serde(rename = "nTx")]
        pub n_tx: f64,
        /// The hash of the previous block (if available)
        #[serde(rename = "previousblockhash")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub previous_block_hash: Option<String>,
        /// The hash of the next block (if available)
        #[serde(rename = "nextblockhash")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_block_hash: Option<String>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[serde(untagged)]
    pub enum GetBlockHeader {
        /// for verbose = true
        Variant0(GetBlockHeaderVariant0),
        /// A string that is serialized, hex-encoded data for block 'hash'
        Variant1(String),
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetBlockStats {
        /// Average fee in the block
        #[serde(rename = "avgfee")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub average_fee: Option<f64>,
        /// Average feerate (in satoshis per virtual byte)
        #[serde(rename = "avgfeerate")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub average_fee_rate: Option<f64>,
        /// Average transaction size
        #[serde(rename = "avgtxsize")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub average_tx_size: Option<f64>,
        /// The block hash (to check for potential reorgs)
        #[serde(rename = "blockhash")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub block_hash: Option<String>,
        /// Feerates at the 10th, 25th, 50th, 75th, and 90th percentile weight unit (in satoshis per virtual byte)
        #[serde(rename = "feerate_percentiles")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fee_rate_percentiles: Option<Vec<Value>>,
        /// The height of the block
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub height: Option<f64>,
        /// The number of inputs (excluding coinbase)
        #[serde(rename = "ins")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub inputs: Option<f64>,
        /// Maximum fee in the block
        #[serde(rename = "maxfee")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub max_fee: Option<f64>,
        /// Maximum feerate (in satoshis per virtual byte)
        #[serde(rename = "maxfeerate")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub max_fee_rate: Option<f64>,
        /// Maximum transaction size
        #[serde(rename = "maxtxsize")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub max_tx_size: Option<f64>,
        /// Truncated median fee in the block
        #[serde(rename = "medianfee")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub median_fee: Option<f64>,
        /// The block median time past
        #[serde(rename = "mediantime")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub median_time: Option<f64>,
        /// Truncated median transaction size
        #[serde(rename = "mediantxsize")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub median_tx_size: Option<f64>,
        /// Minimum fee in the block
        #[serde(rename = "minfee")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub minimum_fee: Option<f64>,
        /// Minimum feerate (in satoshis per virtual byte)
        #[serde(rename = "minfeerate")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub minimum_fee_rate: Option<f64>,
        /// Minimum transaction size
        #[serde(rename = "mintxsize")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub minimum_tx_size: Option<f64>,
        /// The number of outputs
        #[serde(rename = "outs")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub outputs: Option<f64>,
        /// The block subsidy
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub subsidy: Option<f64>,
        /// Total size of all segwit transactions
        #[serde(rename = "swtotal_size")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub segwit_total_size: Option<f64>,
        /// Total weight of all segwit transactions
        #[serde(rename = "swtotal_weight")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub segwit_total_weight: Option<f64>,
        /// The number of segwit transactions
        #[serde(rename = "swtxs")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub segwit_txs: Option<f64>,
        /// The block time
        #[serde(rename = "time")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub transaction_time: Option<f64>,
        /// Total amount in all outputs (excluding coinbase and thus reward [ie subsidy + totalfee])
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_out: Option<f64>,
        /// Total size of all non-coinbase transactions
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_size: Option<f64>,
        /// Total weight of all non-coinbase transactions
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_weight: Option<f64>,
        /// The fee total
        #[serde(rename = "totalfee")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_fee: Option<f64>,
        /// The number of transactions (including coinbase)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub txs: Option<f64>,
        /// The increase/decrease in the number of unspent outputs (not discounting op_return and similar)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub utxo_increase: Option<f64>,
        /// The increase/decrease in size for the utxo index (not discounting op_return and similar)
        #[serde(rename = "utxo_size_inc")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub utxo_size_increase: Option<f64>,
        /// The increase/decrease in the number of unspent outputs, not counting unspendables
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub utxo_increase_actual: Option<f64>,
        /// The increase/decrease in size for the utxo index, not counting unspendables
        #[serde(rename = "utxo_size_inc_actual")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub utxo_size_increase_actual: Option<f64>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetBlockTemplateTemplateRequest {
        /// This must be set to "template", "proposal" (see BIP 23), or omitted
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub mode: Option<String>,
        /// A list of strings
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub capabilities: Option<Vec<String>>,
        /// A list of strings
        pub rules: Vec<Value>,
        /// delay processing request until the result would vary significantly from the "longpollid" of a prior template
        #[serde(rename = "longpollid")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub long_poll_id: Option<String>,
        /// proposed block data to check, encoded in hexadecimal; valid only for mode="proposal"
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub data: Option<String>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetBlockTemplateVariant2TransactionsItem {
        /// transaction data encoded in hexadecimal (byte-for-byte)
        pub data: String,
        /// transaction hash excluding witness data, shown in byte-reversed hex
        pub txid: String,
        /// transaction hash including witness data, shown in byte-reversed hex
        pub hash: String,
        /// array of numbers
        pub depends: Vec<f64>,
        /// difference in value between transaction inputs and outputs (in satoshis); for coinbase transactions, this is a negative Number of the total collected block fees (ie, not including the block subsidy); if key is not present, fee is unknown and clients MUST NOT assume there isn't one
        pub fee: f64,
        /// total SigOps cost, as counted for purposes of block limits; if key is not present, sigop cost is unknown and clients MUST NOT assume it is zero
        pub sigops: f64,
        /// total transaction weight, as counted for purposes of block limits
        pub weight: f64,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetBlockTemplateVariant2 {
        /// The preferred block version
        pub version: f64,
        /// specific block rules that are to be enforced
        pub rules: Vec<String>,
        /// set of pending, supported versionbit (BIP 9) softfork deployments
        #[serde(rename = "vbavailable")]
        pub version_bits_available: BTreeMap<String, f64>,
        pub capabilities: Vec<String>,
        /// bit mask of versionbits the server requires set in submissions
        #[serde(rename = "vbrequired")]
        pub version_bits_required: f64,
        /// The hash of current highest block
        #[serde(rename = "previousblockhash")]
        pub previous_block_hash: String,
        /// contents of non-coinbase transactions that should be included in the next block
        pub transactions: Vec<GetBlockTemplateVariant2TransactionsItem>,
        /// data that should be included in the coinbase's scriptSig content
        #[serde(rename = "coinbaseaux")]
        pub coinbase_aux: BTreeMap<String, String>,
        /// maximum allowable input to coinbase transaction, including the generation award and transaction fees (in satoshis)
        #[serde(rename = "coinbasevalue")]
        pub coinbase_value: f64,
        /// an id to include with a request to longpoll on an update to this template
        #[serde(rename = "longpollid")]
        pub long_poll_id: String,
        /// The hash target
        pub target: String,
        /// The minimum timestamp appropriate for the next block time, expressed in UNIX epoch time. Adjusted for the proposed BIP94 timewarp rule.
        #[serde(rename = "mintime")]
        pub min_time: i64,
        /// list of ways the block template may be changed
        pub mutable: Vec<String>,
        /// A range of valid nonces
        #[serde(rename = "noncerange")]
        pub nonce_range: String,
        /// limit of sigops in blocks
        #[serde(rename = "sigoplimit")]
        pub sigop_limit: f64,
        /// limit of block size
        #[serde(rename = "sizelimit")]
        pub size_limit: f64,
        /// limit of block weight
        #[serde(rename = "weightlimit")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub weight_limit: Option<f64>,
        /// current timestamp in UNIX epoch time. Adjusted for the proposed BIP94 timewarp rule.
        #[serde(rename = "curtime")]
        pub current_time: i64,
        /// compressed target of next block
        pub bits: String,
        /// The height of the next block
        pub height: f64,
        /// Only on signet
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub signet_challenge: Option<String>,
        /// a valid witness commitment for the unmodified block template
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub default_witness_commitment: Option<String>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[serde(untagged)]
    pub enum GetBlockTemplate {
        /// If the proposal was accepted with mode=='proposal'
        Variant0(()),
        /// According to BIP22
        Variant1(String),
        /// Otherwise
        Variant2(GetBlockTemplateVariant2),
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetChainStatesChainStatesItem {
        /// number of blocks in this chainstate
        pub blocks: f64,
        /// blockhash of the tip
        #[serde(rename = "bestblockhash")]
        pub best_block_hash: String,
        /// nBits: compact representation of the block difficulty target
        pub bits: String,
        /// The difficulty target
        pub target: String,
        /// difficulty of the tip
        pub difficulty: f64,
        /// progress towards the network tip
        #[serde(rename = "verificationprogress")]
        pub verification_progress: f64,
        /// the base block of the snapshot this chainstate is based on, if any
        #[serde(rename = "snapshot_blockhash")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub snapshot_block_hash: Option<String>,
        /// size of the coinsdb cache
        pub coins_db_cache_bytes: f64,
        /// size of the coinstip cache
        pub coins_tip_cache_bytes: f64,
        /// whether the chainstate is fully validated. True if all blocks in the chainstate were validated, false if the chain is based on a snapshot and the snapshot has not yet been validated.
        pub validated: bool,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetChainStates {
        /// the number of headers seen so far
        pub headers: f64,
        /// list of the chainstates ordered by work, with the most-work (active) chainstate last
        #[serde(rename = "chainstates")]
        pub chain_states: Vec<GetChainStatesChainStatesItem>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetChainTipsItem {
        /// height of the chain tip
        pub height: f64,
        /// block hash of the tip
        pub hash: String,
        /// zero for main chain, otherwise length of branch connecting the tip to the main chain
        #[serde(rename = "branchlen")]
        pub branch_length: f64,
        /// status of the chain, "active" for the main chain
        /// Possible values for status:
        /// 1.  "invalid"               This branch contains at least one invalid block
        /// 2.  "headers-only"          Not all blocks for this branch are available, but the headers are valid
        /// 3.  "valid-headers"         All blocks are available for this branch, but they were never fully validated
        /// 4.  "valid-fork"            This branch is not part of the active chain, but is fully validated
        /// 5.  "active"                This is the tip of the active main chain, which is certainly valid
        pub status: String,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetChainTxStats {
        /// The timestamp for the final block in the window, expressed in UNIX epoch time
        #[serde(rename = "time")]
        pub transaction_time: i64,
        /// The total number of transactions in the chain up to that point, if known. It may be unknown when using assumeutxo.
        #[serde(rename = "txcount")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub tx_count: Option<f64>,
        /// The hash of the final block in the window
        pub window_final_block_hash: String,
        /// The height of the final block in the window.
        pub window_final_block_height: f64,
        /// Size of the window in number of blocks
        pub window_block_count: f64,
        /// The elapsed time in the window in seconds. Only returned if "window_block_count" is > 0
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub window_interval: Option<f64>,
        /// The number of transactions in the window. Only returned if "window_block_count" is > 0 and if txcount exists for the start and end of the window.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub window_tx_count: Option<f64>,
        /// The average rate of transactions per second in the window. Only returned if "window_interval" is > 0 and if window_tx_count exists.
        #[serde(rename = "txrate")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub tx_rate: Option<f64>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetDeploymentInfoDeploymentsValueBip9Statistics {
        /// the length in blocks of the signalling period
        pub period: f64,
        /// the number of blocks with the version bit set required to activate the feature (only for "started" status)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub threshold: Option<f64>,
        /// the number of blocks elapsed since the beginning of the current period
        pub elapsed: f64,
        /// the number of blocks with the version bit set in the current period
        pub count: f64,
        /// returns false if there are not enough blocks left in this period to pass activation threshold (only for "started" status)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub possible: Option<bool>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetDeploymentInfoDeploymentsValueBip9 {
        /// the bit (0-28) in the block version field used to signal this softfork (only for "started" and "locked_in" status)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub bit: Option<f64>,
        /// the minimum median time past of a block at which the bit gains its meaning
        pub start_time: i64,
        /// the median time past of a block at which the deployment is considered failed if not yet locked in
        pub timeout: i64,
        /// minimum height of blocks for which the rules may be enforced
        pub min_activation_height: f64,
        /// status of deployment at specified block (one of "defined", "started", "locked_in", "active", "failed")
        pub status: String,
        /// height of the first block to which the status applies
        pub since: f64,
        /// status of deployment at the next block
        pub status_next: String,
        /// numeric statistics about signalling for a softfork (only for "started" and "locked_in" status)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub statistics: Option<GetDeploymentInfoDeploymentsValueBip9Statistics>,
        /// indicates blocks that signalled with a # and blocks that did not with a -
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub signalling: Option<String>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetDeploymentInfoDeploymentsValue {
        /// one of "buried", "bip9"
        #[serde(rename = "type")]
        pub type_: String,
        /// height of the first block which the rules are or will be enforced (only for "buried" type, or "bip9" type with "active" status)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub height: Option<f64>,
        /// true if the rules are enforced for the mempool and the next block
        pub active: bool,
        /// status of bip9 softforks (only for "bip9" type)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub bip9: Option<GetDeploymentInfoDeploymentsValueBip9>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetDeploymentInfo {
        /// requested block hash (or tip)
        pub hash: String,
        /// requested block height (or tip)
        pub height: f64,
        pub deployments: BTreeMap<String, GetDeploymentInfoDeploymentsValue>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetDescriptorActivity {
        /// events
        pub activity: Vec<Value>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetDescriptorInfo {
        /// The descriptor in canonical form, without private keys. For a multipath descriptor, only the first will be returned.
        pub descriptor: String,
        /// All descriptors produced by expanding multipath derivation elements. Only if the provided descriptor specifies multipath derivation elements.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub multipath_expansion: Option<Vec<String>>,
        /// The checksum for the input descriptor
        pub checksum: String,
        /// Whether the descriptor is ranged
        #[serde(rename = "isrange")]
        pub is_range: bool,
        /// Whether the descriptor is solvable
        #[serde(rename = "issolvable")]
        pub is_solvable: bool,
        /// Whether the input descriptor contained at least one private key
        #[serde(rename = "hasprivatekeys")]
        pub has_private_keys: bool,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetHdKeysOptions {
        /// Show the keys for only active descriptors
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub active_only: Option<bool>,
        /// Show private keys
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub private: Option<bool>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetHdKeysItemDescriptorsItem {
        /// Descriptor string representation
        #[serde(rename = "desc")]
        pub descriptor: String,
        /// Whether this descriptor is currently used to generate new addresses
        pub active: bool,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetHdKeysItem {
        /// The extended public key
        pub xpub: String,
        /// Whether the wallet has the private key for this xpub
        pub has_private: bool,
        /// The extended private key if "private" is true
        #[serde(rename = "xprv")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub xpriv: Option<String>,
        /// Array of descriptor objects that use this HD key
        pub descriptors: Vec<GetHdKeysItemDescriptorsItem>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetIndexInfoValue {
        /// Whether the index is synced or not
        pub synced: bool,
        /// The block height to which the index is synced
        pub best_block_height: f64,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetMemoryInfoVariant0Locked {
        /// Number of bytes used
        pub used: f64,
        /// Number of bytes available in current arenas
        pub free: f64,
        /// Total number of bytes managed
        pub total: f64,
        /// Amount of bytes that succeeded locking. If this number is smaller than total, locking pages failed at some point and key data could be swapped to disk.
        pub locked: f64,
        /// Number allocated chunks
        pub chunks_used: f64,
        /// Number unused chunks
        pub chunks_free: f64,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetMemoryInfoVariant0 {
        /// Information about locked memory manager
        pub locked: GetMemoryInfoVariant0Locked,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[serde(untagged)]
    pub enum GetMemoryInfo {
        /// mode "stats"
        Variant0(GetMemoryInfoVariant0),
        /// "<malloc version="1">..."
        Variant1(String),
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetMempoolAncestorsVariant1ValueFees {
        /// transaction fee, denominated in BTC
        #[serde(rename = "base")]
        pub base_fee: f64,
        /// transaction fee with fee deltas used for mining priority, denominated in BTC
        pub modified: f64,
        /// transaction fees of in-mempool ancestors (including this one) with fee deltas used for mining priority, denominated in BTC
        pub ancestor: f64,
        /// transaction fees of in-mempool descendants (including this one) with fee deltas used for mining priority, denominated in BTC
        pub descendant: f64,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetMempoolAncestorsVariant1Value {
        /// virtual transaction size as defined in BIP 141. This is different from actual serialized size for witness transactions as witness data is discounted.
        pub vsize: f64,
        /// transaction weight as defined in BIP 141.
        pub weight: f64,
        /// local time transaction entered pool in seconds since 1 Jan 1970 GMT
        #[serde(rename = "time")]
        pub transaction_time: i64,
        /// block height when transaction entered pool
        pub height: f64,
        /// number of in-mempool descendant transactions (including this one)
        #[serde(rename = "descendantcount")]
        pub descendant_count: f64,
        /// virtual transaction size of in-mempool descendants (including this one)
        #[serde(rename = "descendantsize")]
        pub descendant_size: f64,
        /// number of in-mempool ancestor transactions (including this one)
        #[serde(rename = "ancestorcount")]
        pub ancestor_count: f64,
        /// virtual transaction size of in-mempool ancestors (including this one)
        #[serde(rename = "ancestorsize")]
        pub ancestor_size: f64,
        /// hash of serialized transaction, including witness data
        pub wtxid: String,
        pub fees: GetMempoolAncestorsVariant1ValueFees,
        /// unconfirmed transactions used as inputs for this transaction
        pub depends: Vec<String>,
        /// unconfirmed transactions spending outputs from this transaction
        #[serde(rename = "spentby")]
        pub spent_by: Vec<String>,
        /// Whether this transaction signals BIP125 replaceability or has an unconfirmed ancestor signaling BIP125 replaceability. (DEPRECATED)
        #[serde(rename = "bip125-replaceable")]
        pub bip125_replaceable: bool,
        /// Whether this transaction is currently unbroadcast (initial broadcast not yet acknowledged by any peers)
        pub unbroadcast: bool,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[serde(untagged)]
    pub enum GetMempoolAncestors {
        /// for verbose = false
        Variant0(Vec<String>),
        /// for verbose = true
        Variant1(BTreeMap<String, GetMempoolAncestorsVariant1Value>),
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetMempoolDescendantsVariant1ValueFees {
        /// transaction fee, denominated in BTC
        #[serde(rename = "base")]
        pub base_fee: f64,
        /// transaction fee with fee deltas used for mining priority, denominated in BTC
        pub modified: f64,
        /// transaction fees of in-mempool ancestors (including this one) with fee deltas used for mining priority, denominated in BTC
        pub ancestor: f64,
        /// transaction fees of in-mempool descendants (including this one) with fee deltas used for mining priority, denominated in BTC
        pub descendant: f64,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetMempoolDescendantsVariant1Value {
        /// virtual transaction size as defined in BIP 141. This is different from actual serialized size for witness transactions as witness data is discounted.
        pub vsize: f64,
        /// transaction weight as defined in BIP 141.
        pub weight: f64,
        /// local time transaction entered pool in seconds since 1 Jan 1970 GMT
        #[serde(rename = "time")]
        pub transaction_time: i64,
        /// block height when transaction entered pool
        pub height: f64,
        /// number of in-mempool descendant transactions (including this one)
        #[serde(rename = "descendantcount")]
        pub descendant_count: f64,
        /// virtual transaction size of in-mempool descendants (including this one)
        #[serde(rename = "descendantsize")]
        pub descendant_size: f64,
        /// number of in-mempool ancestor transactions (including this one)
        #[serde(rename = "ancestorcount")]
        pub ancestor_count: f64,
        /// virtual transaction size of in-mempool ancestors (including this one)
        #[serde(rename = "ancestorsize")]
        pub ancestor_size: f64,
        /// hash of serialized transaction, including witness data
        pub wtxid: String,
        pub fees: GetMempoolDescendantsVariant1ValueFees,
        /// unconfirmed transactions used as inputs for this transaction
        pub depends: Vec<String>,
        /// unconfirmed transactions spending outputs from this transaction
        #[serde(rename = "spentby")]
        pub spent_by: Vec<String>,
        /// Whether this transaction signals BIP125 replaceability or has an unconfirmed ancestor signaling BIP125 replaceability. (DEPRECATED)
        #[serde(rename = "bip125-replaceable")]
        pub bip125_replaceable: bool,
        /// Whether this transaction is currently unbroadcast (initial broadcast not yet acknowledged by any peers)
        pub unbroadcast: bool,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[serde(untagged)]
    pub enum GetMempoolDescendants {
        /// for verbose = false
        Variant0(Vec<String>),
        /// for verbose = true
        Variant1(BTreeMap<String, GetMempoolDescendantsVariant1Value>),
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetMempoolEntryFees {
        /// transaction fee, denominated in BTC
        #[serde(rename = "base")]
        pub base_fee: f64,
        /// transaction fee with fee deltas used for mining priority, denominated in BTC
        pub modified: f64,
        /// transaction fees of in-mempool ancestors (including this one) with fee deltas used for mining priority, denominated in BTC
        pub ancestor: f64,
        /// transaction fees of in-mempool descendants (including this one) with fee deltas used for mining priority, denominated in BTC
        pub descendant: f64,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetMempoolEntry {
        /// virtual transaction size as defined in BIP 141. This is different from actual serialized size for witness transactions as witness data is discounted.
        pub vsize: f64,
        /// transaction weight as defined in BIP 141.
        pub weight: f64,
        /// local time transaction entered pool in seconds since 1 Jan 1970 GMT
        #[serde(rename = "time")]
        pub transaction_time: i64,
        /// block height when transaction entered pool
        pub height: f64,
        /// number of in-mempool descendant transactions (including this one)
        #[serde(rename = "descendantcount")]
        pub descendant_count: f64,
        /// virtual transaction size of in-mempool descendants (including this one)
        #[serde(rename = "descendantsize")]
        pub descendant_size: f64,
        /// number of in-mempool ancestor transactions (including this one)
        #[serde(rename = "ancestorcount")]
        pub ancestor_count: f64,
        /// virtual transaction size of in-mempool ancestors (including this one)
        #[serde(rename = "ancestorsize")]
        pub ancestor_size: f64,
        /// hash of serialized transaction, including witness data
        pub wtxid: String,
        pub fees: GetMempoolEntryFees,
        /// unconfirmed transactions used as inputs for this transaction
        pub depends: Vec<String>,
        /// unconfirmed transactions spending outputs from this transaction
        #[serde(rename = "spentby")]
        pub spent_by: Vec<String>,
        /// Whether this transaction signals BIP125 replaceability or has an unconfirmed ancestor signaling BIP125 replaceability. (DEPRECATED)
        #[serde(rename = "bip125-replaceable")]
        pub bip125_replaceable: bool,
        /// Whether this transaction is currently unbroadcast (initial broadcast not yet acknowledged by any peers)
        pub unbroadcast: bool,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetMempoolInfo {
        /// True if the initial load attempt of the persisted mempool finished
        pub loaded: bool,
        /// Current tx count
        pub size: f64,
        /// Sum of all virtual transaction sizes as defined in BIP 141. Differs from actual serialized size because witness data is discounted
        pub bytes: f64,
        /// Total memory usage for the mempool
        pub usage: f64,
        /// Total fees for the mempool in BTC, ignoring modified fees through prioritisetransaction
        pub total_fee: f64,
        /// Maximum memory usage for the mempool
        #[serde(rename = "maxmempool")]
        pub max_mempool: f64,
        /// Minimum fee rate in BTC/kvB for tx to be accepted. Is the maximum of minrelaytxfee and minimum mempool fee
        #[serde(rename = "mempoolminfee")]
        pub mempool_min_fee: f64,
        /// Current minimum relay fee for transactions
        #[serde(rename = "minrelaytxfee")]
        pub min_relay_tx_fee: f64,
        /// minimum fee rate increment for mempool limiting or replacement in BTC/kvB
        #[serde(rename = "incrementalrelayfee")]
        pub incremental_relay_fee: f64,
        /// Current number of transactions that haven't passed initial broadcast yet
        #[serde(rename = "unbroadcastcount")]
        pub unbroadcast_count: f64,
        /// True if the mempool accepts RBF without replaceability signaling inspection (DEPRECATED)
        #[serde(rename = "fullrbf")]
        pub full_rbf: bool,
        /// True if the mempool accepts transactions with bare multisig outputs
        #[serde(rename = "permitbaremultisig")]
        pub permit_bare_multisig: bool,
        /// Maximum number of bytes that can be used by OP_RETURN outputs in the mempool
        #[serde(rename = "maxdatacarriersize")]
        pub max_data_carrier_size: f64,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetMiningInfoNext {
        /// The next height
        pub height: f64,
        /// The next target nBits
        pub bits: String,
        /// The next difficulty
        pub difficulty: f64,
        /// The next target
        pub target: String,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetMiningInfo {
        /// The current block
        pub blocks: f64,
        /// The block weight (including reserved weight for block header, txs count and coinbase tx) of the last assembled block (only present if a block was ever assembled)
        #[serde(rename = "currentblockweight")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub current_block_weight: Option<f64>,
        /// The number of block transactions (excluding coinbase) of the last assembled block (only present if a block was ever assembled)
        #[serde(rename = "currentblocktx")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub current_block_tx: Option<f64>,
        /// The current nBits, compact representation of the block difficulty target
        pub bits: String,
        /// The current difficulty
        pub difficulty: f64,
        /// The current target
        pub target: String,
        /// The network hashes per second
        #[serde(rename = "networkhashps")]
        pub network_hash_ps: f64,
        /// The size of the mempool
        #[serde(rename = "pooledtx")]
        pub pooled_tx: f64,
        /// Minimum feerate of packages selected for block inclusion in BTC/kvB
        #[serde(rename = "blockmintxfee")]
        pub block_min_tx_fee: f64,
        /// current network name (main, test, testnet4, signet, regtest)
        pub chain: String,
        /// The block challenge (aka. block script), in hexadecimal (only present if the current network is a signet)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub signet_challenge: Option<String>,
        /// The next block
        pub next: GetMiningInfoNext,
        /// any network and blockchain warnings (run with `-deprecatedrpc=warnings` to return the latest warning as a single string)
        pub warnings: Vec<String>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetNetTotalsUploadTarget {
        /// Length of the measuring timeframe in seconds
        pub timeframe: f64,
        /// Target in bytes
        pub target: f64,
        /// True if target is reached
        pub target_reached: bool,
        /// True if serving historical blocks
        pub serve_historical_blocks: bool,
        /// Bytes left in current time cycle
        pub bytes_left_in_cycle: f64,
        /// Seconds left in current time cycle
        pub time_left_in_cycle: f64,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetNetTotals {
        /// Total bytes received
        #[serde(rename = "totalbytesrecv")]
        pub total_bytes_received: f64,
        /// Total bytes sent
        #[serde(rename = "totalbytessent")]
        pub total_bytes_sent: f64,
        /// Current system UNIX epoch time in milliseconds
        #[serde(rename = "timemillis")]
        pub time_millis: i64,
        #[serde(rename = "uploadtarget")]
        pub upload_target: GetNetTotalsUploadTarget,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetNetworkInfoNetworksItem {
        /// network (ipv4, ipv6, onion, i2p, cjdns)
        pub name: String,
        /// is the network limited using -onlynet?
        pub limited: bool,
        /// is the network reachable?
        pub reachable: bool,
        /// ("host:port") the proxy that is used for this network, or empty if none
        pub proxy: String,
        /// Whether randomized credentials are used
        pub proxy_randomize_credentials: bool,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetNetworkInfoLocalAddressesItem {
        /// network address
        pub address: String,
        /// network port
        pub port: f64,
        /// relative score
        pub score: f64,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetNetworkInfo {
        /// the server version
        pub version: f64,
        /// the server subversion string
        pub subversion: String,
        /// the protocol version
        #[serde(rename = "protocolversion")]
        pub protocol_version: f64,
        /// the services we offer to the network
        #[serde(rename = "localservices")]
        pub local_services: String,
        /// the services we offer to the network, in human-readable form
        #[serde(rename = "localservicesnames")]
        pub local_services_names: Vec<String>,
        /// true if transaction relay is requested from peers
        #[serde(rename = "localrelay")]
        pub local_relay: bool,
        /// the time offset
        #[serde(rename = "timeoffset")]
        pub time_offset: f64,
        /// the total number of connections
        pub connections: f64,
        /// the number of inbound connections
        pub connections_in: f64,
        /// the number of outbound connections
        pub connections_out: f64,
        /// whether p2p networking is enabled
        #[serde(rename = "networkactive")]
        pub network_active: bool,
        /// information per network
        pub networks: Vec<GetNetworkInfoNetworksItem>,
        /// minimum relay fee rate for transactions in BTC/kvB
        #[serde(rename = "relayfee")]
        pub relay_fee: f64,
        /// minimum fee rate increment for mempool limiting or replacement in BTC/kvB
        #[serde(rename = "incrementalfee")]
        pub incremental_fee: f64,
        /// list of local addresses
        #[serde(rename = "localaddresses")]
        pub local_addresses: Vec<GetNetworkInfoLocalAddressesItem>,
        /// any network and blockchain warnings (run with `-deprecatedrpc=warnings` to return the latest warning as a single string)
        pub warnings: Vec<String>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetNodeAddressesItem {
        /// The UNIX epoch time when the node was last seen
        #[serde(rename = "time")]
        pub transaction_time: i64,
        /// The services offered by the node
        pub services: f64,
        /// The address of the node
        pub address: String,
        /// The port number of the node
        pub port: f64,
        /// The network (ipv4, ipv6, onion, i2p, cjdns) the node connected through
        pub network: String,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetOrphanTxsVariant1Item {
        /// The transaction hash in hex
        pub txid: String,
        /// The transaction witness hash in hex
        pub wtxid: String,
        /// The serialized transaction size in bytes
        pub bytes: f64,
        /// The virtual transaction size as defined in BIP 141. This is different from actual serialized size for witness transactions as witness data is discounted.
        pub vsize: f64,
        /// The transaction weight as defined in BIP 141.
        pub weight: f64,
        pub from: Vec<f64>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetOrphanTxsVariant2Item {
        /// The transaction hash in hex
        pub txid: String,
        /// The transaction witness hash in hex
        pub wtxid: String,
        /// The serialized transaction size in bytes
        pub bytes: f64,
        /// The virtual transaction size as defined in BIP 141. This is different from actual serialized size for witness transactions as witness data is discounted.
        pub vsize: f64,
        /// The transaction weight as defined in BIP 141.
        pub weight: f64,
        pub from: Vec<f64>,
        /// The serialized, hex-encoded transaction data
        pub hex: String,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[serde(untagged)]
    pub enum GetOrphanTxs {
        /// for verbose = 0
        Variant0(Vec<String>),
        /// for verbose = 1
        Variant1(Vec<GetOrphanTxsVariant1Item>),
        /// for verbose = 2
        Variant2(Vec<GetOrphanTxsVariant2Item>),
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetPeerInfoItem {
        /// Peer index
        pub id: f64,
        /// (host:port) The IP address and port of the peer
        #[serde(rename = "addr")]
        pub address: String,
        /// (ip:port) Bind address of the connection to the peer
        #[serde(rename = "addrbind")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub address_bind: Option<String>,
        /// (ip:port) Local address as reported by the peer
        #[serde(rename = "addrlocal")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub address_local: Option<String>,
        /// Network (ipv4, ipv6, onion, i2p, cjdns, not_publicly_routable)
        pub network: String,
        /// Mapped AS (Autonomous System) number at the end of the BGP route to the peer, used for diversifying
        /// peer selection (only displayed if the -asmap config option is set)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub mapped_as: Option<f64>,
        /// The services offered
        pub services: String,
        /// the services offered, in human-readable form
        #[serde(rename = "servicesnames")]
        pub services_names: Vec<String>,
        /// Whether we relay transactions to this peer
        #[serde(rename = "relaytxes")]
        pub relay_transactions: bool,
        /// The UNIX epoch time of the last send
        #[serde(rename = "lastsend")]
        pub last_send: i64,
        /// The UNIX epoch time of the last receive
        #[serde(rename = "lastrecv")]
        pub last_received: i64,
        /// The UNIX epoch time of the last valid transaction received from this peer
        pub last_transaction: i64,
        /// The UNIX epoch time of the last block received from this peer
        pub last_block: i64,
        /// The total bytes sent
        #[serde(rename = "bytessent")]
        pub bytes_sent: f64,
        /// The total bytes received
        #[serde(rename = "bytesrecv")]
        pub bytes_received: f64,
        /// The UNIX epoch time of the connection
        #[serde(rename = "conntime")]
        pub connection_time: i64,
        /// The time offset in seconds
        #[serde(rename = "timeoffset")]
        pub time_offset: f64,
        /// The last ping time in seconds, if any
        #[serde(rename = "pingtime")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ping_time: Option<f64>,
        /// The minimum observed ping time in seconds, if any
        #[serde(rename = "minping")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub minimum_ping: Option<f64>,
        /// The duration in seconds of an outstanding ping (if non-zero)
        #[serde(rename = "pingwait")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ping_wait: Option<f64>,
        /// The peer version, such as 70001
        pub version: f64,
        /// The string version
        #[serde(rename = "subver")]
        pub subversion: String,
        /// Inbound (true) or Outbound (false)
        pub inbound: bool,
        /// Whether we selected peer as (compact blocks) high-bandwidth peer
        pub bip152_hb_to: bool,
        /// Whether peer selected us as (compact blocks) high-bandwidth peer
        pub bip152_hb_from: bool,
        /// The starting height (block) of the peer
        #[serde(rename = "startingheight")]
        pub starting_height: f64,
        /// The current height of header pre-synchronization with this peer, or -1 if no low-work sync is in progress
        pub presynced_headers: f64,
        /// The last header we have in common with this peer
        pub synced_headers: f64,
        /// The last block we have in common with this peer
        pub synced_blocks: f64,
        pub inflight: Vec<f64>,
        /// Whether we participate in address relay with this peer
        #[serde(rename = "addr_relay_enabled")]
        pub addresses_relay_enabled: bool,
        /// The total number of addresses processed, excluding those dropped due to rate limiting
        #[serde(rename = "addr_processed")]
        pub addresses_processed: f64,
        /// The total number of addresses dropped due to rate limiting
        #[serde(rename = "addr_rate_limited")]
        pub addresses_rate_limited: f64,
        /// Any special permissions that have been granted to this peer
        pub permissions: Vec<String>,
        /// The minimum fee rate for transactions this peer accepts
        #[serde(rename = "minfeefilter")]
        pub minimum_fee_filter: f64,
        #[serde(rename = "bytessent_per_msg")]
        pub bytes_sent_per_message: BTreeMap<String, f64>,
        #[serde(rename = "bytesrecv_per_msg")]
        pub bytes_received_per_message: BTreeMap<String, f64>,
        /// Type of connection:
        /// outbound-full-relay (default automatic connections),
        /// block-relay-only (does not relay transactions or addresses),
        /// inbound (initiated by the peer),
        /// manual (added via addnode RPC or -addnode/-connect configuration options),
        /// addr-fetch (short-lived automatic connection for soliciting addresses),
        /// feeler (short-lived automatic connection for testing addresses).
        /// Please note this output is unlikely to be stable in upcoming releases as we iterate to
        /// best capture connection behaviors.
        pub connection_type: String,
        /// Type of transport protocol:
        /// detecting (peer could be v1 or v2),
        /// v1 (plaintext transport protocol),
        /// v2 (BIP324 encrypted transport protocol).
        pub transport_protocol_type: String,
        /// The session ID for this connection, or "" if there is none ("v2" transport protocol only).
        pub session_id: String,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetPrioritisedTransactionsValue {
        /// transaction fee delta in satoshis
        pub fee_delta: f64,
        /// whether this transaction is currently in mempool
        pub in_mempool: bool,
        /// modified fee in satoshis. Only returned if in_mempool=true
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub modified_fee: Option<f64>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetRawAddrmanValueValue {
        /// The address of the node
        pub address: String,
        /// Mapped AS (Autonomous System) number at the end of the BGP route to the peer, used for diversifying peer selection (only displayed if the -asmap config option is set)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub mapped_as: Option<f64>,
        /// The port number of the node
        pub port: f64,
        /// The network (ipv4, ipv6, onion, i2p, cjdns) of the address
        pub network: String,
        /// The services offered by the node
        pub services: f64,
        /// The UNIX epoch time when the node was last seen
        #[serde(rename = "time")]
        pub transaction_time: i64,
        /// The address that relayed the address to us
        pub source: String,
        /// The network (ipv4, ipv6, onion, i2p, cjdns) of the source address
        pub source_network: String,
        /// Mapped AS (Autonomous System) number at the end of the BGP route to the source, used for diversifying peer selection (only displayed if the -asmap config option is set)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub source_mapped_as: Option<f64>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetRawMempoolVariant1ValueFees {
        /// transaction fee, denominated in BTC
        #[serde(rename = "base")]
        pub base_fee: f64,
        /// transaction fee with fee deltas used for mining priority, denominated in BTC
        pub modified: f64,
        /// transaction fees of in-mempool ancestors (including this one) with fee deltas used for mining priority, denominated in BTC
        pub ancestor: f64,
        /// transaction fees of in-mempool descendants (including this one) with fee deltas used for mining priority, denominated in BTC
        pub descendant: f64,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetRawMempoolVariant1Value {
        /// virtual transaction size as defined in BIP 141. This is different from actual serialized size for witness transactions as witness data is discounted.
        pub vsize: f64,
        /// transaction weight as defined in BIP 141.
        pub weight: f64,
        /// local time transaction entered pool in seconds since 1 Jan 1970 GMT
        #[serde(rename = "time")]
        pub transaction_time: i64,
        /// block height when transaction entered pool
        pub height: f64,
        /// number of in-mempool descendant transactions (including this one)
        #[serde(rename = "descendantcount")]
        pub descendant_count: f64,
        /// virtual transaction size of in-mempool descendants (including this one)
        #[serde(rename = "descendantsize")]
        pub descendant_size: f64,
        /// number of in-mempool ancestor transactions (including this one)
        #[serde(rename = "ancestorcount")]
        pub ancestor_count: f64,
        /// virtual transaction size of in-mempool ancestors (including this one)
        #[serde(rename = "ancestorsize")]
        pub ancestor_size: f64,
        /// hash of serialized transaction, including witness data
        pub wtxid: String,
        pub fees: GetRawMempoolVariant1ValueFees,
        /// unconfirmed transactions used as inputs for this transaction
        pub depends: Vec<String>,
        /// unconfirmed transactions spending outputs from this transaction
        #[serde(rename = "spentby")]
        pub spent_by: Vec<String>,
        /// Whether this transaction signals BIP125 replaceability or has an unconfirmed ancestor signaling BIP125 replaceability. (DEPRECATED)
        #[serde(rename = "bip125-replaceable")]
        pub bip125_replaceable: bool,
        /// Whether this transaction is currently unbroadcast (initial broadcast not yet acknowledged by any peers)
        pub unbroadcast: bool,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetRawMempoolVariant2 {
        pub txids: Vec<String>,
        /// The mempool sequence value.
        pub mempool_sequence: f64,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[serde(untagged)]
    pub enum GetRawMempool {
        /// for verbose = false
        Variant0(Vec<String>),
        /// for verbose = true
        Variant1(BTreeMap<String, GetRawMempoolVariant1Value>),
        /// for verbose = false and mempool_sequence = true
        Variant2(GetRawMempoolVariant2),
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetRawTransactionVariant1InputsItemScriptSig {
        /// Disassembly of the signature script
        pub asm: String,
        /// The raw signature script bytes, hex-encoded
        pub hex: String,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetRawTransactionVariant1InputsItem {
        /// The coinbase value (only if coinbase transaction)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub coinbase: Option<String>,
        /// The transaction id (if not coinbase transaction)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub txid: Option<String>,
        /// The output number (if not coinbase transaction)
        #[serde(rename = "vout")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub outputs: Option<f64>,
        /// The script (if not coinbase transaction)
        #[serde(rename = "scriptSig")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub script_sig: Option<GetRawTransactionVariant1InputsItemScriptSig>,
        #[serde(rename = "txinwitness")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub txin_witness: Option<Vec<String>>,
        /// The script sequence number
        pub sequence: f64,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetRawTransactionVariant1OutputsItemScriptPubkey {
        /// Disassembly of the output script
        pub asm: String,
        /// Inferred descriptor for the output
        #[serde(rename = "desc")]
        pub descriptor: String,
        /// The raw output script bytes, hex-encoded
        pub hex: String,
        /// The Bitcoin address (only if a well-defined address exists)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub address: Option<String>,
        /// The type (one of: nonstandard, anchor, pubkey, pubkeyhash, scripthash, multisig, nulldata, witness_v0_scripthash, witness_v0_keyhash, witness_v1_taproot, witness_unknown)
        #[serde(rename = "type")]
        pub type_: String,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetRawTransactionVariant1OutputsItem {
        /// The value in BTC
        pub value: f64,
        /// index
        #[serde(rename = "n")]
        pub index: f64,
        #[serde(rename = "scriptPubKey")]
        pub script_pubkey: GetRawTransactionVariant1OutputsItemScriptPubkey,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetRawTransactionVariant1 {
        /// Whether specified block is in the active chain or not (only present with explicit "blockhash" argument)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub in_active_chain: Option<bool>,
        /// the block hash
        #[serde(rename = "blockhash")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub block_hash: Option<String>,
        /// The confirmations
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub confirmations: Option<f64>,
        /// The block time expressed in UNIX epoch time
        #[serde(rename = "blocktime")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub block_time: Option<i64>,
        /// Same as "blocktime"
        #[serde(rename = "time")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub transaction_time: Option<f64>,
        /// The serialized, hex-encoded data for 'txid'
        pub hex: String,
        /// The transaction id (same as provided)
        pub txid: String,
        /// The transaction hash (differs from txid for witness transactions)
        pub hash: String,
        /// The serialized transaction size
        pub size: f64,
        /// The virtual transaction size (differs from size for witness transactions)
        pub vsize: f64,
        /// The transaction's weight (between vsize*4-3 and vsize*4)
        pub weight: f64,
        /// The version
        pub version: f64,
        /// The lock time
        #[serde(rename = "locktime")]
        pub lock_time: i64,
        #[serde(rename = "vin")]
        pub inputs: Vec<GetRawTransactionVariant1InputsItem>,
        #[serde(rename = "vout")]
        pub outputs: Vec<GetRawTransactionVariant1OutputsItem>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetRawTransactionVariant2InputsItemPrevoutScriptPubkey {
        /// Disassembly of the output script
        pub asm: String,
        /// Inferred descriptor for the output
        #[serde(rename = "desc")]
        pub descriptor: String,
        /// The raw output script bytes, hex-encoded
        pub hex: String,
        /// The Bitcoin address (only if a well-defined address exists)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub address: Option<String>,
        /// The type (one of: nonstandard, anchor, pubkey, pubkeyhash, scripthash, multisig, nulldata, witness_v0_scripthash, witness_v0_keyhash, witness_v1_taproot, witness_unknown)
        #[serde(rename = "type")]
        pub type_: String,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetRawTransactionVariant2InputsItemPrevout {
        /// Coinbase or not
        pub generated: bool,
        /// The height of the prevout
        pub height: f64,
        /// The value in BTC
        pub value: f64,
        #[serde(rename = "scriptPubKey")]
        pub script_pubkey: GetRawTransactionVariant2InputsItemPrevoutScriptPubkey,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetRawTransactionVariant2InputsItem {
        /// The previous output, omitted if block undo data is not available
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub prevout: Option<GetRawTransactionVariant2InputsItemPrevout>,
        /// Additional properties
        #[serde(flatten)]
        pub extra: BTreeMap<String, Value>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetRawTransactionVariant2 {
        /// transaction fee in BTC, omitted if block undo data is not available
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fee: Option<f64>,
        #[serde(rename = "vin")]
        pub inputs: Vec<GetRawTransactionVariant2InputsItem>,
        /// Additional properties
        #[serde(flatten)]
        pub extra: BTreeMap<String, Value>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[serde(untagged)]
    pub enum GetRawTransaction {
        /// The serialized transaction as a hex-encoded string for 'txid'
        Variant0(String),
        /// if verbosity is set to 1
        Variant1(GetRawTransactionVariant1),
        /// for verbosity = 2
        Variant2(GetRawTransactionVariant2),
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetRpcInfoActiveCommandsItem {
        /// The name of the RPC command
        pub method: String,
        /// The running time in microseconds
        pub duration: f64,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetRpcInfo {
        /// All active commands
        pub active_commands: Vec<GetRpcInfoActiveCommandsItem>,
        /// The complete file path to the debug log
        #[serde(rename = "logpath")]
        pub log_path: String,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetTransactionDetailsItem {
        /// The bitcoin address involved in the transaction.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub address: Option<String>,
        /// The transaction category.
        /// "send"                  Transactions sent.
        /// "receive"               Non-coinbase transactions received.
        /// "generate"              Coinbase transactions received with more than 100 confirmations.
        /// "immature"              Coinbase transactions received with 100 or fewer confirmations.
        /// "orphan"                Orphaned coinbase transactions received.
        pub category: String,
        /// The amount in BTC
        pub amount: f64,
        /// A comment for the address/transaction, if any
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub label: Option<String>,
        /// the vout value
        #[serde(rename = "vout")]
        pub outputs: f64,
        /// The amount of the fee in BTC. This is negative and only available for the
        /// 'send' category of transactions.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fee: Option<f64>,
        /// 'true' if the transaction has been abandoned (inputs are respendable).
        pub abandoned: bool,
        /// Only if 'category' is 'received'. List of parent descriptors for the output script of this coin.
        #[serde(rename = "parent_descs")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub parent_descriptors: Option<Vec<String>>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetTransactionLastProcessedBlock {
        /// hash of the block this information was generated on
        pub hash: String,
        /// height of the block this information was generated on
        pub height: f64,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetTransaction {
        /// The amount in BTC
        pub amount: f64,
        /// The amount of the fee in BTC. This is negative and only available for the
        /// 'send' category of transactions.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fee: Option<f64>,
        /// The number of confirmations for the transaction. Negative confirmations means the
        /// transaction conflicted that many blocks ago.
        pub confirmations: f64,
        /// Only present if the transaction's only input is a coinbase one.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub generated: Option<bool>,
        /// Whether we consider the transaction to be trusted and safe to spend from.
        /// Only present when the transaction has 0 confirmations (or negative confirmations, if conflicted).
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub trusted: Option<bool>,
        /// The block hash containing the transaction.
        #[serde(rename = "blockhash")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub block_hash: Option<String>,
        /// The block height containing the transaction.
        #[serde(rename = "blockheight")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub block_height: Option<f64>,
        /// The index of the transaction in the block that includes it.
        #[serde(rename = "blockindex")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub block_index: Option<f64>,
        /// The block time expressed in UNIX epoch time.
        #[serde(rename = "blocktime")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub block_time: Option<i64>,
        /// The transaction id.
        pub txid: String,
        /// The hash of serialized transaction, including witness data.
        pub wtxid: String,
        /// Confirmed transactions that have been detected by the wallet to conflict with this transaction.
        #[serde(rename = "walletconflicts")]
        pub wallet_conflicts: Vec<String>,
        /// Only if 'category' is 'send'. The txid if this tx was replaced.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub replaced_by_txid: Option<String>,
        /// Only if 'category' is 'send'. The txid if this tx replaces another.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub replaces_txid: Option<String>,
        /// Transactions in the mempool that directly conflict with either this transaction or an ancestor transaction
        #[serde(rename = "mempoolconflicts")]
        pub mempool_conflicts: Vec<String>,
        /// If a comment to is associated with the transaction.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub to: Option<String>,
        /// The transaction time expressed in UNIX epoch time.
        #[serde(rename = "time")]
        pub transaction_time: i64,
        /// The time received expressed in UNIX epoch time.
        #[serde(rename = "timereceived")]
        pub time_received: i64,
        /// If a comment is associated with the transaction, only present if not empty.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub comment: Option<String>,
        /// ("yes|no|unknown") Whether this transaction signals BIP125 replaceability or has an unconfirmed ancestor signaling BIP125 replaceability.
        /// May be unknown for unconfirmed transactions not in the mempool because their unconfirmed ancestors are unknown.
        #[serde(rename = "bip125-replaceable")]
        pub bip125_replaceable: String,
        /// Only if 'category' is 'received'. List of parent descriptors for the output script of this coin.
        #[serde(rename = "parent_descs")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub parent_descriptors: Option<Vec<String>>,
        pub details: Vec<GetTransactionDetailsItem>,
        /// Raw data for transaction
        pub hex: String,
        /// The decoded transaction (only present when `verbose` is passed)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub decoded: Option<BTreeMap<String, Value>>,
        /// hash and height of the block this information was generated on
        #[serde(rename = "lastprocessedblock")]
        pub last_processed_block: GetTransactionLastProcessedBlock,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetTxOutScriptPubkey {
        /// Disassembly of the output script
        pub asm: String,
        /// Inferred descriptor for the output
        #[serde(rename = "desc")]
        pub descriptor: String,
        /// The raw output script bytes, hex-encoded
        pub hex: String,
        /// The type, eg pubkeyhash
        #[serde(rename = "type")]
        pub type_: String,
        /// The Bitcoin address (only if a well-defined address exists)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub address: Option<String>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetTxOut {
        /// The hash of the block at the tip of the chain
        #[serde(rename = "bestblock")]
        pub best_block: String,
        /// The number of confirmations
        pub confirmations: f64,
        /// The transaction value in BTC
        pub value: f64,
        #[serde(rename = "scriptPubKey")]
        pub script_pubkey: GetTxOutScriptPubkey,
        /// Coinbase or not
        pub coinbase: bool,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetTxOutSetInfoBlockInfoUnspendables {
        /// The unspendable amount of the Genesis block subsidy
        pub genesis_block: f64,
        /// Transactions overridden by duplicates (no longer possible with BIP30)
        pub bip30: f64,
        /// Amounts sent to scripts that are unspendable (for example OP_RETURN outputs)
        pub scripts: f64,
        /// Fee rewards that miners did not claim in their coinbase transaction
        pub unclaimed_rewards: f64,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetTxOutSetInfoBlockInfo {
        /// Total amount of all prevouts spent in this block
        pub prevout_spent: f64,
        /// Coinbase subsidy amount of this block
        pub coinbase: f64,
        /// Total amount of new outputs created by this block
        pub new_outputs_ex_coinbase: f64,
        /// Total amount of unspendable outputs created in this block
        pub unspendable: f64,
        /// Detailed view of the unspendable categories
        pub unspendables: GetTxOutSetInfoBlockInfoUnspendables,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetTxOutSetInfo {
        /// The block height (index) of the returned statistics
        pub height: f64,
        /// The hash of the block at which these statistics are calculated
        #[serde(rename = "bestblock")]
        pub best_block: String,
        /// The number of unspent transaction outputs
        #[serde(rename = "txouts")]
        pub tx_outs: f64,
        /// Database-independent, meaningless metric indicating the UTXO set size
        #[serde(rename = "bogosize")]
        pub bogo_size: f64,
        /// The serialized hash (only present if 'hash_serialized_3' hash_type is chosen)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub hash_serialized_3: Option<String>,
        /// The serialized hash (only present if 'muhash' hash_type is chosen)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub muhash: Option<String>,
        /// The number of transactions with unspent outputs (not available when coinstatsindex is used)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub transactions: Option<f64>,
        /// The estimated size of the chainstate on disk (not available when coinstatsindex is used)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub disk_size: Option<f64>,
        /// The total amount of coins in the UTXO set
        pub total_amount: f64,
        /// The total amount of coins permanently excluded from the UTXO set (only available if coinstatsindex is used)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub total_unspendable_amount: Option<f64>,
        /// Info on amounts in the block at this block height (only available if coinstatsindex is used)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub block_info: Option<GetTxOutSetInfoBlockInfo>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetTxSpendingPrevoutOutputsItem {
        /// The transaction id
        pub txid: String,
        /// The output number
        #[serde(rename = "vout")]
        pub outputs: f64,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetTxSpendingPrevoutItem {
        /// the transaction id of the checked output
        pub txid: String,
        /// the vout value of the checked output
        #[serde(rename = "vout")]
        pub outputs: f64,
        /// the transaction id of the mempool transaction spending this output (omitted if unspent)
        #[serde(rename = "spendingtxid")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub spending_txid: Option<String>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetWalletInfoScanning {
        /// elapsed seconds since scan start
        pub duration: f64,
        /// scanning progress percentage [0.0, 1.0]
        pub progress: f64,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetWalletInfoLastProcessedBlock {
        /// hash of the block this information was generated on
        pub hash: String,
        /// height of the block this information was generated on
        pub height: f64,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct GetWalletInfo {
        /// the wallet name
        #[serde(rename = "walletname")]
        pub wallet_name: String,
        /// (DEPRECATED) only related to unsupported legacy wallet, returns the latest version 169900 for backwards compatibility
        #[serde(rename = "walletversion")]
        pub wallet_version: f64,
        /// the database format (only sqlite)
        pub format: String,
        /// the total number of transactions in the wallet
        #[serde(rename = "txcount")]
        pub tx_count: f64,
        /// how many new keys are pre-generated (only counts external keys)
        #[serde(rename = "keypoolsize")]
        pub keypool_size: f64,
        /// how many new keys are pre-generated for internal use (used for change outputs, only appears if the wallet is using this feature, otherwise external keys are used)
        #[serde(rename = "keypoolsize_hd_internal")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub keypool_size_hd_internal: Option<f64>,
        /// the UNIX epoch time until which the wallet is unlocked for transfers, or 0 if the wallet is locked (only present for passphrase-encrypted wallets)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub unlocked_until: Option<i64>,
        /// the transaction fee configuration, set in BTC/kvB
        #[serde(rename = "paytxfee")]
        pub pay_tx_fee: f64,
        /// false if privatekeys are disabled for this wallet (enforced watch-only wallet)
        pub private_keys_enabled: bool,
        /// whether this wallet tracks clean/dirty coins in terms of reuse
        pub avoid_reuse: bool,
        /// current scanning details, or false if no scan is in progress
        pub scanning: GetWalletInfoScanning,
        /// whether this wallet uses descriptors for output script management
        pub descriptors: bool,
        /// whether this wallet is configured to use an external signer such as a hardware wallet
        pub external_signer: bool,
        /// Whether this wallet intentionally does not contain any keys, scripts, or descriptors
        pub blank: bool,
        /// The start time for blocks scanning. It could be modified by (re)importing any descriptor with an earlier timestamp.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub birthtime: Option<i64>,
        /// The flags currently set on the wallet
        pub flags: Vec<String>,
        /// hash and height of the block this information was generated on
        #[serde(rename = "lastprocessedblock")]
        pub last_processed_block: GetWalletInfoLastProcessedBlock,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct ImportDescriptorsRequestsItem {
        /// Descriptor to import.
        #[serde(rename = "desc")]
        pub descriptor: String,
        /// Set this descriptor to be the active descriptor for the corresponding output type/externality
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub active: Option<bool>,
        /// If a ranged descriptor is used, this specifies the end or the range (in the form [begin,end]) to import
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub range: Option<RangeParam>,
        /// If a ranged descriptor is set to active, this specifies the next index to generate addresses from
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_index: Option<f64>,
        /// Time from which to start rescanning the blockchain for this descriptor, in UNIX epoch time
        /// Use the string "now" to substitute the current synced blockchain time.
        /// "now" can be specified to bypass scanning, for outputs which are known to never have been used, and
        /// 0 can be specified to scan the entire blockchain. Blocks up to 2 hours before the earliest timestamp
        /// of all descriptors being imported will be scanned as well as the mempool.
        pub timestamp: f64,
        /// Whether matching outputs should be treated as not incoming payments (e.g. change)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub internal: Option<bool>,
        /// Label to assign to the address, only allowed with internal=false. Disabled for ranged descriptors
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub label: Option<String>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct ImportDescriptorsItem {
        pub success: bool,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub warnings: Option<Vec<String>>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub error: Option<BTreeMap<String, Value>>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct ImportMempoolOptions {
        /// Whether to use the current system time or use the entry time metadata from the mempool file.
        /// Warning: Importing untrusted metadata may lead to unexpected issues and undesirable behavior.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub use_current_time: Option<bool>,
        /// Whether to apply the fee delta metadata from the mempool file.
        /// It will be added to any existing fee deltas.
        /// The fee delta can be set by the prioritisetransaction RPC.
        /// Warning: Importing untrusted metadata may lead to unexpected issues and undesirable behavior.
        /// Only set this bool if you understand what it does.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub apply_fee_delta_priority: Option<bool>,
        /// Whether to apply the unbroadcast set metadata from the mempool file.
        /// Warning: Importing untrusted metadata may lead to unexpected issues and undesirable behavior.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub apply_unbroadcast_set: Option<bool>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct ListBannedItem {
        /// The IP/Subnet of the banned node
        pub address: String,
        /// The UNIX epoch time the ban was created
        pub ban_created: i64,
        /// The UNIX epoch time the ban expires
        pub banned_until: i64,
        /// The ban duration, in seconds
        pub ban_duration: i64,
        /// The time remaining until the ban expires, in seconds
        pub time_remaining: i64,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct ListDescriptorsDescriptorsItem {
        /// Descriptor string representation
        #[serde(rename = "desc")]
        pub descriptor: String,
        /// The creation time of the descriptor
        pub timestamp: f64,
        /// Whether this descriptor is currently used to generate new addresses
        pub active: bool,
        /// True if this descriptor is used to generate change addresses. False if this descriptor is used to generate receiving addresses; defined only for active descriptors
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub internal: Option<bool>,
        /// Defined only for ranged descriptors
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub range: Option<Vec<Value>>,
        /// Same as next_index field. Kept for compatibility reason.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next: Option<f64>,
        /// The next index to generate addresses from; defined only for ranged descriptors
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_index: Option<f64>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct ListDescriptors {
        /// Name of wallet this operation was performed on
        pub wallet_name: String,
        /// Array of descriptor objects (sorted by descriptor string representation)
        pub descriptors: Vec<ListDescriptorsDescriptorsItem>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct ListLockUnspentItem {
        /// The transaction id locked
        pub txid: String,
        /// The vout value
        #[serde(rename = "vout")]
        pub outputs: f64,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct ListReceivedByAddressItem {
        /// The receiving address
        pub address: String,
        /// The total amount in BTC received by the address
        pub amount: f64,
        /// The number of confirmations of the most recent transaction included
        pub confirmations: f64,
        /// The label of the receiving address. The default label is ""
        pub label: String,
        pub txids: Vec<String>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct ListReceivedByLabelItem {
        /// The total amount received by addresses with this label
        pub amount: f64,
        /// The number of confirmations of the most recent transaction included
        pub confirmations: f64,
        /// The label of the receiving address. The default label is ""
        pub label: String,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct ListSinceBlockTransactionsItem {
        /// The bitcoin address of the transaction (not returned if the output does not have an address, e.g. OP_RETURN null data).
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub address: Option<String>,
        /// The transaction category.
        /// "send"                  Transactions sent.
        /// "receive"               Non-coinbase transactions received.
        /// "generate"              Coinbase transactions received with more than 100 confirmations.
        /// "immature"              Coinbase transactions received with 100 or fewer confirmations.
        /// "orphan"                Orphaned coinbase transactions received.
        pub category: String,
        /// The amount in BTC. This is negative for the 'send' category, and is positive
        /// for all other categories
        pub amount: f64,
        /// the vout value
        #[serde(rename = "vout")]
        pub outputs: f64,
        /// The amount of the fee in BTC. This is negative and only available for the
        /// 'send' category of transactions.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fee: Option<f64>,
        /// The number of confirmations for the transaction. Negative confirmations means the
        /// transaction conflicted that many blocks ago.
        pub confirmations: f64,
        /// Only present if the transaction's only input is a coinbase one.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub generated: Option<bool>,
        /// Whether we consider the transaction to be trusted and safe to spend from.
        /// Only present when the transaction has 0 confirmations (or negative confirmations, if conflicted).
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub trusted: Option<bool>,
        /// The block hash containing the transaction.
        #[serde(rename = "blockhash")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub block_hash: Option<String>,
        /// The block height containing the transaction.
        #[serde(rename = "blockheight")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub block_height: Option<f64>,
        /// The index of the transaction in the block that includes it.
        #[serde(rename = "blockindex")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub block_index: Option<f64>,
        /// The block time expressed in UNIX epoch time.
        #[serde(rename = "blocktime")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub block_time: Option<i64>,
        /// The transaction id.
        pub txid: String,
        /// The hash of serialized transaction, including witness data.
        pub wtxid: String,
        /// Confirmed transactions that have been detected by the wallet to conflict with this transaction.
        #[serde(rename = "walletconflicts")]
        pub wallet_conflicts: Vec<String>,
        /// Only if 'category' is 'send'. The txid if this tx was replaced.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub replaced_by_txid: Option<String>,
        /// Only if 'category' is 'send'. The txid if this tx replaces another.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub replaces_txid: Option<String>,
        /// Transactions in the mempool that directly conflict with either this transaction or an ancestor transaction
        #[serde(rename = "mempoolconflicts")]
        pub mempool_conflicts: Vec<String>,
        /// If a comment to is associated with the transaction.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub to: Option<String>,
        /// The transaction time expressed in UNIX epoch time.
        #[serde(rename = "time")]
        pub transaction_time: i64,
        /// The time received expressed in UNIX epoch time.
        #[serde(rename = "timereceived")]
        pub time_received: i64,
        /// If a comment is associated with the transaction, only present if not empty.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub comment: Option<String>,
        /// ("yes|no|unknown") Whether this transaction signals BIP125 replaceability or has an unconfirmed ancestor signaling BIP125 replaceability.
        /// May be unknown for unconfirmed transactions not in the mempool because their unconfirmed ancestors are unknown.
        #[serde(rename = "bip125-replaceable")]
        pub bip125_replaceable: String,
        /// Only if 'category' is 'received'. List of parent descriptors for the output script of this coin.
        #[serde(rename = "parent_descs")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub parent_descriptors: Option<Vec<String>>,
        /// 'true' if the transaction has been abandoned (inputs are respendable).
        pub abandoned: bool,
        /// A comment for the address/transaction, if any
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub label: Option<String>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct ListSinceBlock {
        pub transactions: Vec<ListSinceBlockTransactionsItem>,
        /// <structure is the same as "transactions" above, only present if include_removed=true>
        /// Note: transactions that were re-added in the active chain will appear as-is in this array, and may thus have a positive confirmation count.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub removed: Option<Vec<Value>>,
        /// The hash of the block (target_confirmations-1) from the best block on the main chain, or the genesis hash if the referenced block does not exist yet. This is typically used to feed back into listsinceblock the next time you call it. So you would generally use a target_confirmations of say 6, so you will be continually re-notified of transactions until they've reached 6 confirmations plus any new ones
        #[serde(rename = "lastblock")]
        pub last_block: String,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct ListTransactionsItem {
        /// The bitcoin address of the transaction (not returned if the output does not have an address, e.g. OP_RETURN null data).
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub address: Option<String>,
        /// The transaction category.
        /// "send"                  Transactions sent.
        /// "receive"               Non-coinbase transactions received.
        /// "generate"              Coinbase transactions received with more than 100 confirmations.
        /// "immature"              Coinbase transactions received with 100 or fewer confirmations.
        /// "orphan"                Orphaned coinbase transactions received.
        pub category: String,
        /// The amount in BTC. This is negative for the 'send' category, and is positive
        /// for all other categories
        pub amount: f64,
        /// A comment for the address/transaction, if any
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub label: Option<String>,
        /// the vout value
        #[serde(rename = "vout")]
        pub outputs: f64,
        /// The amount of the fee in BTC. This is negative and only available for the
        /// 'send' category of transactions.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fee: Option<f64>,
        /// The number of confirmations for the transaction. Negative confirmations means the
        /// transaction conflicted that many blocks ago.
        pub confirmations: f64,
        /// Only present if the transaction's only input is a coinbase one.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub generated: Option<bool>,
        /// Whether we consider the transaction to be trusted and safe to spend from.
        /// Only present when the transaction has 0 confirmations (or negative confirmations, if conflicted).
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub trusted: Option<bool>,
        /// The block hash containing the transaction.
        #[serde(rename = "blockhash")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub block_hash: Option<String>,
        /// The block height containing the transaction.
        #[serde(rename = "blockheight")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub block_height: Option<f64>,
        /// The index of the transaction in the block that includes it.
        #[serde(rename = "blockindex")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub block_index: Option<f64>,
        /// The block time expressed in UNIX epoch time.
        #[serde(rename = "blocktime")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub block_time: Option<i64>,
        /// The transaction id.
        pub txid: String,
        /// The hash of serialized transaction, including witness data.
        pub wtxid: String,
        /// Confirmed transactions that have been detected by the wallet to conflict with this transaction.
        #[serde(rename = "walletconflicts")]
        pub wallet_conflicts: Vec<String>,
        /// Only if 'category' is 'send'. The txid if this tx was replaced.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub replaced_by_txid: Option<String>,
        /// Only if 'category' is 'send'. The txid if this tx replaces another.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub replaces_txid: Option<String>,
        /// Transactions in the mempool that directly conflict with either this transaction or an ancestor transaction
        #[serde(rename = "mempoolconflicts")]
        pub mempool_conflicts: Vec<String>,
        /// If a comment to is associated with the transaction.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub to: Option<String>,
        /// The transaction time expressed in UNIX epoch time.
        #[serde(rename = "time")]
        pub transaction_time: i64,
        /// The time received expressed in UNIX epoch time.
        #[serde(rename = "timereceived")]
        pub time_received: i64,
        /// If a comment is associated with the transaction, only present if not empty.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub comment: Option<String>,
        /// ("yes|no|unknown") Whether this transaction signals BIP125 replaceability or has an unconfirmed ancestor signaling BIP125 replaceability.
        /// May be unknown for unconfirmed transactions not in the mempool because their unconfirmed ancestors are unknown.
        #[serde(rename = "bip125-replaceable")]
        pub bip125_replaceable: String,
        /// Only if 'category' is 'received'. List of parent descriptors for the output script of this coin.
        #[serde(rename = "parent_descs")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub parent_descriptors: Option<Vec<String>>,
        /// 'true' if the transaction has been abandoned (inputs are respendable).
        pub abandoned: bool,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct ListUnspentQueryOptions {
        /// Minimum value of each UTXO in BTC
        #[serde(rename = "minimumAmount")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub minimum_amount: Option<f64>,
        /// Maximum value of each UTXO in BTC
        #[serde(rename = "maximumAmount")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub maximum_amount: Option<f64>,
        /// Maximum number of UTXOs
        #[serde(rename = "maximumCount")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub maximum_count: Option<f64>,
        /// Minimum sum value of all UTXOs in BTC
        #[serde(rename = "minimumSumAmount")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub minimum_sum_amount: Option<f64>,
        /// Include immature coinbase UTXOs
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub include_immature_coinbase: Option<bool>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct ListUnspentItem {
        /// the transaction id
        pub txid: String,
        /// the vout value
        #[serde(rename = "vout")]
        pub outputs: f64,
        /// the bitcoin address
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub address: Option<String>,
        /// The associated label, or "" for the default label
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub label: Option<String>,
        /// the output script
        #[serde(rename = "scriptPubKey")]
        pub script_pubkey: String,
        /// the transaction output amount in BTC
        pub amount: f64,
        /// The number of confirmations
        pub confirmations: f64,
        /// The number of in-mempool ancestor transactions, including this one (if transaction is in the mempool)
        #[serde(rename = "ancestorcount")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ancestor_count: Option<f64>,
        /// The virtual transaction size of in-mempool ancestors, including this one (if transaction is in the mempool)
        #[serde(rename = "ancestorsize")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ancestor_size: Option<f64>,
        /// The total fees of in-mempool ancestors (including this one) with fee deltas used for mining priority in sat (if transaction is in the mempool)
        #[serde(rename = "ancestorfees")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ancestor_fees: Option<f64>,
        /// The redeem script if the output script is P2SH
        #[serde(rename = "redeemScript")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub redeem_script: Option<String>,
        /// witness script if the output script is P2WSH or P2SH-P2WSH
        #[serde(rename = "witnessScript")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub witness_script: Option<String>,
        /// (DEPRECATED) Always true
        pub spendable: bool,
        /// Whether we know how to spend this output, ignoring the lack of keys
        pub solvable: bool,
        /// (only present if avoid_reuse is set) Whether this output is reused/dirty (sent to an address that was previously spent from)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub reused: Option<bool>,
        /// (only when solvable) A descriptor for spending this output
        #[serde(rename = "desc")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub descriptor: Option<String>,
        /// List of parent descriptors for the output script of this coin.
        #[serde(rename = "parent_descs")]
        pub parent_descriptors: Vec<String>,
        /// Whether this output is considered safe to spend. Unconfirmed transactions
        /// from outside keys and unconfirmed replacement transactions are considered unsafe
        /// and are not eligible for spending by fundrawtransaction and sendtoaddress.
        pub safe: bool,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct ListWalletDirWalletsItem {
        /// The wallet name
        pub name: String,
        /// Warning messages, if any, related to loading the wallet.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub warnings: Option<Vec<String>>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct ListWalletDir {
        pub wallets: Vec<ListWalletDirWalletsItem>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct LoadTxOutSet {
        /// the number of coins loaded from the snapshot
        pub coins_loaded: f64,
        /// the hash of the base of the snapshot
        pub tip_hash: String,
        /// the height of the base of the snapshot
        pub base_height: f64,
        /// the absolute path that the snapshot was loaded from
        pub path: String,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct LoadWallet {
        /// The wallet name if loaded successfully.
        pub name: String,
        /// Warning messages, if any, related to loading the wallet.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub warnings: Option<Vec<String>>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct LockUnspentTransactionsItem {
        /// The transaction id
        pub txid: String,
        /// The output number
        #[serde(rename = "vout")]
        pub outputs: f64,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct MigrateWallet {
        /// The name of the primary migrated wallet
        pub wallet_name: String,
        /// The name of the migrated wallet containing the watchonly scripts
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub watchonly_name: Option<String>,
        /// The name of the migrated wallet containing solvable but not watched scripts
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub solvables_name: Option<String>,
        /// The location of the backup of the original wallet
        pub backup_path: String,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct PsbtBumpFeeOptions {
        /// Confirmation target in blocks
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub conf_target: Option<f64>,
        /// Specify a fee rate in sat/vB instead of relying on the built-in fee estimator.
        /// Must be at least 0.100 sat/vB higher than the current transaction fee rate.
        /// WARNING: before version 0.21, fee_rate was in BTC/kvB. As of 0.21, fee_rate is in sat/vB.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fee_rate: Option<f64>,
        /// Whether the new transaction should be
        /// marked bip-125 replaceable. If true, the sequence numbers in the transaction will
        /// be set to 0xfffffffd. If false, any input sequence numbers in the
        /// transaction will be set to 0xfffffffe
        /// so the new transaction will not be explicitly bip-125 replaceable (though it may
        /// still be replaceable in practice, for example if it has unconfirmed ancestors which
        /// are replaceable).
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub replaceable: Option<bool>,
        /// The fee estimate mode, must be one of (case insensitive):
        /// unset, economical, conservative
        /// unset means no mode set (economical mode is used if the transaction is replaceable;
        /// otherwise, conservative mode is used).
        /// economical estimates use a shorter time horizon, making them more
        /// responsive to short-term drops in the prevailing fee market. This mode
        /// potentially returns a lower fee rate estimate.
        /// conservative estimates use a longer time horizon, making them
        /// less responsive to short-term drops in the prevailing fee market. This mode
        /// potentially returns a higher fee rate estimate.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub estimate_mode: Option<String>,
        /// The outputs specified as key-value pairs.
        /// Each key may only appear once, i.e. there can only be one 'data' output, and no address may be duplicated.
        /// At least one output of either type must be specified.
        /// Cannot be provided if 'original_change_index' is specified.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub outputs: Option<Vec<Value>>,
        /// The 0-based index of the change output on the original transaction. The indicated output will be recycled into the new change output on the bumped transaction. The remainder after paying the recipients and fees will be sent to the output script of the original change output. The change outputâ€™s amount can increase if bumping the transaction adds new inputs, otherwise it will decrease. Cannot be used in combination with the 'outputs' option.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub original_change_index: Option<f64>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct PsbtBumpFee {
        /// The base64-encoded unsigned PSBT of the new transaction.
        pub psbt: String,
        /// The fee of the replaced transaction.
        #[serde(rename = "origfee")]
        pub original_fee: f64,
        /// The fee of the new transaction.
        pub fee: f64,
        /// Errors encountered during processing (may be empty).
        pub errors: Vec<String>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct RescanBlockchain {
        /// The block height where the rescan started (the requested height or 0)
        pub start_height: f64,
        /// The height of the last rescanned block. May be null in rare cases if there was a reorg and the call didn't scan any blocks because they were already scanned in the background.
        pub stop_height: f64,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct RestoreWallet {
        /// The wallet name if restored successfully.
        pub name: String,
        /// Warning messages, if any, related to restoring and loading the wallet.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub warnings: Option<Vec<String>>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct SaveMempool {
        /// the directory and file where the mempool was saved
        #[serde(rename = "filename")]
        pub file_name: String,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct ScanBlocksOptions {
        /// Filter false positives (slower and may fail on pruned nodes). Otherwise they may occur at a rate of 1/M
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub filter_false_positives: Option<bool>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct ScanBlocksVariant1 {
        /// The height we started the scan from
        pub from_height: f64,
        /// The height we ended the scan at
        pub to_height: f64,
        /// Blocks that may have matched a scanobject.
        pub relevant_blocks: Vec<String>,
        /// true if the scan process was not aborted
        pub completed: bool,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct ScanBlocksVariant2 {
        /// Approximate percent complete
        pub progress: f64,
        /// Height of the block currently being scanned
        pub current_height: f64,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[serde(untagged)]
    pub enum ScanBlocks {
        /// when action=='status' and no scan is in progress - possibly already completed
        Variant0(()),
        /// When action=='start'; only returns after scan completes
        Variant1(ScanBlocksVariant1),
        /// when action=='status' and a scan is currently in progress
        Variant2(ScanBlocksVariant2),
        /// True if scan will be aborted (not necessarily before this RPC returns), or false if there is no scan to abort
        Variant3(bool),
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct ScanTxOutSetVariant0UnspentsItem {
        /// The transaction id
        pub txid: String,
        /// The vout value
        #[serde(rename = "vout")]
        pub outputs: f64,
        /// The output script
        #[serde(rename = "scriptPubKey")]
        pub script_pubkey: String,
        /// A specialized descriptor for the matched output script
        #[serde(rename = "desc")]
        pub descriptor: String,
        /// The total amount in BTC of the unspent output
        pub amount: f64,
        /// Whether this is a coinbase output
        pub coinbase: bool,
        /// Height of the unspent transaction output
        pub height: f64,
        /// Blockhash of the unspent transaction output
        #[serde(rename = "blockhash")]
        pub block_hash: String,
        /// Number of confirmations of the unspent transaction output when the scan was done
        pub confirmations: f64,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct ScanTxOutSetVariant0 {
        /// Whether the scan was completed
        pub success: bool,
        /// The number of unspent transaction outputs scanned
        #[serde(rename = "txouts")]
        pub tx_outs: f64,
        /// The block height at which the scan was done
        pub height: f64,
        /// The hash of the block at the tip of the chain
        #[serde(rename = "bestblock")]
        pub best_block: String,
        pub unspents: Vec<ScanTxOutSetVariant0UnspentsItem>,
        /// The total amount of all found unspent outputs in BTC
        pub total_amount: f64,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct ScanTxOutSetVariant2 {
        /// Approximate percent complete
        pub progress: f64,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[serde(untagged)]
    pub enum ScanTxOutSet {
        /// when action=='start'; only returns after scan completes
        Variant0(ScanTxOutSetVariant0),
        /// True if scan will be aborted (not necessarily before this RPC returns), or false if there is no scan to abort
        Variant1(bool),
        /// when action=='status' and a scan is currently in progress
        Variant2(ScanTxOutSetVariant2),
        /// when action=='status' and no scan is in progress - possibly already completed
        Variant3(()),
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct SendOptionsInputsItem {
        /// The transaction id
        pub txid: String,
        /// The output number
        #[serde(rename = "vout")]
        pub outputs: f64,
        /// The sequence number
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub sequence: Option<f64>,
        /// The maximum weight for this input, including the weight of the outpoint and sequence number. Note that signature sizes are not guaranteed to be consistent, so the maximum DER signatures size of 73 bytes should be used when considering ECDSA signatures.Remember to convert serialized sizes to weight units when necessary.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub weight: Option<f64>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct SendOptionsSolvingData {
        /// Public keys involved in this transaction.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pubkeys: Option<Vec<String>>,
        /// Scripts involved in this transaction.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub scripts: Option<Vec<String>>,
        /// Descriptors that provide solving data for this transaction.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub descriptors: Option<Vec<String>>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct SendOptions {
        /// Automatically include coins from the wallet to cover the target amount.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub add_inputs: Option<bool>,
        /// Include inputs that are not safe to spend (unconfirmed transactions from outside keys and unconfirmed replacement transactions).
        /// Warning: the resulting transaction may become invalid if one of the unsafe inputs disappears.
        /// If that happens, you will need to fund the transaction with different inputs and republish it.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub include_unsafe: Option<bool>,
        /// If add_inputs is specified, require inputs with at least this many confirmations.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub minconf: Option<f64>,
        /// If add_inputs is specified, require inputs with at most this many confirmations.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub maxconf: Option<f64>,
        /// When false, returns a serialized transaction which will not be added to the wallet or broadcast
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub add_to_wallet: Option<bool>,
        /// The bitcoin address to receive the change
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub change_address: Option<String>,
        /// The index of the change output
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub change_position: Option<f64>,
        /// The output type to use. Only valid if change_address is not specified. Options are "legacy", "p2sh-segwit", "bech32", "bech32m".
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub change_type: Option<String>,
        /// Specify a fee rate in sat/vB.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fee_rate: Option<f64>,
        /// (DEPRECATED) No longer used
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub include_watching: Option<bool>,
        /// Specify inputs instead of adding them automatically.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub inputs: Option<Vec<SendOptionsInputsItem>>,
        /// Raw locktime. Non-0 value also locktime-activates inputs
        #[serde(rename = "locktime")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub lock_time: Option<f64>,
        /// Lock selected unspent outputs
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub lock_unspents: Option<bool>,
        /// Always return a PSBT, implies add_to_wallet=false.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub psbt: Option<bool>,
        /// Outputs to subtract the fee from, specified as integer indices.
        /// The fee will be equally deducted from the amount of each specified output.
        /// Those recipients will receive less bitcoins than you enter in their corresponding amount field.
        /// If no outputs are specified here, the sender pays the fee.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub subtract_fee_from_outputs: Option<Vec<f64>>,
        /// The maximum acceptable transaction weight.
        /// Transaction building will fail if this can not be satisfied.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub max_tx_weight: Option<f64>,
        /// Confirmation target in blocks
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub conf_target: Option<f64>,
        /// The fee estimate mode, must be one of (case insensitive):
        /// unset, economical, conservative
        /// unset means no mode set (economical mode is used if the transaction is replaceable;
        /// otherwise, conservative mode is used).
        /// economical estimates use a shorter time horizon, making them more
        /// responsive to short-term drops in the prevailing fee market. This mode
        /// potentially returns a lower fee rate estimate.
        /// conservative estimates use a longer time horizon, making them
        /// less responsive to short-term drops in the prevailing fee market. This mode
        /// potentially returns a higher fee rate estimate.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub estimate_mode: Option<String>,
        /// Marks this transaction as BIP125-replaceable.
        /// Allows this transaction to be replaced by a transaction with higher fees
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub replaceable: Option<bool>,
        /// Keys and scripts needed for producing a final transaction with a dummy signature.
        /// Used for fee estimation during coin selection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub solving_data: Option<SendOptionsSolvingData>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct Send {
        /// If the transaction has a complete set of signatures
        pub complete: bool,
        /// The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub txid: Option<String>,
        /// If add_to_wallet is false, the hex-encoded raw transaction with signature(s)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub hex: Option<String>,
        /// If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub psbt: Option<String>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct SendAllOptionsInputsItem {
        /// The transaction id
        pub txid: String,
        /// The output number
        #[serde(rename = "vout")]
        pub outputs: f64,
        /// The sequence number
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub sequence: Option<f64>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct SendAllOptionsSolvingData {
        /// Public keys involved in this transaction.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pubkeys: Option<Vec<String>>,
        /// Scripts involved in this transaction.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub scripts: Option<Vec<String>>,
        /// Descriptors that provide solving data for this transaction.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub descriptors: Option<Vec<String>>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct SendAllOptions {
        /// When false, returns the serialized transaction without broadcasting or adding it to the wallet
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub add_to_wallet: Option<bool>,
        /// Specify a fee rate in sat/vB.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fee_rate: Option<f64>,
        /// (DEPRECATED) No longer used
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub include_watching: Option<bool>,
        /// Use exactly the specified inputs to build the transaction. Specifying inputs is incompatible with the send_max, minconf, and maxconf options.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub inputs: Option<Vec<SendAllOptionsInputsItem>>,
        /// Raw locktime. Non-0 value also locktime-activates inputs
        #[serde(rename = "locktime")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub lock_time: Option<f64>,
        /// Lock selected unspent outputs
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub lock_unspents: Option<bool>,
        /// Always return a PSBT, implies add_to_wallet=false.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub psbt: Option<bool>,
        /// When true, only use UTXOs that can pay for their own fees to maximize the output amount. When 'false' (default), no UTXO is left behind. send_max is incompatible with providing specific inputs.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub send_max: Option<bool>,
        /// Require inputs with at least this many confirmations.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub minconf: Option<f64>,
        /// Require inputs with at most this many confirmations.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub maxconf: Option<f64>,
        /// Transaction version
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub version: Option<f64>,
        /// Confirmation target in blocks
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub conf_target: Option<f64>,
        /// The fee estimate mode, must be one of (case insensitive):
        /// unset, economical, conservative
        /// unset means no mode set (economical mode is used if the transaction is replaceable;
        /// otherwise, conservative mode is used).
        /// economical estimates use a shorter time horizon, making them more
        /// responsive to short-term drops in the prevailing fee market. This mode
        /// potentially returns a lower fee rate estimate.
        /// conservative estimates use a longer time horizon, making them
        /// less responsive to short-term drops in the prevailing fee market. This mode
        /// potentially returns a higher fee rate estimate.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub estimate_mode: Option<String>,
        /// Marks this transaction as BIP125-replaceable.
        /// Allows this transaction to be replaced by a transaction with higher fees
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub replaceable: Option<bool>,
        /// Keys and scripts needed for producing a final transaction with a dummy signature.
        /// Used for fee estimation during coin selection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub solving_data: Option<SendAllOptionsSolvingData>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct SendAll {
        /// If the transaction has a complete set of signatures
        pub complete: bool,
        /// The transaction id for the send. Only 1 transaction is created regardless of the number of addresses.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub txid: Option<String>,
        /// If add_to_wallet is false, the hex-encoded raw transaction with signature(s)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub hex: Option<String>,
        /// If more signatures are needed, or if add_to_wallet is false, the base64-encoded (partially) signed transaction
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub psbt: Option<String>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct SendManyVariant1 {
        /// The transaction id for the send. Only 1 transaction is created regardless of
        /// the number of addresses.
        pub txid: String,
        /// The transaction fee reason.
        pub fee_reason: String,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[serde(untagged)]
    pub enum SendMany {
        /// The transaction id for the send. Only 1 transaction is created regardless of
        /// the number of addresses.
        Variant0(String),
        /// if verbose is set to true
        Variant1(SendManyVariant1),
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct SendToAddressVariant1 {
        /// The transaction id.
        pub txid: String,
        /// The transaction fee reason.
        pub fee_reason: String,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[serde(untagged)]
    pub enum SendToAddress {
        /// The transaction id.
        Variant0(String),
        /// if verbose is set to true
        Variant1(SendToAddressVariant1),
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct SetWalletFlag {
        /// The name of the flag that was modified
        pub flag_name: String,
        /// The new state of the flag
        pub flag_state: bool,
        /// Any warnings associated with the change
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub warnings: Option<String>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct SignRawTransactionWithKeyPrevtxsItem {
        /// The transaction id
        pub txid: String,
        /// The output number
        #[serde(rename = "vout")]
        pub outputs: f64,
        /// output script
        #[serde(rename = "scriptPubKey")]
        pub script_pubkey: String,
        /// (required for P2SH) redeem script
        #[serde(rename = "redeemScript")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub redeem_script: Option<String>,
        /// (required for P2WSH or P2SH-P2WSH) witness script
        #[serde(rename = "witnessScript")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub witness_script: Option<String>,
        /// (required for Segwit inputs) the amount spent
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub amount: Option<f64>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct SignRawTransactionWithKeyErrorsItem {
        /// The hash of the referenced, previous transaction
        pub txid: String,
        /// The index of the output to spent and used as input
        #[serde(rename = "vout")]
        pub outputs: f64,
        pub witness: Vec<String>,
        /// The hex-encoded signature script
        #[serde(rename = "scriptSig")]
        pub script_sig: String,
        /// Script sequence number
        pub sequence: f64,
        /// Verification or signing error related to the input
        pub error: String,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct SignRawTransactionWithKey {
        /// The hex-encoded raw transaction with signature(s)
        pub hex: String,
        /// If the transaction has a complete set of signatures
        pub complete: bool,
        /// Script verification errors (if there are any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub errors: Option<Vec<SignRawTransactionWithKeyErrorsItem>>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct SignRawTransactionWithWalletPrevtxsItem {
        /// The transaction id
        pub txid: String,
        /// The output number
        #[serde(rename = "vout")]
        pub outputs: f64,
        /// The output script
        #[serde(rename = "scriptPubKey")]
        pub script_pubkey: String,
        /// (required for P2SH) redeem script
        #[serde(rename = "redeemScript")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub redeem_script: Option<String>,
        /// (required for P2WSH or P2SH-P2WSH) witness script
        #[serde(rename = "witnessScript")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub witness_script: Option<String>,
        /// (required for Segwit inputs) the amount spent
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub amount: Option<f64>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct SignRawTransactionWithWalletErrorsItem {
        /// The hash of the referenced, previous transaction
        pub txid: String,
        /// The index of the output to spent and used as input
        #[serde(rename = "vout")]
        pub outputs: f64,
        pub witness: Vec<String>,
        /// The hex-encoded signature script
        #[serde(rename = "scriptSig")]
        pub script_sig: String,
        /// Script sequence number
        pub sequence: f64,
        /// Verification or signing error related to the input
        pub error: String,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct SignRawTransactionWithWallet {
        /// The hex-encoded raw transaction with signature(s)
        pub hex: String,
        /// If the transaction has a complete set of signatures
        pub complete: bool,
        /// Script verification errors (if there are any)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub errors: Option<Vec<SignRawTransactionWithWalletErrorsItem>>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct SimulateRawTransactionOptions {
        /// (DEPRECATED) No longer used
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub include_watchonly: Option<bool>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct SimulateRawTransaction {
        /// The wallet balance change (negative means decrease).
        pub balance_change: f64,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct SubmitPackageTxResultsValueFees {
        /// transaction fee in BTC
        #[serde(rename = "base")]
        pub base_fee: f64,
        /// if the transaction was not already in the mempool, the effective feerate in BTC per KvB. For example, the package feerate and/or feerate with modified fees from prioritisetransaction.
        #[serde(rename = "effective-feerate")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub effective_fee_rate: Option<f64>,
        /// if effective-feerate is provided, the wtxids of the transactions whose fees and vsizes are included in effective-feerate.
        #[serde(rename = "effective-includes")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub effective_includes: Option<Vec<String>>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct SubmitPackageTxResultsValue {
        /// The transaction hash in hex
        pub txid: String,
        /// The wtxid of a different transaction with the same txid but different witness found in the mempool. This means the submitted transaction was ignored.
        #[serde(rename = "other-wtxid")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub other_wtxid: Option<String>,
        /// Sigops-adjusted virtual transaction size.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub vsize: Option<f64>,
        /// Transaction fees
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fees: Option<SubmitPackageTxResultsValueFees>,
        /// The transaction error string, if it was rejected by the mempool
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub error: Option<String>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct SubmitPackage {
        /// The transaction package result message. "success" indicates all transactions were accepted into or are already in the mempool.
        pub package_msg: String,
        /// transaction results keyed by wtxid
        #[serde(rename = "tx-results")]
        pub tx_results: BTreeMap<String, SubmitPackageTxResultsValue>,
        /// List of txids of replaced transactions
        #[serde(rename = "replaced-transactions")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub replaced_transactions: Option<Vec<String>>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct TestMempoolAcceptItemFees {
        /// transaction fee in BTC
        #[serde(rename = "base")]
        pub base_fee: f64,
        /// the effective feerate in BTC per KvB. May differ from the base feerate if, for example, there are modified fees from prioritisetransaction or a package feerate was used.
        #[serde(rename = "effective-feerate")]
        pub effective_fee_rate: f64,
        /// transactions whose fees and vsizes are included in effective-feerate.
        #[serde(rename = "effective-includes")]
        pub effective_includes: Vec<String>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct TestMempoolAcceptItem {
        /// The transaction hash in hex
        pub txid: String,
        /// The transaction witness hash in hex
        pub wtxid: String,
        /// Package validation error, if any (only possible if rawtxs had more than 1 transaction).
        #[serde(rename = "package-error")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub package_error: Option<String>,
        /// Whether this tx would be accepted to the mempool and pass client-specified maxfeerate. If not present, the tx was not fully validated due to a failure in another tx in the list.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub allowed: Option<bool>,
        /// Virtual transaction size as defined in BIP 141. This is different from actual serialized size for witness transactions as witness data is discounted (only present when 'allowed' is true)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub vsize: Option<f64>,
        /// Transaction fees (only present if 'allowed' is true)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fees: Option<TestMempoolAcceptItemFees>,
        /// Rejection reason (only present when 'allowed' is false)
        #[serde(rename = "reject-reason")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub reject_reason: Option<String>,
        /// Rejection details (only present when 'allowed' is false and rejection details exist)
        #[serde(rename = "reject-details")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub reject_details: Option<String>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct UnloadWallet {
        /// Warning messages, if any, related to unloading the wallet.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub warnings: Option<Vec<String>>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct ValidateAddress {
        /// If the address is valid or not
        #[serde(rename = "isvalid")]
        pub is_valid: bool,
        /// The bitcoin address validated
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub address: Option<String>,
        /// The hex-encoded output script generated by the address
        #[serde(rename = "scriptPubKey")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub script_pubkey: Option<String>,
        /// If the key is a script
        #[serde(rename = "isscript")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_script: Option<bool>,
        /// If the address is a witness address
        #[serde(rename = "iswitness")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub is_witness: Option<bool>,
        /// The version number of the witness program
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub witness_version: Option<f64>,
        /// The hex value of the witness program
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub witness_program: Option<String>,
        /// Error message, if any
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub error: Option<String>,
        /// Indices of likely error locations in address, if known (e.g. Bech32 errors)
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub error_locations: Option<Vec<f64>>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct WaitForBlock {
        /// The blockhash
        pub hash: String,
        /// Block height
        pub height: f64,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct WaitForBlockHeight {
        /// The blockhash
        pub hash: String,
        /// Block height
        pub height: f64,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct WaitForNewBlock {
        /// The blockhash
        pub hash: String,
        /// Block height
        pub height: f64,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct WalletCreateFundedPsbtInputsItem {
        /// The transaction id
        pub txid: String,
        /// The output number
        #[serde(rename = "vout")]
        pub outputs: f64,
        /// The sequence number
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub sequence: Option<f64>,
        /// The maximum weight for this input, including the weight of the outpoint and sequence number. Note that signature sizes are not guaranteed to be consistent, so the maximum DER signatures size of 73 bytes should be used when considering ECDSA signatures.Remember to convert serialized sizes to weight units when necessary.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub weight: Option<f64>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct WalletCreateFundedPsbtOptionsSolvingData {
        /// Public keys involved in this transaction.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub pubkeys: Option<Vec<String>>,
        /// Scripts involved in this transaction.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub scripts: Option<Vec<String>>,
        /// Descriptors that provide solving data for this transaction.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub descriptors: Option<Vec<String>>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct WalletCreateFundedPsbtOptions {
        /// Automatically include coins from the wallet to cover the target amount.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub add_inputs: Option<bool>,
        /// Include inputs that are not safe to spend (unconfirmed transactions from outside keys and unconfirmed replacement transactions).
        /// Warning: the resulting transaction may become invalid if one of the unsafe inputs disappears.
        /// If that happens, you will need to fund the transaction with different inputs and republish it.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub include_unsafe: Option<bool>,
        /// If add_inputs is specified, require inputs with at least this many confirmations.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub minconf: Option<f64>,
        /// If add_inputs is specified, require inputs with at most this many confirmations.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub maxconf: Option<f64>,
        /// The bitcoin address to receive the change
        #[serde(rename = "changeAddress")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub change_address: Option<String>,
        /// The index of the change output
        #[serde(rename = "changePosition")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub change_position: Option<f64>,
        /// The output type to use. Only valid if changeAddress is not specified. Options are "legacy", "p2sh-segwit", "bech32", "bech32m".
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub change_type: Option<String>,
        /// (DEPRECATED) No longer used
        #[serde(rename = "includeWatching")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub include_watching: Option<bool>,
        /// Lock selected unspent outputs
        #[serde(rename = "lockUnspents")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub lock_unspents: Option<bool>,
        /// Specify a fee rate in sat/vB.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fee_rate: Option<f64>,
        /// Specify a fee rate in BTC/kvB.
        #[serde(rename = "feeRate")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub fee_rate_btc_kvb: Option<f64>,
        /// The outputs to subtract the fee from.
        /// The fee will be equally deducted from the amount of each specified output.
        /// Those recipients will receive less bitcoins than you enter in their corresponding amount field.
        /// If no outputs are specified here, the sender pays the fee.
        #[serde(rename = "subtractFeeFromOutputs")]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub subtract_fee_from_outputs: Option<Vec<f64>>,
        /// The maximum acceptable transaction weight.
        /// Transaction building will fail if this can not be satisfied.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub max_tx_weight: Option<f64>,
        /// Confirmation target in blocks
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub conf_target: Option<f64>,
        /// The fee estimate mode, must be one of (case insensitive):
        /// unset, economical, conservative
        /// unset means no mode set (economical mode is used if the transaction is replaceable;
        /// otherwise, conservative mode is used).
        /// economical estimates use a shorter time horizon, making them more
        /// responsive to short-term drops in the prevailing fee market. This mode
        /// potentially returns a lower fee rate estimate.
        /// conservative estimates use a longer time horizon, making them
        /// less responsive to short-term drops in the prevailing fee market. This mode
        /// potentially returns a higher fee rate estimate.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub estimate_mode: Option<String>,
        /// Marks this transaction as BIP125-replaceable.
        /// Allows this transaction to be replaced by a transaction with higher fees
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub replaceable: Option<bool>,
        /// Keys and scripts needed for producing a final transaction with a dummy signature.
        /// Used for fee estimation during coin selection.
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub solving_data: Option<WalletCreateFundedPsbtOptionsSolvingData>,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct WalletCreateFundedPsbt {
        /// The resulting raw transaction (base64-encoded string)
        pub psbt: String,
        /// Fee in BTC the resulting transaction pays
        pub fee: f64,
        /// The position of the added change output, or -1
        #[serde(rename = "changepos")]
        pub change_position: f64,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct WalletDisplayAddress {
        /// The address as confirmed by the signer
        pub address: String,
    }

    #[derive(Clone, Debug, PartialEq, Deserialize, Serialize)]
    #[cfg_attr(feature = "serde-deny-unknown-fields", serde(deny_unknown_fields))]
    pub struct WalletProcessPsbt {
        /// The base64-encoded partially signed transaction
        pub psbt: String,
        /// If the transaction has a complete set of signatures
        pub complete: bool,
        /// The hex-encoded network transaction if complete
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub hex: Option<String>,
    }

}

use self::types::*;
use std::collections::BTreeMap;

impl crate::RpcClient {
    
    /// Mark in-wallet transaction <txid> as abandoned
    pub async fn abandon_transaction(&self, txid: String) -> crate::RpcResult<()> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(txid)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("abandontransaction", out).await
    }
    
    /// Stops current wallet rescan triggered by an RPC call, e.g. by a rescanblockchain call.
    pub async fn abort_rescan(&self) -> crate::RpcResult<bool> {
        self.call("abortrescan", Vec::new()).await
    }
    
    /// Open an outbound connection to a specified node. This RPC is for testing only.
    pub async fn add_connection(&self, address: String, connection_type: String, v2transport: bool) -> crate::RpcResult<AddConnection> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(address)?);
        params[1] = Some(serde_json::to_value(connection_type)?);
        params[2] = Some(serde_json::to_value(v2transport)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("addconnection", out).await
    }
    
    /// Attempts to add or remove a node from the addnode list.
    pub async fn add_node(&self, node: String, command: String, v2transport: Option<bool>) -> crate::RpcResult<()> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(node)?);
        params[1] = Some(serde_json::to_value(command)?);
        if let Some(value) = v2transport {
            params[2] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("addnode", out).await
    }
    
    /// Add the address of a potential peer to an address manager table. This RPC is for testing only.
    pub async fn add_peer_address(&self, address: String, port: f64, tried: Option<bool>) -> crate::RpcResult<AddPeerAddress> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(address)?);
        params[1] = Some(serde_json::to_value(port)?);
        if let Some(value) = tried {
            params[2] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("addpeeraddress", out).await
    }
    
    /// Analyzes and provides information about the current status of a PSBT and its inputs
    pub async fn analyze_psbt(&self, psbt: String) -> crate::RpcResult<AnalyzePsbt> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(psbt)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("analyzepsbt", out).await
    }
    
    /// Return an OpenRPC document describing the RPC API.
    pub async fn api(&self) -> crate::RpcResult<Value> {
        self.call("api", Vec::new()).await
    }
    
    /// Safely copies the current wallet file to the specified destination, which can either be a directory or a path with a filename.
    pub async fn backup_wallet(&self, destination: String) -> crate::RpcResult<()> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(destination)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("backupwallet", out).await
    }
    
    /// Bumps the fee of a transaction T, replacing it with a new transaction B.
    pub async fn bump_fee(&self, txid: String, options: Option<BumpFeeOptions>) -> crate::RpcResult<BumpFee> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(txid)?);
        if let Some(value) = options {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("bumpfee", out).await
    }
    
    /// Clear all banned IPs.
    pub async fn clear_banned(&self) -> crate::RpcResult<()> {
        self.call("clearbanned", Vec::new()).await
    }
    
    /// Combine multiple partially signed Bitcoin transactions into one transaction.
    pub async fn combine_psbt(&self, txs: Vec<String>) -> crate::RpcResult<String> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(txs)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("combinepsbt", out).await
    }
    
    /// Combine multiple partially signed transactions into one transaction.
    pub async fn combine_raw_transaction(&self, txs: Vec<String>) -> crate::RpcResult<String> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(txs)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("combinerawtransaction", out).await
    }
    
    /// Converts a network serialized transaction to a PSBT. This should be used only with createrawtransaction and fundrawtransaction
    pub async fn convert_to_psbt(&self, hexstring: String, permit_sig_data: Option<bool>, is_witness: Option<bool>) -> crate::RpcResult<String> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(hexstring)?);
        if let Some(value) = permit_sig_data {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = is_witness {
            params[2] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("converttopsbt", out).await
    }
    
    /// Creates a multi-signature address with n signatures of m keys required.
    pub async fn create_multisig(&self, n_required: f64, keys: Vec<String>, address_type: Option<String>) -> crate::RpcResult<CreateMultisig> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(n_required)?);
        params[1] = Some(serde_json::to_value(keys)?);
        if let Some(value) = address_type {
            params[2] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("createmultisig", out).await
    }
    
    /// Creates a transaction in the Partially Signed Transaction format.
    pub async fn create_psbt(&self, inputs: Vec<CreatePsbtInputsItem>, outputs: Vec<Value>, lock_time: Option<f64>, replaceable: Option<bool>, version: Option<f64>) -> crate::RpcResult<String> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 5];
        params[0] = Some(serde_json::to_value(inputs)?);
        params[1] = Some(serde_json::to_value(outputs)?);
        if let Some(value) = lock_time {
            params[2] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = replaceable {
            params[3] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = version {
            params[4] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("createpsbt", out).await
    }
    
    /// Create a transaction spending the given inputs and creating new outputs.
    pub async fn create_raw_transaction(&self, inputs: Vec<CreateRawTransactionInputsItem>, outputs: Vec<Value>, lock_time: Option<f64>, replaceable: Option<bool>, version: Option<f64>) -> crate::RpcResult<String> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 5];
        params[0] = Some(serde_json::to_value(inputs)?);
        params[1] = Some(serde_json::to_value(outputs)?);
        if let Some(value) = lock_time {
            params[2] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = replaceable {
            params[3] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = version {
            params[4] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("createrawtransaction", out).await
    }
    
    /// Creates and loads a new wallet.
    pub async fn create_wallet(&self, wallet_name: String, disable_private_keys: Option<bool>, blank: Option<bool>, passphrase: Option<String>, avoid_reuse: Option<bool>, descriptors: Option<bool>, load_on_startup: Option<bool>, external_signer: Option<bool>) -> crate::RpcResult<CreateWallet> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 8];
        params[0] = Some(serde_json::to_value(wallet_name)?);
        if let Some(value) = disable_private_keys {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = blank {
            params[2] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = passphrase {
            params[3] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = avoid_reuse {
            params[4] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = descriptors {
            params[5] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = load_on_startup {
            params[6] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = external_signer {
            params[7] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("createwallet", out).await
    }
    
    /// Creates the wallet's descriptor for the given address type. The address type must be one that the wallet does not already have a descriptor for.
    pub async fn create_wallet_descriptor(&self, type_: String, options: Option<CreateWalletDescriptorOptions>) -> crate::RpcResult<CreateWalletDescriptor> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(type_)?);
        if let Some(value) = options {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("createwalletdescriptor", out).await
    }
    
    /// Return a JSON object representing the serialized, base64-encoded partially signed Bitcoin transaction.
    pub async fn decode_psbt(&self, psbt: String) -> crate::RpcResult<DecodePsbt> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(psbt)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("decodepsbt", out).await
    }
    
    /// Return a JSON object representing the serialized, hex-encoded transaction.
    pub async fn decode_raw_transaction(&self, hexstring: String, is_witness: Option<bool>) -> crate::RpcResult<DecodeRawTransaction> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(hexstring)?);
        if let Some(value) = is_witness {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("decoderawtransaction", out).await
    }
    
    /// Decode a hex-encoded script.
    pub async fn decode_script(&self, hexstring: String) -> crate::RpcResult<DecodeScript> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(hexstring)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("decodescript", out).await
    }
    
    /// Derives one or more addresses corresponding to an output descriptor.
    pub async fn derive_addresses(&self, descriptor: String, range: Option<RangeParam>) -> crate::RpcResult<DeriveAddresses> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(descriptor)?);
        if let Some(value) = range {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("deriveaddresses", out).await
    }
    
    /// Update all segwit inputs in a PSBT with information from output descriptors, the UTXO set or the mempool.
    pub async fn descriptor_process_psbt(&self, psbt: String, descriptors: Vec<Value>, sighash_type: Option<String>, bip32_derivs: Option<bool>, finalize: Option<bool>) -> crate::RpcResult<DescriptorProcessPsbt> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 5];
        params[0] = Some(serde_json::to_value(psbt)?);
        params[1] = Some(serde_json::to_value(descriptors)?);
        if let Some(value) = sighash_type {
            params[2] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = bip32_derivs {
            params[3] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = finalize {
            params[4] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("descriptorprocesspsbt", out).await
    }
    
    /// Immediately disconnects from the specified peer node.
    pub async fn disconnect_node(&self, address: Option<String>, node_id: Option<f64>) -> crate::RpcResult<()> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        if let Some(value) = address {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = node_id {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("disconnectnode", out).await
    }
    
    /// Write the serialized UTXO set to a file. This can be used in loadtxoutset afterwards if this snapshot height is supported in the chainparams as well.
    pub async fn dump_tx_out_set(&self, path: String, type_: Option<String>, options: Option<DumpTxOutSetOptions>) -> crate::RpcResult<DumpTxOutSet> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(path)?);
        if let Some(value) = type_ {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = options {
            params[2] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("dumptxoutset", out).await
    }
    
    /// Simply echo back the input arguments. This command is for testing.
    pub async fn echo(&self, arg0: Option<String>, arg1: Option<String>, arg2: Option<String>, arg3: Option<String>, arg4: Option<String>, arg5: Option<String>, arg6: Option<String>, arg7: Option<String>, arg8: Option<String>, arg9: Option<String>) -> crate::RpcResult<Value> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 10];
        if let Some(value) = arg0 {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = arg1 {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = arg2 {
            params[2] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = arg3 {
            params[3] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = arg4 {
            params[4] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = arg5 {
            params[5] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = arg6 {
            params[6] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = arg7 {
            params[7] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = arg8 {
            params[8] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = arg9 {
            params[9] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("echo", out).await
    }
    
    /// Echo back the input argument, passing it through a spawned process in a multiprocess build.
    pub async fn echoipc(&self, arg: String) -> crate::RpcResult<String> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(arg)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("echoipc", out).await
    }
    
    /// Simply echo back the input arguments. This command is for testing.
    pub async fn echojson(&self, arg0: Option<String>, arg1: Option<String>, arg2: Option<String>, arg3: Option<String>, arg4: Option<String>, arg5: Option<String>, arg6: Option<String>, arg7: Option<String>, arg8: Option<String>, arg9: Option<String>) -> crate::RpcResult<Value> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 10];
        if let Some(value) = arg0 {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = arg1 {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = arg2 {
            params[2] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = arg3 {
            params[3] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = arg4 {
            params[4] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = arg5 {
            params[5] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = arg6 {
            params[6] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = arg7 {
            params[7] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = arg8 {
            params[8] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = arg9 {
            params[9] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("echojson", out).await
    }
    
    /// Encrypts the wallet with 'passphrase'. This is for first time encryption.
    pub async fn encrypt_wallet(&self, passphrase: String) -> crate::RpcResult<String> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(passphrase)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("encryptwallet", out).await
    }
    
    /// Returns a list of external signers from -signer.
    pub async fn enumerate_signers(&self) -> crate::RpcResult<EnumerateSigners> {
        self.call("enumeratesigners", Vec::new()).await
    }
    
    /// WARNING: This interface is unstable and may disappear or change!
    pub async fn estimate_raw_fee(&self, conf_target: f64, threshold: Option<f64>) -> crate::RpcResult<EstimateRawFee> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(conf_target)?);
        if let Some(value) = threshold {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("estimaterawfee", out).await
    }
    
    /// Estimates the approximate fee per kilobyte needed for a transaction to begin
    pub async fn estimate_smart_fee(&self, conf_target: f64, estimate_mode: Option<String>) -> crate::RpcResult<EstimateSmartFee> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(conf_target)?);
        if let Some(value) = estimate_mode {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("estimatesmartfee", out).await
    }
    
    /// Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a
    pub async fn finalize_psbt(&self, psbt: String, extract: Option<bool>) -> crate::RpcResult<FinalizePsbt> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(psbt)?);
        if let Some(value) = extract {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("finalizepsbt", out).await
    }
    
    /// If the transaction has no inputs, they will be automatically selected to meet its out value.
    pub async fn fund_raw_transaction(&self, hexstring: String, options: Option<FundRawTransactionOptions>, is_witness: Option<bool>) -> crate::RpcResult<FundRawTransaction> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(hexstring)?);
        if let Some(value) = options {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = is_witness {
            params[2] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("fundrawtransaction", out).await
    }
    
    /// has been replaced by the -generate cli option. Refer to -help for more information.
    pub async fn generate(&self) -> crate::RpcResult<Value> {
        self.call("generate", Vec::new()).await
    }
    
    /// Mine a set of ordered transactions to a specified address or descriptor and return the block hash.
    pub async fn generate_block(&self, output: String, transactions: Vec<String>, submit: Option<bool>) -> crate::RpcResult<GenerateBlock> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(output)?);
        params[1] = Some(serde_json::to_value(transactions)?);
        if let Some(value) = submit {
            params[2] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("generateblock", out).await
    }
    
    /// Mine to a specified address and return the block hashes.
    pub async fn generate_to_address(&self, n_blocks: f64, address: String, maxtries: Option<f64>) -> crate::RpcResult<Vec<String>> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(n_blocks)?);
        params[1] = Some(serde_json::to_value(address)?);
        if let Some(value) = maxtries {
            params[2] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("generatetoaddress", out).await
    }
    
    /// Mine to a specified descriptor and return the block hashes.
    pub async fn generate_to_descriptor(&self, num_blocks: f64, descriptor: String, maxtries: Option<f64>) -> crate::RpcResult<Vec<String>> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(num_blocks)?);
        params[1] = Some(serde_json::to_value(descriptor)?);
        if let Some(value) = maxtries {
            params[2] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("generatetodescriptor", out).await
    }
    
    /// Returns information about the given added node, or all added nodes
    pub async fn get_added_node_info(&self, node: Option<String>) -> crate::RpcResult<Vec<GetAddedNodeInfoItem>> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        if let Some(value) = node {
            params[0] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getaddednodeinfo", out).await
    }
    
    /// Returns the list of addresses assigned the specified label.
    pub async fn get_addresses_by_label(&self, label: String) -> crate::RpcResult<BTreeMap<String, GetAddressesByLabelValue>> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(label)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getaddressesbylabel", out).await
    }
    
    /// Return information about the given bitcoin address.
    pub async fn get_address_info(&self, address: String) -> crate::RpcResult<GetAddressInfo> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(address)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getaddressinfo", out).await
    }
    
    /// Provides information about the node's address manager by returning the number of addresses in the `new` and `tried` tables and their sum for all networks.
    pub async fn get_addrman_info(&self) -> crate::RpcResult<BTreeMap<String, GetAddrmanInfoValue>> {
        self.call("getaddrmaninfo", Vec::new()).await
    }
    
    /// Returns the total available balance.
    pub async fn get_balance(&self, dummy: Option<String>, minconf: Option<f64>, include_watchonly: Option<bool>, avoid_reuse: Option<bool>) -> crate::RpcResult<f64> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 4];
        if let Some(value) = dummy {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = minconf {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = include_watchonly {
            params[2] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = avoid_reuse {
            params[3] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getbalance", out).await
    }
    
    /// Returns an object with all balances in BTC.
    pub async fn get_balances(&self) -> crate::RpcResult<GetBalances> {
        self.call("getbalances", Vec::new()).await
    }
    
    /// Returns the hash of the best (tip) block in the most-work fully-validated chain.
    pub async fn get_best_block_hash(&self) -> crate::RpcResult<String> {
        self.call("getbestblockhash", Vec::new()).await
    }
    
    /// If verbosity is 0, returns a string that is serialized, hex-encoded data for block 'hash'.
    pub async fn get_block(&self, block_hash: String, verbosity: Option<f64>) -> crate::RpcResult<GetBlock> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(block_hash)?);
        if let Some(value) = verbosity {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getblock", out).await
    }
    
    /// Returns an object containing various state info regarding blockchain processing.
    pub async fn get_blockchain_info(&self) -> crate::RpcResult<GetBlockchainInfo> {
        self.call("getblockchaininfo", Vec::new()).await
    }
    
    /// Returns the height of the most-work fully-validated chain.
    pub async fn get_block_count(&self) -> crate::RpcResult<f64> {
        self.call("getblockcount", Vec::new()).await
    }
    
    /// Retrieve a BIP 157 content filter for a particular block.
    pub async fn get_block_filter(&self, block_hash: String, filter_type: Option<String>) -> crate::RpcResult<GetBlockFilter> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(block_hash)?);
        if let Some(value) = filter_type {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getblockfilter", out).await
    }
    
    /// Attempt to fetch block from a given peer.
    pub async fn get_block_from_peer(&self, block_hash: String, peer_id: f64) -> crate::RpcResult<Value> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(block_hash)?);
        params[1] = Some(serde_json::to_value(peer_id)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getblockfrompeer", out).await
    }
    
    /// Returns hash of block in best-block-chain at height provided.
    pub async fn get_block_hash(&self, height: f64) -> crate::RpcResult<String> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(height)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getblockhash", out).await
    }
    
    /// If verbose is false, returns a string that is serialized, hex-encoded data for blockheader 'hash'.
    pub async fn get_block_header(&self, block_hash: String, verbose: Option<bool>) -> crate::RpcResult<GetBlockHeader> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(block_hash)?);
        if let Some(value) = verbose {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getblockheader", out).await
    }
    
    /// Compute per block statistics for a given window. All amounts are in satoshis.
    pub async fn get_block_stats(&self, hash_or_height: f64, stats: Option<Vec<Value>>) -> crate::RpcResult<GetBlockStats> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(hash_or_height)?);
        if let Some(value) = stats {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getblockstats", out).await
    }
    
    /// If the request parameters include a 'mode' key, that is used to explicitly select between the default 'template' request or a 'proposal'.
    pub async fn get_block_template(&self, template_request: GetBlockTemplateTemplateRequest) -> crate::RpcResult<GetBlockTemplate> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(template_request)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getblocktemplate", out).await
    }
    
    /// Return information about chainstates.
    pub async fn get_chain_states(&self) -> crate::RpcResult<GetChainStates> {
        self.call("getchainstates", Vec::new()).await
    }
    
    /// Return information about all known tips in the block tree, including the main chain as well as orphaned branches.
    pub async fn get_chain_tips(&self) -> crate::RpcResult<Vec<GetChainTipsItem>> {
        self.call("getchaintips", Vec::new()).await
    }
    
    /// Compute statistics about the total number and rate of transactions in the chain.
    pub async fn get_chain_tx_stats(&self, n_blocks: Option<f64>, block_hash: Option<String>) -> crate::RpcResult<GetChainTxStats> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        if let Some(value) = n_blocks {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = block_hash {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getchaintxstats", out).await
    }
    
    /// Returns the number of connections to other nodes.
    pub async fn get_connection_count(&self) -> crate::RpcResult<f64> {
        self.call("getconnectioncount", Vec::new()).await
    }
    
    /// Returns an object containing various state info regarding deployments of consensus changes.
    pub async fn get_deployment_info(&self, block_hash: Option<String>) -> crate::RpcResult<GetDeploymentInfo> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        if let Some(value) = block_hash {
            params[0] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getdeploymentinfo", out).await
    }
    
    /// Get spend and receive activity associated with a set of descriptors for a set of blocks. This command pairs well with the `relevant_blocks` output of `scanblocks()`.
    pub async fn get_descriptor_activity(&self, block_hashes: Vec<String>, scanobjects: Vec<Value>, include_mempool: Option<bool>) -> crate::RpcResult<GetDescriptorActivity> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(block_hashes)?);
        params[1] = Some(serde_json::to_value(scanobjects)?);
        if let Some(value) = include_mempool {
            params[2] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getdescriptoractivity", out).await
    }
    
    /// Analyses a descriptor.
    pub async fn get_descriptor_info(&self, descriptor: String) -> crate::RpcResult<GetDescriptorInfo> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(descriptor)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getdescriptorinfo", out).await
    }
    
    /// Returns the proof-of-work difficulty as a multiple of the minimum difficulty.
    pub async fn get_difficulty(&self) -> crate::RpcResult<f64> {
        self.call("getdifficulty", Vec::new()).await
    }
    
    /// List all BIP 32 HD keys in the wallet and which descriptors use them.
    pub async fn get_hd_keys(&self, options: Option<GetHdKeysOptions>) -> crate::RpcResult<Vec<GetHdKeysItem>> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        if let Some(value) = options {
            params[0] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("gethdkeys", out).await
    }
    
    /// Returns the status of one or all available indices currently running in the node.
    pub async fn get_index_info(&self, index_name: Option<String>) -> crate::RpcResult<BTreeMap<String, GetIndexInfoValue>> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        if let Some(value) = index_name {
            params[0] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getindexinfo", out).await
    }
    
    /// Returns an object containing information about memory usage.
    pub async fn get_memory_info(&self, mode: Option<String>) -> crate::RpcResult<GetMemoryInfo> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        if let Some(value) = mode {
            params[0] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getmemoryinfo", out).await
    }
    
    /// If txid is in the mempool, returns all in-mempool ancestors.
    pub async fn get_mempool_ancestors(&self, txid: String, verbose: Option<bool>) -> crate::RpcResult<GetMempoolAncestors> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(txid)?);
        if let Some(value) = verbose {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getmempoolancestors", out).await
    }
    
    /// If txid is in the mempool, returns all in-mempool descendants.
    pub async fn get_mempool_descendants(&self, txid: String, verbose: Option<bool>) -> crate::RpcResult<GetMempoolDescendants> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(txid)?);
        if let Some(value) = verbose {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getmempooldescendants", out).await
    }
    
    /// Returns mempool data for given transaction
    pub async fn get_mempool_entry(&self, txid: String) -> crate::RpcResult<GetMempoolEntry> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(txid)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getmempoolentry", out).await
    }
    
    /// Returns details on the active state of the TX memory pool.
    pub async fn get_mempool_info(&self) -> crate::RpcResult<GetMempoolInfo> {
        self.call("getmempoolinfo", Vec::new()).await
    }
    
    /// Returns a json object containing mining-related information.
    pub async fn get_mining_info(&self) -> crate::RpcResult<GetMiningInfo> {
        self.call("getmininginfo", Vec::new()).await
    }
    
    /// Returns information about network traffic, including bytes in, bytes out,
    pub async fn get_net_totals(&self) -> crate::RpcResult<GetNetTotals> {
        self.call("getnettotals", Vec::new()).await
    }
    
    /// Returns the estimated network hashes per second based on the last n blocks.
    pub async fn get_network_hash_ps(&self, n_blocks: Option<f64>, height: Option<f64>) -> crate::RpcResult<f64> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        if let Some(value) = n_blocks {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = height {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getnetworkhashps", out).await
    }
    
    /// Returns an object containing various state info regarding P2P networking.
    pub async fn get_network_info(&self) -> crate::RpcResult<GetNetworkInfo> {
        self.call("getnetworkinfo", Vec::new()).await
    }
    
    /// Returns a new Bitcoin address for receiving payments.
    pub async fn get_new_address(&self, label: Option<String>, address_type: Option<String>) -> crate::RpcResult<String> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        if let Some(value) = label {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = address_type {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getnewaddress", out).await
    }
    
    /// Return known addresses, after filtering for quality and recency.
    pub async fn get_node_addresses(&self, count: Option<f64>, network: Option<String>) -> crate::RpcResult<Vec<GetNodeAddressesItem>> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        if let Some(value) = count {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = network {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getnodeaddresses", out).await
    }
    
    /// Shows transactions in the tx orphanage.
    pub async fn get_orphan_txs(&self, verbosity: Option<f64>) -> crate::RpcResult<GetOrphanTxs> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        if let Some(value) = verbosity {
            params[0] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getorphantxs", out).await
    }
    
    /// Returns data about each connected network peer as a json array of objects.
    pub async fn get_peer_info(&self) -> crate::RpcResult<Vec<GetPeerInfoItem>> {
        self.call("getpeerinfo", Vec::new()).await
    }
    
    /// Returns a map of all user-created (see prioritisetransaction) fee deltas by txid, and whether the tx is present in mempool.
    pub async fn get_prioritised_transactions(&self) -> crate::RpcResult<BTreeMap<String, GetPrioritisedTransactionsValue>> {
        self.call("getprioritisedtransactions", Vec::new()).await
    }
    
    /// EXPERIMENTAL warning: this call may be changed in future releases.
    pub async fn get_raw_addrman(&self) -> crate::RpcResult<BTreeMap<String, BTreeMap<String, GetRawAddrmanValueValue>>> {
        self.call("getrawaddrman", Vec::new()).await
    }
    
    /// Returns a new Bitcoin address, for receiving change.
    pub async fn get_raw_change_address(&self, address_type: Option<String>) -> crate::RpcResult<String> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        if let Some(value) = address_type {
            params[0] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getrawchangeaddress", out).await
    }
    
    /// Returns all transaction ids in memory pool as a json array of string transaction ids.
    pub async fn get_raw_mempool(&self, verbose: Option<bool>, mempool_sequence: Option<bool>) -> crate::RpcResult<GetRawMempool> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        if let Some(value) = verbose {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = mempool_sequence {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getrawmempool", out).await
    }
    
    /// By default, this call only returns a transaction if it is in the mempool. If -txindex is enabled
    pub async fn get_raw_transaction(&self, txid: String, verbosity: Option<f64>, block_hash: Option<String>) -> crate::RpcResult<GetRawTransaction> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(txid)?);
        if let Some(value) = verbosity {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = block_hash {
            params[2] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getrawtransaction", out).await
    }
    
    /// Returns the total amount received by the given address in transactions with at least minconf confirmations.
    pub async fn get_received_by_address(&self, address: String, minconf: Option<f64>, include_immature_coinbase: Option<bool>) -> crate::RpcResult<f64> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(address)?);
        if let Some(value) = minconf {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = include_immature_coinbase {
            params[2] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getreceivedbyaddress", out).await
    }
    
    /// Returns the total amount received by addresses with <label> in transactions with at least [minconf] confirmations.
    pub async fn get_received_by_label(&self, label: String, minconf: Option<f64>, include_immature_coinbase: Option<bool>) -> crate::RpcResult<f64> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(label)?);
        if let Some(value) = minconf {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = include_immature_coinbase {
            params[2] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("getreceivedbylabel", out).await
    }
    
    /// Returns details of the RPC server.
    pub async fn get_rpc_info(&self) -> crate::RpcResult<GetRpcInfo> {
        self.call("getrpcinfo", Vec::new()).await
    }
    
    /// Get detailed information about in-wallet transaction <txid>
    pub async fn get_transaction(&self, txid: String, include_watchonly: Option<bool>, verbose: Option<bool>) -> crate::RpcResult<GetTransaction> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(txid)?);
        if let Some(value) = include_watchonly {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = verbose {
            params[2] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("gettransaction", out).await
    }
    
    /// Returns details about an unspent transaction output.
    pub async fn get_tx_out(&self, txid: String, index: f64, include_mempool: Option<bool>) -> crate::RpcResult<Option<GetTxOut>> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(txid)?);
        params[1] = Some(serde_json::to_value(index)?);
        if let Some(value) = include_mempool {
            params[2] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("gettxout", out).await
    }
    
    /// Returns a hex-encoded proof that "txid" was included in a block.
    pub async fn get_tx_out_proof(&self, txids: Vec<String>, block_hash: Option<String>) -> crate::RpcResult<String> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(txids)?);
        if let Some(value) = block_hash {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("gettxoutproof", out).await
    }
    
    /// Returns statistics about the unspent transaction output set.
    pub async fn get_tx_out_set_info(&self, hash_type: Option<String>, hash_or_height: Option<f64>, use_index: Option<bool>) -> crate::RpcResult<GetTxOutSetInfo> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        if let Some(value) = hash_type {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = hash_or_height {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = use_index {
            params[2] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("gettxoutsetinfo", out).await
    }
    
    /// Scans the mempool to find transactions spending any of the given outputs
    pub async fn get_tx_spending_prevout(&self, outputs: Vec<GetTxSpendingPrevoutOutputsItem>) -> crate::RpcResult<Vec<GetTxSpendingPrevoutItem>> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(outputs)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("gettxspendingprevout", out).await
    }
    
    /// Returns an object containing various wallet state info.
    pub async fn get_wallet_info(&self) -> crate::RpcResult<GetWalletInfo> {
        self.call("getwalletinfo", Vec::new()).await
    }
    
    /// List all commands, or get help for a specified command.
    pub async fn help(&self, command: Option<String>) -> crate::RpcResult<String> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        if let Some(value) = command {
            params[0] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("help", out).await
    }
    
    /// Import descriptors. This will trigger a rescan of the blockchain based on the earliest timestamp of all descriptors being imported. Requires a new wallet backup.
    pub async fn import_descriptors(&self, requests: Vec<ImportDescriptorsRequestsItem>) -> crate::RpcResult<Vec<ImportDescriptorsItem>> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(requests)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("importdescriptors", out).await
    }
    
    /// Import a mempool.dat file and attempt to add its contents to the mempool.
    pub async fn import_mempool(&self, file_path: String, options: Option<ImportMempoolOptions>) -> crate::RpcResult<Value> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(file_path)?);
        if let Some(value) = options {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("importmempool", out).await
    }
    
    /// Imports funds without rescan. Corresponding address or script must previously be included in wallet. Aimed towards pruned wallets. The end-user is responsible to import additional transactions that subsequently spend the imported outputs or rescan after the point in the blockchain the transaction is included.
    pub async fn import_pruned_funds(&self, raw_transaction: String, tx_out_proof: String) -> crate::RpcResult<()> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(raw_transaction)?);
        params[1] = Some(serde_json::to_value(tx_out_proof)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("importprunedfunds", out).await
    }
    
    /// Permanently marks a block as invalid, as if it violated a consensus rule.
    pub async fn invalidate_block(&self, block_hash: String) -> crate::RpcResult<()> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(block_hash)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("invalidateblock", out).await
    }
    
    /// Joins multiple distinct PSBTs with different inputs and outputs into one PSBT with inputs and outputs from all of the PSBTs
    pub async fn join_psbts(&self, txs: Vec<String>) -> crate::RpcResult<String> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(txs)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("joinpsbts", out).await
    }
    
    /// Refills each descriptor keypool in the wallet up to the specified number of new keys.
    pub async fn keypool_refill(&self, new_size: Option<f64>) -> crate::RpcResult<()> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        if let Some(value) = new_size {
            params[0] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("keypoolrefill", out).await
    }
    
    /// Lists groups of addresses which have had their common ownership
    pub async fn list_address_groupings(&self) -> crate::RpcResult<Vec<Vec<Vec<Value>>>> {
        self.call("listaddressgroupings", Vec::new()).await
    }
    
    /// List all manually banned IPs/Subnets.
    pub async fn list_banned(&self) -> crate::RpcResult<Vec<ListBannedItem>> {
        self.call("listbanned", Vec::new()).await
    }
    
    /// List all descriptors present in a wallet.
    pub async fn list_descriptors(&self, private: Option<bool>) -> crate::RpcResult<ListDescriptors> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        if let Some(value) = private {
            params[0] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("listdescriptors", out).await
    }
    
    /// Returns the list of all labels, or labels that are assigned to addresses with a specific purpose.
    pub async fn list_labels(&self, purpose: Option<String>) -> crate::RpcResult<Vec<String>> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        if let Some(value) = purpose {
            params[0] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("listlabels", out).await
    }
    
    /// Returns list of temporarily unspendable outputs.
    pub async fn list_lock_unspent(&self) -> crate::RpcResult<Vec<ListLockUnspentItem>> {
        self.call("listlockunspent", Vec::new()).await
    }
    
    /// List balances by receiving address.
    pub async fn list_received_by_address(&self, minconf: Option<f64>, include_empty: Option<bool>, include_watchonly: Option<bool>, address_filter: Option<String>, include_immature_coinbase: Option<bool>) -> crate::RpcResult<Vec<ListReceivedByAddressItem>> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 5];
        if let Some(value) = minconf {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = include_empty {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = include_watchonly {
            params[2] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = address_filter {
            params[3] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = include_immature_coinbase {
            params[4] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("listreceivedbyaddress", out).await
    }
    
    /// List received transactions by label.
    pub async fn list_received_by_label(&self, minconf: Option<f64>, include_empty: Option<bool>, include_watchonly: Option<bool>, include_immature_coinbase: Option<bool>) -> crate::RpcResult<Vec<ListReceivedByLabelItem>> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 4];
        if let Some(value) = minconf {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = include_empty {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = include_watchonly {
            params[2] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = include_immature_coinbase {
            params[3] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("listreceivedbylabel", out).await
    }
    
    /// Get all transactions in blocks since block [blockhash], or all transactions if omitted.
    pub async fn list_since_block(&self, block_hash: Option<String>, target_confirmations: Option<f64>, include_watchonly: Option<bool>, include_removed: Option<bool>, include_change: Option<bool>, label: Option<String>) -> crate::RpcResult<ListSinceBlock> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 6];
        if let Some(value) = block_hash {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = target_confirmations {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = include_watchonly {
            params[2] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = include_removed {
            params[3] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = include_change {
            params[4] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = label {
            params[5] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("listsinceblock", out).await
    }
    
    /// If a label name is provided, this will return only incoming transactions paying to addresses with the specified label.
    pub async fn list_transactions(&self, label: Option<String>, count: Option<f64>, skip: Option<f64>, include_watchonly: Option<bool>) -> crate::RpcResult<Vec<ListTransactionsItem>> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 4];
        if let Some(value) = label {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = count {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = skip {
            params[2] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = include_watchonly {
            params[3] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("listtransactions", out).await
    }
    
    /// Returns array of unspent transaction outputs
    pub async fn list_unspent(&self, minconf: Option<f64>, maxconf: Option<f64>, addresses: Option<Vec<String>>, include_unsafe: Option<bool>, query_options: Option<ListUnspentQueryOptions>) -> crate::RpcResult<Vec<ListUnspentItem>> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 5];
        if let Some(value) = minconf {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = maxconf {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = addresses {
            params[2] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = include_unsafe {
            params[3] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = query_options {
            params[4] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("listunspent", out).await
    }
    
    /// Returns a list of wallets in the wallet directory.
    pub async fn list_wallet_dir(&self) -> crate::RpcResult<ListWalletDir> {
        self.call("listwalletdir", Vec::new()).await
    }
    
    /// Returns a list of currently loaded wallets.
    pub async fn list_wallets(&self) -> crate::RpcResult<Vec<String>> {
        self.call("listwallets", Vec::new()).await
    }
    
    /// Load the serialized UTXO set from a file.
    pub async fn load_tx_out_set(&self, path: String) -> crate::RpcResult<LoadTxOutSet> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(path)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("loadtxoutset", out).await
    }
    
    /// Loads a wallet from a wallet file or directory.
    pub async fn load_wallet(&self, file_name: String, load_on_startup: Option<bool>) -> crate::RpcResult<LoadWallet> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(file_name)?);
        if let Some(value) = load_on_startup {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("loadwallet", out).await
    }
    
    /// Updates list of temporarily unspendable outputs.
    pub async fn lock_unspent(&self, unlock: bool, transactions: Option<Vec<LockUnspentTransactionsItem>>, persistent: Option<bool>) -> crate::RpcResult<bool> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(unlock)?);
        if let Some(value) = transactions {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = persistent {
            params[2] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("lockunspent", out).await
    }
    
    /// Gets and sets the logging configuration.
    pub async fn logging(&self, include: Option<Vec<String>>, exclude: Option<Vec<String>>) -> crate::RpcResult<BTreeMap<String, bool>> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        if let Some(value) = include {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = exclude {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("logging", out).await
    }
    
    /// Migrate the wallet to a descriptor wallet.
    pub async fn migrate_wallet(&self, wallet_name: Option<String>, passphrase: Option<String>) -> crate::RpcResult<MigrateWallet> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        if let Some(value) = wallet_name {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = passphrase {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("migratewallet", out).await
    }
    
    /// Bump the scheduler into the future (-regtest only)
    pub async fn mock_scheduler(&self, delta_time: f64) -> crate::RpcResult<()> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(delta_time)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("mockscheduler", out).await
    }
    
    /// Requests that a ping be sent to all other nodes, to measure ping time.
    pub async fn ping(&self) -> crate::RpcResult<()> {
        self.call("ping", Vec::new()).await
    }
    
    /// Treats a block as if it were received before others with the same work.
    pub async fn precious_block(&self, block_hash: String) -> crate::RpcResult<()> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(block_hash)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("preciousblock", out).await
    }
    
    /// Accepts the transaction into mined blocks at a higher (or lower) priority
    pub async fn prioritise_transaction(&self, txid: String, dummy: Option<f64>, fee_delta: f64) -> crate::RpcResult<bool> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(txid)?);
        if let Some(value) = dummy {
            params[1] = Some(serde_json::to_value(value)?);
        }
        params[2] = Some(serde_json::to_value(fee_delta)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("prioritisetransaction", out).await
    }
    
    /// Attempts to delete block and undo data up to a specified height or timestamp, if eligible for pruning.
    pub async fn prune_blockchain(&self, height: f64) -> crate::RpcResult<f64> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(height)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("pruneblockchain", out).await
    }
    
    /// Bumps the fee of a transaction T, replacing it with a new transaction B.
    pub async fn psbt_bump_fee(&self, txid: String, options: Option<PsbtBumpFeeOptions>) -> crate::RpcResult<PsbtBumpFee> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(txid)?);
        if let Some(value) = options {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("psbtbumpfee", out).await
    }
    
    /// Removes invalidity status of a block, its ancestors and its descendants, reconsider them for activation.
    pub async fn reconsider_block(&self, block_hash: String) -> crate::RpcResult<()> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(block_hash)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("reconsiderblock", out).await
    }
    
    /// Deletes the specified transaction from the wallet. Meant for use with pruned wallets and as a companion to importprunedfunds. This will affect wallet balances.
    pub async fn remove_pruned_funds(&self, txid: String) -> crate::RpcResult<()> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(txid)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("removeprunedfunds", out).await
    }
    
    /// Rescan the local blockchain for wallet related transactions.
    pub async fn rescan_blockchain(&self, start_height: Option<f64>, stop_height: Option<f64>) -> crate::RpcResult<RescanBlockchain> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        if let Some(value) = start_height {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = stop_height {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("rescanblockchain", out).await
    }
    
    /// Restores and loads a wallet from backup.
    pub async fn restore_wallet(&self, wallet_name: String, backup_file: String, load_on_startup: Option<bool>) -> crate::RpcResult<RestoreWallet> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(wallet_name)?);
        params[1] = Some(serde_json::to_value(backup_file)?);
        if let Some(value) = load_on_startup {
            params[2] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("restorewallet", out).await
    }
    
    /// Dumps the mempool to disk. It will fail until the previous dump is fully loaded.
    pub async fn save_mempool(&self) -> crate::RpcResult<SaveMempool> {
        self.call("savemempool", Vec::new()).await
    }
    
    /// Return relevant blockhashes for given descriptors (requires blockfilterindex).
    pub async fn scan_blocks(&self, action: String, scanobjects: Option<Vec<Value>>, start_height: Option<f64>, stop_height: Option<f64>, filter_type: Option<String>, options: Option<ScanBlocksOptions>) -> crate::RpcResult<ScanBlocks> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 6];
        params[0] = Some(serde_json::to_value(action)?);
        if let Some(value) = scanobjects {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = start_height {
            params[2] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = stop_height {
            params[3] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = filter_type {
            params[4] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = options {
            params[5] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("scanblocks", out).await
    }
    
    /// Scans the unspent transaction output set for entries that match certain output descriptors.
    pub async fn scan_tx_out_set(&self, action: String, scanobjects: Option<Vec<Value>>) -> crate::RpcResult<ScanTxOutSet> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(action)?);
        if let Some(value) = scanobjects {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("scantxoutset", out).await
    }
    
    /// EXPERIMENTAL warning: this call may be changed in future releases.
    pub async fn send(&self, outputs: Vec<Value>, conf_target: Option<f64>, estimate_mode: Option<String>, fee_rate: Option<f64>, options: Option<SendOptions>, version: Option<f64>) -> crate::RpcResult<Send> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 6];
        params[0] = Some(serde_json::to_value(outputs)?);
        if let Some(value) = conf_target {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = estimate_mode {
            params[2] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = fee_rate {
            params[3] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = options {
            params[4] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = version {
            params[5] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("send", out).await
    }
    
    /// EXPERIMENTAL warning: this call may be changed in future releases.
    pub async fn send_all(&self, recipients: Vec<Value>, conf_target: Option<f64>, estimate_mode: Option<String>, fee_rate: Option<f64>, options: Option<SendAllOptions>) -> crate::RpcResult<SendAll> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 5];
        params[0] = Some(serde_json::to_value(recipients)?);
        if let Some(value) = conf_target {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = estimate_mode {
            params[2] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = fee_rate {
            params[3] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = options {
            params[4] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("sendall", out).await
    }
    
    /// Send multiple times. Amounts are double-precision floating point numbers.
    pub async fn send_many(&self, dummy: Option<String>, amounts: BTreeMap<String, f64>, minconf: Option<f64>, comment: Option<String>, subtractfeefrom: Option<Vec<String>>, replaceable: Option<bool>, conf_target: Option<f64>, estimate_mode: Option<String>, fee_rate: Option<f64>, verbose: Option<bool>) -> crate::RpcResult<SendMany> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 10];
        if let Some(value) = dummy {
            params[0] = Some(serde_json::to_value(value)?);
        }
        params[1] = Some(serde_json::to_value(amounts)?);
        if let Some(value) = minconf {
            params[2] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = comment {
            params[3] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = subtractfeefrom {
            params[4] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = replaceable {
            params[5] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = conf_target {
            params[6] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = estimate_mode {
            params[7] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = fee_rate {
            params[8] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = verbose {
            params[9] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("sendmany", out).await
    }
    
    /// Send a p2p message to a peer specified by id.
    pub async fn send_msg_to_peer(&self, peer_id: f64, msg_type: String, msg: String) -> crate::RpcResult<Value> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(peer_id)?);
        params[1] = Some(serde_json::to_value(msg_type)?);
        params[2] = Some(serde_json::to_value(msg)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("sendmsgtopeer", out).await
    }
    
    /// Submit a raw transaction (serialized, hex-encoded) to local node and network.
    pub async fn send_raw_transaction(&self, hexstring: String, max_fee_rate: Option<f64>, maxburnamount: Option<f64>) -> crate::RpcResult<String> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(hexstring)?);
        if let Some(value) = max_fee_rate {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = maxburnamount {
            params[2] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("sendrawtransaction", out).await
    }
    
    /// Send an amount to a given address.
    pub async fn send_to_address(&self, address: String, amount: f64, comment: Option<String>, comment_to: Option<String>, subtractfeefromamount: Option<bool>, replaceable: Option<bool>, conf_target: Option<f64>, estimate_mode: Option<String>, avoid_reuse: Option<bool>, fee_rate: Option<f64>, verbose: Option<bool>) -> crate::RpcResult<SendToAddress> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 11];
        params[0] = Some(serde_json::to_value(address)?);
        params[1] = Some(serde_json::to_value(amount)?);
        if let Some(value) = comment {
            params[2] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = comment_to {
            params[3] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = subtractfeefromamount {
            params[4] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = replaceable {
            params[5] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = conf_target {
            params[6] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = estimate_mode {
            params[7] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = avoid_reuse {
            params[8] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = fee_rate {
            params[9] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = verbose {
            params[10] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("sendtoaddress", out).await
    }
    
    /// Attempts to add or remove an IP/Subnet from the banned list.
    pub async fn set_ban(&self, subnet: String, command: String, ban_time: Option<f64>, absolute: Option<bool>) -> crate::RpcResult<()> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 4];
        params[0] = Some(serde_json::to_value(subnet)?);
        params[1] = Some(serde_json::to_value(command)?);
        if let Some(value) = ban_time {
            params[2] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = absolute {
            params[3] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("setban", out).await
    }
    
    /// Sets the label associated with the given address.
    pub async fn set_label(&self, address: String, label: String) -> crate::RpcResult<()> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(address)?);
        params[1] = Some(serde_json::to_value(label)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("setlabel", out).await
    }
    
    /// Set the local time to given timestamp (-regtest only)
    pub async fn set_mock_time(&self, timestamp: f64) -> crate::RpcResult<()> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(timestamp)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("setmocktime", out).await
    }
    
    /// Disable/enable all p2p network activity.
    pub async fn set_network_active(&self, state: bool) -> crate::RpcResult<bool> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(state)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("setnetworkactive", out).await
    }
    
    /// (DEPRECATED) Set the transaction fee rate in BTC/kvB for this wallet. Overrides the global -paytxfee command line parameter.
    pub async fn set_tx_fee(&self, amount: f64) -> crate::RpcResult<bool> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(amount)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("settxfee", out).await
    }
    
    /// Change the state of the given wallet flag for a wallet.
    pub async fn set_wallet_flag(&self, flag: String, value: Option<bool>) -> crate::RpcResult<SetWalletFlag> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(flag)?);
        if let Some(value) = value {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("setwalletflag", out).await
    }
    
    /// Sign a message with the private key of an address
    pub async fn sign_message(&self, address: String, message: String) -> crate::RpcResult<String> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(address)?);
        params[1] = Some(serde_json::to_value(message)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("signmessage", out).await
    }
    
    /// Sign a message with the private key of an address
    pub async fn sign_message_with_privkey(&self, privkey: String, message: String) -> crate::RpcResult<String> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(privkey)?);
        params[1] = Some(serde_json::to_value(message)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("signmessagewithprivkey", out).await
    }
    
    /// Sign inputs for raw transaction (serialized, hex-encoded).
    pub async fn sign_raw_transaction_with_key(&self, hexstring: String, priv_keys: Vec<String>, prevtxs: Option<Vec<SignRawTransactionWithKeyPrevtxsItem>>, sighash_type: Option<String>) -> crate::RpcResult<SignRawTransactionWithKey> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 4];
        params[0] = Some(serde_json::to_value(hexstring)?);
        params[1] = Some(serde_json::to_value(priv_keys)?);
        if let Some(value) = prevtxs {
            params[2] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = sighash_type {
            params[3] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("signrawtransactionwithkey", out).await
    }
    
    /// Sign inputs for raw transaction (serialized, hex-encoded).
    pub async fn sign_raw_transaction_with_wallet(&self, hexstring: String, prevtxs: Option<Vec<SignRawTransactionWithWalletPrevtxsItem>>, sighash_type: Option<String>) -> crate::RpcResult<SignRawTransactionWithWallet> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(hexstring)?);
        if let Some(value) = prevtxs {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = sighash_type {
            params[2] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("signrawtransactionwithwallet", out).await
    }
    
    /// Calculate the balance change resulting in the signing and broadcasting of the given transaction(s).
    pub async fn simulate_raw_transaction(&self, raw_txs: Option<Vec<String>>, options: Option<SimulateRawTransactionOptions>) -> crate::RpcResult<SimulateRawTransaction> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        if let Some(value) = raw_txs {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = options {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("simulaterawtransaction", out).await
    }
    
    /// Request a graceful shutdown of Bitcoin Core.
    pub async fn stop(&self, wait: Option<f64>) -> crate::RpcResult<String> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        if let Some(value) = wait {
            params[0] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("stop", out).await
    }
    
    /// Attempts to submit new block to network.
    pub async fn submit_block(&self, hex_data: String, dummy: Option<String>) -> crate::RpcResult<Option<String>> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(hex_data)?);
        if let Some(value) = dummy {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("submitblock", out).await
    }
    
    /// Decode the given hexdata as a header and submit it as a candidate chain tip if valid.
    pub async fn submit_header(&self, hex_data: String) -> crate::RpcResult<()> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(hex_data)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("submitheader", out).await
    }
    
    /// Submit a package of raw transactions (serialized, hex-encoded) to local node.
    pub async fn submit_package(&self, package: Vec<String>, max_fee_rate: Option<f64>, maxburnamount: Option<f64>) -> crate::RpcResult<SubmitPackage> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(package)?);
        if let Some(value) = max_fee_rate {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = maxburnamount {
            params[2] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("submitpackage", out).await
    }
    
    /// Waits for the validation interface queue to catch up on everything that was there when we entered this function.
    pub async fn sync_with_validation_interface_queue(&self) -> crate::RpcResult<()> {
        self.call("syncwithvalidationinterfacequeue", Vec::new()).await
    }
    
    /// Returns result of mempool acceptance tests indicating if raw transaction(s) (serialized, hex-encoded) would be accepted by mempool.
    pub async fn test_mempool_accept(&self, raw_txs: Vec<String>, max_fee_rate: Option<f64>) -> crate::RpcResult<Vec<TestMempoolAcceptItem>> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(raw_txs)?);
        if let Some(value) = max_fee_rate {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("testmempoolaccept", out).await
    }
    
    /// Unloads the wallet referenced by the request endpoint or the wallet_name argument.
    pub async fn unload_wallet(&self, wallet_name: Option<String>, load_on_startup: Option<bool>) -> crate::RpcResult<UnloadWallet> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        if let Some(value) = wallet_name {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = load_on_startup {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("unloadwallet", out).await
    }
    
    /// Returns the total uptime of the server.
    pub async fn uptime(&self) -> crate::RpcResult<f64> {
        self.call("uptime", Vec::new()).await
    }
    
    /// Updates all segwit inputs and outputs in a PSBT with data from output descriptors, the UTXO set, txindex, or the mempool.
    pub async fn utxo_update_psbt(&self, psbt: String, descriptors: Option<Vec<Value>>) -> crate::RpcResult<String> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(psbt)?);
        if let Some(value) = descriptors {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("utxoupdatepsbt", out).await
    }
    
    /// Return information about the given bitcoin address.
    pub async fn validate_address(&self, address: String) -> crate::RpcResult<ValidateAddress> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(address)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("validateaddress", out).await
    }
    
    /// Verifies blockchain database.
    pub async fn verify_chain(&self, checklevel: Option<f64>, n_blocks: Option<f64>) -> crate::RpcResult<bool> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        if let Some(value) = checklevel {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = n_blocks {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("verifychain", out).await
    }
    
    /// Verify a signed message.
    pub async fn verify_message(&self, address: String, signature: String, message: String) -> crate::RpcResult<bool> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 3];
        params[0] = Some(serde_json::to_value(address)?);
        params[1] = Some(serde_json::to_value(signature)?);
        params[2] = Some(serde_json::to_value(message)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("verifymessage", out).await
    }
    
    /// Verifies that a proof points to a transaction in a block, returning the transaction it commits to
    pub async fn verify_tx_out_proof(&self, proof: String) -> crate::RpcResult<Vec<String>> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(proof)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("verifytxoutproof", out).await
    }
    
    /// Waits for a specific new block and returns useful info about it.
    pub async fn wait_for_block(&self, block_hash: String, timeout: Option<f64>) -> crate::RpcResult<WaitForBlock> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(block_hash)?);
        if let Some(value) = timeout {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("waitforblock", out).await
    }
    
    /// Waits for (at least) block height and returns the height and hash
    pub async fn wait_for_block_height(&self, height: f64, timeout: Option<f64>) -> crate::RpcResult<WaitForBlockHeight> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(height)?);
        if let Some(value) = timeout {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("waitforblockheight", out).await
    }
    
    /// Waits for any new block and returns useful info about it.
    pub async fn wait_for_new_block(&self, timeout: Option<f64>, current_tip: Option<String>) -> crate::RpcResult<WaitForNewBlock> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        if let Some(value) = timeout {
            params[0] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = current_tip {
            params[1] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("waitfornewblock", out).await
    }
    
    /// Creates and funds a transaction in the Partially Signed Transaction format.
    pub async fn wallet_create_funded_psbt(&self, inputs: Option<Vec<WalletCreateFundedPsbtInputsItem>>, outputs: Vec<Value>, lock_time: Option<f64>, options: Option<WalletCreateFundedPsbtOptions>, bip32_derivs: Option<bool>, version: Option<f64>) -> crate::RpcResult<WalletCreateFundedPsbt> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 6];
        if let Some(value) = inputs {
            params[0] = Some(serde_json::to_value(value)?);
        }
        params[1] = Some(serde_json::to_value(outputs)?);
        if let Some(value) = lock_time {
            params[2] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = options {
            params[3] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = bip32_derivs {
            params[4] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = version {
            params[5] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("walletcreatefundedpsbt", out).await
    }
    
    /// Display address on an external signer for verification.
    pub async fn wallet_display_address(&self, address: String) -> crate::RpcResult<WalletDisplayAddress> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 1];
        params[0] = Some(serde_json::to_value(address)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("walletdisplayaddress", out).await
    }
    
    /// Removes the wallet encryption key from memory, locking the wallet.
    pub async fn wallet_lock(&self) -> crate::RpcResult<()> {
        self.call("walletlock", Vec::new()).await
    }
    
    /// Stores the wallet decryption key in memory for 'timeout' seconds.
    pub async fn wallet_passphrase(&self, passphrase: String, timeout: f64) -> crate::RpcResult<()> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(passphrase)?);
        params[1] = Some(serde_json::to_value(timeout)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("walletpassphrase", out).await
    }
    
    /// Changes the wallet passphrase from 'oldpassphrase' to 'newpassphrase'.
    pub async fn wallet_passphrase_change(&self, oldpassphrase: String, new_passphrase: String) -> crate::RpcResult<()> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 2];
        params[0] = Some(serde_json::to_value(oldpassphrase)?);
        params[1] = Some(serde_json::to_value(new_passphrase)?);
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("walletpassphrasechange", out).await
    }
    
    /// Update a PSBT with input information from our wallet and then sign inputs
    pub async fn wallet_process_psbt(&self, psbt: String, sign: Option<bool>, sighash_type: Option<String>, bip32_derivs: Option<bool>, finalize: Option<bool>) -> crate::RpcResult<WalletProcessPsbt> {
        let out = {
        let mut params: Vec<Option<serde_json::Value>> = vec![None; 5];
        params[0] = Some(serde_json::to_value(psbt)?);
        if let Some(value) = sign {
            params[1] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = sighash_type {
            params[2] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = bip32_derivs {
            params[3] = Some(serde_json::to_value(value)?);
        }
        if let Some(value) = finalize {
            params[4] = Some(serde_json::to_value(value)?);
        }
        let mut last_some: Option<usize> = None;
        for (idx, item) in params.iter().enumerate() {
            if item.is_some() {
                last_some = Some(idx);
            }
        }
        let mut out = Vec::new();
        if let Some(last) = last_some {
            for (idx, item) in params.into_iter().enumerate() {
                if idx > last { break; }
                out.push(item.unwrap_or(serde_json::Value::Null));
            }
        }
        out
        };
        self.call("walletprocesspsbt", out).await
    }
}
